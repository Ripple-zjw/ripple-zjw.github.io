<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeaveIt on LeaveIt</title>
    <link>https://ripple-zjw.github.io/</link>
    <description>Recent content in LeaveIt on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 19 Aug 2019 22:52:15 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>132模式</title>
      <link>https://ripple-zjw.github.io/2019/132%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 19 Aug 2019 22:52:15 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/132%E6%A8%A1%E5%BC%8F/</guid>
      <description>

&lt;h1 id=&#34;题目-132模式&#34;&gt;题目：132模式&lt;/h1&gt;

&lt;p&gt;给定一个整数序列：&lt;code&gt;a1, a2, ..., an&lt;/code&gt;，一个132模式的子序列&lt;code&gt;ai, aj, ak&lt;/code&gt;被定义为：当 &lt;code&gt;i &amp;lt; j &amp;lt; k&lt;/code&gt;时，&lt;code&gt;ai &amp;lt; ak &amp;lt; aj&lt;/code&gt;。设计一个算法，当给定有 n 个数字的序列时，验证这个序列中是否含有132模式的子序列。
- 注意：n 的值小于15000。&lt;/p&gt;

&lt;h5 id=&#34;示例1&#34;&gt;示例1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1, 2, 3, 4]
输出: False
解释: 序列中不存在132模式的子序列。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [3, 1, 4, 2]
输出: True
解释: 序列中有 1 个132模式的子序列： [1, 4, 2].
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-3&#34;&gt;示例 3:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [-1, 3, 2, 0]
输出: True
解释: 序列中有 3 个132模式的的子序列: [-1, 3, 2], [-1, 3, 0] 和 [-1, 2, 0].
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第456题&#34;&gt;来源：力扣（LeetCode）第456题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/132-pattern&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/132-pattern&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;分析&#34;&gt;分析：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;还是单调栈，不过还需要用到另一个方法，逆向工作法。反向遍历列表就会发现不一样的做法。&lt;/li&gt;
&lt;li&gt;根据题意&lt;code&gt;1&lt;/code&gt;代表最小元素，&lt;code&gt;3&lt;/code&gt;代表最大元素，&lt;code&gt;2&lt;/code&gt;代表次大元素&lt;/li&gt;
&lt;li&gt;通过单调递减栈找到最大元素的最大次大元素，然后再确定最小元素要比最大次大元素小。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;反向遍历列表。&lt;/li&gt;
&lt;li&gt;严格维护一个单调递减栈。&lt;/li&gt;
&lt;li&gt;一旦遇到一个大的元素，将栈内元素出栈，维护单调递减。入栈后，将自己作为题目中的最大元素，即中间的元素。&lt;/li&gt;
&lt;li&gt;将最后一个出栈的元素作为次大元素，即右边的元素。&lt;/li&gt;
&lt;li&gt;这样的好处是我找到的次大元素一定是与当前最大元素的值最近的，而且还在最大元素的后面。&lt;/li&gt;
&lt;li&gt;这样我只要在前面找到一个比次大元素小的值，也就是最小值，那么就是True。&lt;/li&gt;
&lt;li&gt;如果找不到，那么可能有两种情况。

&lt;ul&gt;
&lt;li&gt;第一种在最大元素和次大元素之间，最小值比最大的次大元素还要大，不符合题意。但是要维护单调递减栈，所以入栈。&lt;/li&gt;
&lt;li&gt;第二种在最大元素之上，那么用刚才的方法重新确定最大元素和次大元素。由于它在最大元素之上，当它为最大元素时它能包括之前的最大元素在内，重新确定的次大元素一定会比之前的次大元素大。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果遍历完为止都没有返回True，那么返回False。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;上代码&#34;&gt;上代码：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def find132pattern(self, nums: List[int]) -&amp;gt; bool:
        stack = []
        _min = float(&#39;-inf&#39;)
        for i in range(len(nums) - 1, -1, -1):
            if nums[i] &amp;lt; _min:
                return True
            while stack and stack[-1] &amp;lt; nums[i]:
                _min = stack.pop()
            stack.append(nums[i])
        return False
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为列表的长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;逆向工作法，如果你想不出来细节时可以考虑使用。&lt;/li&gt;
&lt;li&gt;我一开始的思路是正向遍历，维护一个单调递减栈。&lt;/li&gt;
&lt;li&gt;然后确定一个最小值，但是次大元素在右边，所以单调栈内无法找到次大元素。如果次大元素在左边的话，就可以直接正向单调递减了。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>验证二叉树的前序序列化</title>
      <link>https://ripple-zjw.github.io/2019/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96/</link>
      <pubDate>Mon, 19 Aug 2019 22:51:58 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
      <description>

&lt;h1 id=&#34;题目-验证二叉树的前序序列化&#34;&gt;题目：验证二叉树的前序序列化&lt;/h1&gt;

&lt;p&gt;序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     _9_
    /   \
   3     2
  / \   / \
 4   1  #  6
/ \ / \   / \
# # # #   # #
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;例如，上面的二叉树可以被序列化为字符串 &lt;code&gt;&amp;quot;9,3,4,#,#,1,#,#,2,#,6,#,#&amp;quot;&lt;/code&gt;，其中 &lt;code&gt;#&lt;/code&gt;代表一个空节点。&lt;/li&gt;
&lt;li&gt;给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。&lt;/li&gt;
&lt;li&gt;每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 &lt;code&gt;&#39;#&#39;&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如&lt;code&gt;&amp;quot;1,,3&amp;quot;&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;9,3,4,#,#,1,#,#,2,#,6,#,#&amp;quot;
输出: true
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;1,#&amp;quot;
输出: false
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-3&#34;&gt;示例 3:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;9,#,#,1&amp;quot;
输出: false
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第331题&#34;&gt;来源：力扣（LeetCode）第331题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;分析&#34;&gt;分析：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;就是每个爸爸都要找到两个儿子。(两个儿子可以是数字也可以是&lt;code&gt;#&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#&lt;/code&gt;爸爸什么都没有，比较惨。&lt;/li&gt;
&lt;li&gt;上面两条任意一条不对都不合法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;前序遍历严格遵守中，左，右的顺序。&lt;/li&gt;
&lt;li&gt;所以第一个为根节点，到第一个&lt;code&gt;#&lt;/code&gt;为止，前面这些数字都是根节点的最左边的左子节点&lt;/li&gt;
&lt;li&gt;维护一个栈&lt;code&gt;stack&lt;/code&gt;，栈中存的是未确认它是否有两个子节点的节点，就是说如果该节点找到了他的两个子节点，就出栈(&lt;code&gt;#&lt;/code&gt;也算它的子节点)。&lt;/li&gt;
&lt;li&gt;凡是找到数字，全都入栈，因为一开始找到数字，你只能确认它的左子节点是下一个值(数字或&lt;code&gt;#&lt;/code&gt;)，无法知道它的右子节点。&lt;/li&gt;
&lt;li&gt;当找到第一个&lt;code&gt;#&lt;/code&gt;时，开始遍历右子节点。因为没有左子节点了，遍历最近的节点的右子节点，也就是栈顶元素！！！&lt;/li&gt;
&lt;li&gt;一旦遍历了右子节点，那么该节点的左右子节点都找到了，出栈。&lt;/li&gt;
&lt;li&gt;接下来继续重复之前的规律，如果字符串合法，那么stack中的元素都被弹出去了，如果栈中还有元素，那么就说明有的元素找不到它的两个儿子。&lt;/li&gt;
&lt;li&gt;大概是这么个思路，不过还有些细节要处理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;看我写的代码&#34;&gt;看我写的代码：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isValidSerialization(self, preorder: str) -&amp;gt; bool:
        if preorder == &#39;&#39;:
            return False
        if preorder == &#39;#&#39;:
            return True
        pol = preorder.split(&#39;,&#39;)  # PreOrderList
        stack = []  # 只有数字入栈，当确认了该数字的两个子节点后出栈
        n = len(pol)
        isLeftTree = True  # 如果现在遍历的是左子树的话，不用出栈，如果为右子树的话无论是什么都要出栈
        for i in range(n):
            if pol[i].isdigit():
                if not isLeftTree:
                    if not stack:  # 如果栈是空的还要弹元素的话说明这字符串不合法。
                        return False
                    stack.pop()
                stack.append(pol[i])  # 无论是左子树还是右子树，遇到数字都要入栈
                isLeftTree = True  # 如果遍历到的是数字的话，那么又开始遍历左子树了。
            else:
                isLeftTree = False  # 当左子树遍历到#号时那么左子树完了，开始遍历右子树。
                if pol[i - 1] == &#39;#&#39;:
                    if not stack:
                        return False
                    stack.pop()
        return len(stack) == 0  # 栈为空就说明合法，每一个节点都找到了它的两个子节点了。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为pol列表长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;p&gt;写的不是最优，总的来说就是将数据分为遍历左子树和右子树两种情况。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>移掉K位数字</title>
      <link>https://ripple-zjw.github.io/2019/%E7%A7%BB%E6%8E%89k%E4%BD%8D%E6%95%B0%E5%AD%97/</link>
      <pubDate>Mon, 19 Aug 2019 22:51:46 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%A7%BB%E6%8E%89k%E4%BD%8D%E6%95%B0%E5%AD%97/</guid>
      <description>

&lt;h1 id=&#34;题目-移掉k位数字&#34;&gt;题目：移掉K位数字&lt;/h1&gt;

&lt;p&gt;给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。&lt;/p&gt;

&lt;h5 id=&#34;注意&#34;&gt;注意:&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;num 的长度小于 10002 且 ≥ k。&lt;/li&gt;
&lt;li&gt;num 不会包含任何前导零。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1 :&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: num = &amp;quot;1432219&amp;quot;, k = 3
输出: &amp;quot;1219&amp;quot;
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2 :&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: num = &amp;quot;10200&amp;quot;, k = 1
输出: &amp;quot;200&amp;quot;
解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-3&#34;&gt;示例 3 :&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: num = &amp;quot;10&amp;quot;, k = 2
输出: &amp;quot;0&amp;quot;
解释: 从原数字移除所有的数字，剩余为空就是0。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第402题&#34;&gt;来源：力扣（LeetCode）第402题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/remove-k-digits&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/remove-k-digits&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;分析&#34;&gt;分析：&lt;/h3&gt;

&lt;p&gt;维护一个单调递增栈，主要的方法很容易想到，但是在处理细节上我还是费了的时间，其实不难处理但是我想的有点复杂了。&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;维护一个单调递增栈。&lt;/li&gt;
&lt;li&gt;依次遍历整个字符串，将元素放入栈，同时使单调栈严格单调递增。&lt;/li&gt;
&lt;li&gt;如果已经弹出去k个元素了，那么剩下的值直接放入栈中即可，不用再删了。&lt;/li&gt;
&lt;li&gt;如果还没到k个元素字符串就遍历完了，那么根据剩下还要加的元素数量，从栈顶依次出栈。&lt;/li&gt;
&lt;li&gt;栈有可能是空，根据示例3，栈为空答案时&lt;code&gt;&amp;quot;0&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果栈有值，那么将栈合并为字符串，得出答案。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;激动人心的代码环节&#34;&gt;激动人心的代码环节：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def removeKdigits(self, num: str, k: int) -&amp;gt; str:
        stack = []
        cnt = 0
        n = len(num)
        for i in range(n):
            while cnt &amp;lt; k and stack and stack[-1] &amp;gt; num[i]:
                tmp = stack.pop()
                cnt += 1
            if stack or num[i] != &#39;0&#39;:
                stack.append(num[i])
        while stack and cnt &amp;lt; k:
            stack.pop()
            cnt += 1
        ans = &#39;&#39;.join(stack)
        return ans if ans != &#39;&#39; else &#39;0&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为字符串的长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n) n为k的长度&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;单调栈的思想越来越熟了，但是在处理细节上还是不够熟练。&lt;/li&gt;
&lt;li&gt;虽然自己第一遍做出来了，但是并没有想到最优算法，写的稍微有的啰嗦了。&lt;/li&gt;
&lt;li&gt;我觉得一开始没处理好是因为我忽略了k这个值，于是关于k的细节没有想得很全面，导致最后自己测试时总是会发现一些小错误，浪费时间。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>搭建Hugo时需要注意的坑</title>
      <link>https://ripple-zjw.github.io/2019/%E6%90%AD%E5%BB%BAhugo%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9D%91/</link>
      <pubDate>Sat, 17 Aug 2019 18:58:39 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%90%AD%E5%BB%BAhugo%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9D%91/</guid>
      <description>

&lt;h1 id=&#34;搭建hugo时需要注意的坑&#34;&gt;搭建Hugo时需要注意的坑&lt;/h1&gt;

&lt;p&gt;Hugo是一种博客框架，可以说是非常优秀的博客框架。基于go语言，网页生成的速度非常的快，而且下载简单，在GitHub上就能下载，还有官方的中文文档，操作也是很简单。但是对于刚开始搭建博客的小白，还是会遇到各种各样的问题，在这里我把我遇到的坑分享给各位读者。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;从GitHub上把Hugo下载下来会慢，当然也有人网速没问题。这个问题可以找网上的一些方法，比如改hosts文件。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可能有人和我一样下载完解压后在终端输入&lt;code&gt;hugo xxx&lt;/code&gt;的命令无效，那是因为系统找不到你要输的是什么东西，有两种解决方法。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一种是每次输入命令都带上你&lt;code&gt;hugo.exe&lt;/code&gt;文件的绝对路径，但是这样太麻烦了。&lt;/li&gt;
&lt;li&gt;第二种是将&lt;code&gt;hugo.exe&lt;/code&gt;添加到你系统的环境变量中，这样直接输入hugo就能启动命令了。&lt;/li&gt;
&lt;li&gt;设置方法为：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;控制面板 &amp;gt; 系统和安全 &amp;gt; 系统 &amp;gt; 高级系统设置 &amp;gt; 高级 &amp;gt; 环境变量&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;上下两个一个是用户变量，一个是系统变量，建议两个都设置。&lt;/li&gt;
&lt;li&gt;点击&lt;code&gt;Path&lt;/code&gt;变量，然后点击&lt;code&gt;新建&lt;/code&gt;，将你&lt;code&gt;hugo.exe&lt;/code&gt;的绝对路径目录添加进去，注意是目录。不要把&lt;code&gt;hugo.exe&lt;/code&gt;带进去。例如：你的目录为&lt;code&gt;c:/xxx/xxx/hugo.exe&lt;/code&gt;，你只要添加&lt;code&gt;c:/xxx/xxx&lt;/code&gt;就行了。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;主题是下载到&lt;code&gt;themes\&lt;/code&gt;文件夹中的，用git clone。如果不会使用git，请参考我关于git的文章&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下载完之后，里面基本都会有一个&lt;code&gt;exampleSite\&lt;/code&gt;文件夹，里面放的是一个样式，你可以直接把里面的&lt;code&gt;config.toml&lt;/code&gt;中的内容复制到你的博客主目录的&lt;code&gt;config.toml&lt;/code&gt;中。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;你博客根目录的&lt;code&gt;config.toml&lt;/code&gt;文件里要把&lt;code&gt;baseURL&lt;/code&gt;参数换成你的博客网站网址，如果你还没有部署到网上，可以填你的本地网址，就是那个默认端口1313的那个。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;你部署好之后，如果想要继续添加文章，首先使用&lt;code&gt;hugo&lt;/code&gt;命令重新生成&lt;code&gt;public/&lt;/code&gt;文件夹，然后在里面用git添加，提交，上传就行了。与第一次部署时的操作一样。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;### 以上差不多就是我遇到的坑。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>字符串解码</title>
      <link>https://ripple-zjw.github.io/2019/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</link>
      <pubDate>Sat, 17 Aug 2019 18:51:43 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</guid>
      <description>

&lt;h1 id=&#34;题目-字符串解码&#34;&gt;题目：字符串解码&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个经过编码的字符串，返回它解码后的字符串。&lt;/li&gt;
&lt;li&gt;编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。&lt;/li&gt;
&lt;li&gt;你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。&lt;/li&gt;
&lt;li&gt;此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&#34;示例&#34;&gt;示例:&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;s = &amp;quot;3[a]2[bc]&amp;quot;, 返回 &amp;quot;aaabcbc&amp;quot;.
s = &amp;quot;3[a2[c]]&amp;quot;, 返回 &amp;quot;accaccacc&amp;quot;.
s = &amp;quot;2[abc]3[cd]ef&amp;quot;, 返回 &amp;quot;abcabccdcdcdef&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第394题&#34;&gt;来源：力扣（LeetCode）第394题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/decode-string&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/decode-string&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;分析&#34;&gt;分析：&lt;/h3&gt;

&lt;p&gt;两种方法，辅助栈法和递归法，递归法相对思路清晰，比较好做。其实本质两种方法是一样的，因为函数的递归调用其实也是用栈来实现的。&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;递归法：

&lt;ul&gt;
&lt;li&gt;遍历整个字符串&lt;/li&gt;
&lt;li&gt;同时要用到stack列表，tmp列表，还有一个表示下标的变量i&lt;/li&gt;
&lt;li&gt;每次递归之后stack都是该函数的stack，与外面的stack不同&lt;/li&gt;
&lt;li&gt;每次遍历字符时，tmp都要将里面的值清空&lt;/li&gt;
&lt;li&gt;遇到字母，压入stack&lt;/li&gt;
&lt;li&gt;遇到&lt;code&gt;]&lt;/code&gt;字符,结束函数并将stack返回&lt;/li&gt;
&lt;li&gt;遇到数字首先判断该数字后是否还有数字，有的话一起加入tmp，然后递归调用函数。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;辅助栈法：

&lt;ul&gt;
&lt;li&gt;遍历整个字符串&lt;/li&gt;
&lt;li&gt;res表示当前字符串，multi表示当前数字，stack储存答案&lt;/li&gt;
&lt;li&gt;遇到字母，与res拼接起来&lt;/li&gt;
&lt;li&gt;遇到数字，放入multi，注意由于两个数字放在一起要变成两位数，以此类推，所以res 写成&lt;code&gt;res = res * 10 + 当前数字&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;遇到&lt;code&gt;[&lt;/code&gt;，将res，multi同时入栈，用一个列表或元祖，并行的，不是先后入栈。&lt;/li&gt;
&lt;li&gt;遇到右括号，栈顶元素出栈，并将栈顶元素的multi与当前字符相乘，然后再与栈顶的res相加&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;上代码&#34;&gt;上代码：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;递归法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def decodeString(self, s: str) -&amp;gt; str:
        self.i = 0
        return &#39;&#39;.join(self.recursion(s))
            
    def recursion(self, s: str) -&amp;gt; list:
        stack = []
        while self.i &amp;lt; len(s):
            tmp = []
            if s[self.i].isalpha():
                stack.append(s[self.i])
            elif s[self.i] == &#39;]&#39;:
                return stack
            elif s[self.i].isdigit():
                tmp.append(s[self.i])
                while s[self.i + 1].isdigit():
                    tmp.append(s[self.i + 1])
                    self.i += 1
                self.i += 2
                stack += (int(&#39;&#39;.join(tmp)) * self.recursion(s))
            self.i += 1
        return stack
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;辅助栈法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def decodeString(self, s: str) -&amp;gt; str:
        stack, res, multi = [], &amp;quot;&amp;quot;, 0
        for c in s:
            if c == &#39;[&#39;:
                stack.append([multi, res])
                res, multi = &amp;quot;&amp;quot;, 0
            elif c == &#39;]&#39;:
                cur_multi, last_res = stack.pop()
                res = last_res + cur_multi * res
            elif &#39;0&#39; &amp;lt;= c &amp;lt;= &#39;9&#39;:
                multi = multi * 10 + int(c)            
            else:
                res += c
        return res
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;辅助栈法不是我自己写的，可以参考LeetCode上的作者：
&amp;gt; &lt;a href=&#34;https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;递归法：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为字符串长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;辅助栈法：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为字符串长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;递归是一种不错的尝试，很多时候递归的时间耗时并不是非常高，而且解题方便。&lt;/li&gt;
&lt;li&gt;写这种题目前需要理清各种情况时的行为。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>下一个更大元素</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0ii/</link>
      <pubDate>Sat, 17 Aug 2019 18:50:56 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0ii/</guid>
      <description>

&lt;h1 id=&#34;题目-下一个更大元素-ii&#34;&gt;题目：下一个更大元素 II&lt;/h1&gt;

&lt;p&gt;给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。&lt;/p&gt;

&lt;h6 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第503题&#34;&gt;来源：力扣（LeetCode）第503题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/next-greater-element-ii&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/next-greater-element-ii&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;分析&#34;&gt;分析：&lt;/h3&gt;

&lt;p&gt;循环数组和循环队列的样子差不多，这道题主要是单调栈，同样涉及两种解法，暴力法和单调栈法。这题的难点不在于单调栈，而是循环数组什么时候停下来。&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;由于是循环数组，如果只遍历一遍无法完全找到答案，所以我们遍历两边数组，使得数组较后的元素能与前面的元素比对。&lt;/li&gt;
&lt;li&gt;当下表(i)比数组的最后一个下表大时，i % len(数组)&lt;/li&gt;
&lt;li&gt;初始化所有答案均为-1(如果找不到最大的是-1，所以先全部等于-1)&lt;/li&gt;
&lt;li&gt;维护一个单调递减栈，入栈元素将比它小的栈内元素全部出栈，出栈元素的答案就是入栈元素。&lt;/li&gt;
&lt;li&gt;如此循环两次，如果栈内元素在两次循环之后均未能出栈(找到比它大的元素),那么它们就是数组中最大的元素，又由于我们初始化答案全部为-1，所以不用改变它们。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;上代码&#34;&gt;上代码:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution(object):
    def nextGreaterElements(self, nums):
        &amp;quot;&amp;quot;&amp;quot;
        :type nums: List[int]
        :rtype: List[int]
        &amp;quot;&amp;quot;&amp;quot;
        stack = []
        n = len(nums)
        res = [-1 for _ in nums]
        for i in range(2 * n):
            while stack and nums[i % n] &amp;gt; nums[stack[-1]]:
                res[stack.pop()] = nums[i % n]
            stack.append(i % n)
        return res
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一并给出暴力法(时间太长，会超时)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def nextGreaterElements(self, nums: List[int]) -&amp;gt; List[int]:
        n = len(nums)
        ans = []
        for i in range(n):
            j = i
            while True:
                j = (j + 1) % n
                if nums[j] &amp;gt; nums[i]:
                    ans.append(nums[j])
                    break
                if j + 1 == i:
                    ans.append(-1)
                    break
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;复杂地分析&#34;&gt;复杂地分析:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;暴力法:&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂地：O(n^2^)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;单调栈法:

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为数组长度

&lt;ul&gt;
&lt;li&gt;最好情况 n = 3n&lt;/li&gt;
&lt;li&gt;最差情况 n = 4n&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n) n为数组长度 n = 2n(最差)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;使用单调栈解这类题目非常合适。&lt;/li&gt;
&lt;li&gt;如果实在无法找到结束循环点，不妨全部再遍历一遍数组。&lt;/li&gt;
&lt;li&gt;单调栈不一定要全部将栈中的元素都拿出来，如果有元素没有合适的答案，留在栈中也是可以的。&lt;/li&gt;
&lt;li&gt;初始化答案数组是一个不错方法，保证数组内的元素在找不到合适的答案时也能满足题目要求。(比如这道题说如果没有比它大的元素，那么它的答案为-1，所以我们就全部初始化为-1)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>扁平化嵌套列表迭代器</title>
      <link>https://ripple-zjw.github.io/2019/%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Sat, 17 Aug 2019 18:50:30 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>

&lt;h1 id=&#34;题目-扁平化嵌套列表迭代器&#34;&gt;题目:扁平化嵌套列表迭代器&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个嵌套的整型列表。设计一个迭代器，使其能够遍历这个整型列表中的所有整数。&lt;/li&gt;
&lt;li&gt;列表中的项或者为一个整数，或者是另一个列表。&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;输入: [[1,1],2,[1,1]]
输出: [1,1,2,1,1]
解释: 通过重复调用 next 直到 hasNext 返回false，next 返回的元素的顺序应该是: [1,1,2,1,1]。
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,[4,[6]]]
输出: [1,4,6]
解释: 通过重复调用 next 直到 hasNext 返回false，next 返回的元素的顺序应该是: [1,4,6]。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第341题&#34;&gt;来源：力扣（LeetCode）第341题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/flatten-nested-list-iterator&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/flatten-nested-list-iterator&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;分析&#34;&gt;分析：&lt;/h3&gt;

&lt;p&gt;递归调用，不是很难。唯一要注意的是要看清题目，list里面是NestedIterator，需要使用他给你的方法调用才能得到integer或者list。&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;从后往前遍历&lt;/li&gt;
&lt;li&gt;判断是否是integer，是  入栈  不是  递归进去&lt;/li&gt;
&lt;li&gt;返回栈，结束。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# &amp;quot;&amp;quot;&amp;quot;
# This is the interface that allows for creating nested lists.
# You should not implement it, or speculate about its implementation
# &amp;quot;&amp;quot;&amp;quot;
#class NestedInteger(object):
#    def isInteger(self):
#        &amp;quot;&amp;quot;&amp;quot;
#        @return True if this NestedInteger holds a single integer, rather than a nested list.
#        :rtype bool
#        &amp;quot;&amp;quot;&amp;quot;
#
#    def getInteger(self):
#        &amp;quot;&amp;quot;&amp;quot;
#        @return the single integer that this NestedInteger holds, if it holds a single integer
#        Return None if this NestedInteger holds a nested list
#        :rtype int
#        &amp;quot;&amp;quot;&amp;quot;
#
#    def getList(self):
#        &amp;quot;&amp;quot;&amp;quot;
#        @return the nested list that this NestedInteger holds, if it holds a nested list
#        Return None if this NestedInteger holds a single integer
#        :rtype List[NestedInteger]
#        &amp;quot;&amp;quot;&amp;quot;

class NestedIterator(object):  # 注意看清上面的方法都是干什么的，虽然是英文但是也比较容易看懂。
    def __init__(self, nestedList):
        &amp;quot;&amp;quot;&amp;quot;
        Initialize your data structure here.
        :type nestedList: List[NestedInteger]
        &amp;quot;&amp;quot;&amp;quot;
        self.stack = []
        self.recursion(nestedList)


    def recursion(self, nestedList):
        for i in range(len(nestedList) - 1, -1, -1):
            if nestedList[i].isInteger():
                self.stack.append(nestedList[i].getInteger())
            else:
                self.recursion(nestedList[i].getList())


    def next(self):
        &amp;quot;&amp;quot;&amp;quot;
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        return self.stack.pop()
        

    def hasNext(self):
        &amp;quot;&amp;quot;&amp;quot;
        :rtype: bool
        &amp;quot;&amp;quot;&amp;quot;
        return len(self.stack) &amp;gt; 0

# Your NestedIterator object will be instantiated and called as such:
# i, v = NestedIterator(nestedList), []
# while i.hasNext(): v.append(i.next())
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n 为整个列表的元素，也就是最后stack里的元素。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;p&gt;还是很简单的，只要递归写的稍微熟练一点都能写的出来。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>二叉树的锯齿形层次遍历</title>
      <link>https://ripple-zjw.github.io/2019/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sat, 17 Aug 2019 18:48:01 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</guid>
      <description>

&lt;h1 id=&#34;题目-二叉树的锯齿形层次遍历&#34;&gt;题目: 二叉树的锯齿形层次遍历&lt;/h1&gt;

&lt;p&gt;给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。&lt;/p&gt;

&lt;h6 id=&#34;例如&#34;&gt;例如：&lt;/h6&gt;

&lt;p&gt;给定二叉树 [3,9,20,null,null,15,7],&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    3
   / \
  9  20
    /  \
   15   7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回锯齿形层次遍历如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  [3],
  [20,9],
  [15,7]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第103题&#34;&gt;来源：力扣（LeetCode）第103题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;分析&#34;&gt;分析:&lt;/h3&gt;

&lt;p&gt;层次遍历比较简单，主要是锯齿形，就是单数层从左到右，双数层从右到左。网上有很多题解，看了他们的之后觉得没有自己的好，他们基本都是使用了反转列表的操作，理论上会很耗时间。所以，我讲的是自己写的思路。&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;运用双栈法，分别储存单数层和双数层两种情况。&lt;/li&gt;
&lt;li&gt;ans为返回的总列表，res为每一层的答案，stack和helper是两个栈，方法和之前的前、中序遍历差不多。&lt;/li&gt;
&lt;li&gt;写一个主循环while，再写两个循环放在主循环中，一个遍历单数层，一个遍历双数层。&lt;/li&gt;
&lt;li&gt;两个循环里把双栈中的节点拿出来，同时也把节点的两个子节点(stack或者helper)以及他们的值(res)也存起来。&lt;/li&gt;
&lt;li&gt;最后将res的值加到ans中。主循环结束，ans值也都进去了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -&amp;gt; List[List[int]]:
        if root is None:
            return []
        stack = []
        helper = [root]
        res = []
        ans = [[root.val]]
        cnt = 1
        while stack or helper:
            for i in range(cnt):
                tail = helper.pop()
                if tail.right is not None:
                    stack.append(tail.right)
                    res.append(tail.right.val)
                if tail.left is not None:
                    stack.append(tail.left)
                    res.append(tail.left.val)
            if res:
                ans.append(res)
                res = []
                cnt = len(stack)
            else:
                break
            for i in range(cnt):
                tail = stack.pop()
                if tail.left is not None:
                    helper.append(tail.left)
                    res.append(tail.left.val)
                if tail.right is not None:
                    helper.append(tail.right)
                    res.append(tail.right.val)
            if res:
                ans.append(res)
                res = []
                cnt = len(helper)
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;虽然有一个while，两个for，但是其实只遍历了一遍节点，而且没有额外的其他耗时操作，也没有递归&lt;/li&gt;
&lt;li&gt;所以时间复杂度为O(n) n为树的总节点&lt;/li&gt;
&lt;li&gt;空间复杂度为O(n)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结:&lt;/h1&gt;

&lt;p&gt;双栈法的另一个用处，当遇到在一个循环里但是其中两次循环的条件不一眼时，可以写两个循环分别运算，再用一个主循环让两个循环不会结束。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>二叉搜索树迭代器</title>
      <link>https://ripple-zjw.github.io/2019/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Thu, 15 Aug 2019 16:42:03 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>

&lt;h2 id=&#34;题目-二叉搜索树迭代器&#34;&gt;题目：二叉搜索树迭代器&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。&lt;/li&gt;
&lt;li&gt;调用 next() 将返回二叉搜索树中的下一个最小的数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&#34;示例&#34;&gt;示例：&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;BSTIterator iterator = new BSTIterator(root);
iterator.next();    // 返回 3
iterator.next();    // 返回 7
iterator.hasNext(); // 返回 true
iterator.next();    // 返回 9
iterator.hasNext(); // 返回 true
iterator.next();    // 返回 15
iterator.hasNext(); // 返回 true
iterator.next();    // 返回 20
iterator.hasNext(); // 返回 false
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;提示&#34;&gt;提示：&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;next() 和 hasNext() 操作的时间复杂度是 O(1)，并使用O(h)内存，其中 h 是树的高度。&lt;/li&gt;
&lt;li&gt;你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 中至少存在一个下一个最小的数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第173题&#34;&gt;来源：力扣（LeetCode）第173题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/binary-search-tree-iterator&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/binary-search-tree-iterator&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;二叉搜索树的性质，任何一个节点的左子树都比自己小，任何一个节点的右子树都比自己大。&lt;/li&gt;
&lt;li&gt;然后它还有一个性质，我在哪个地方看到的有点不记得了。就是将二叉搜索树中序遍历之后得到的值是从小到大排列的有序列表。&lt;/li&gt;
&lt;li&gt;所以将二叉搜索树中序遍历就能拿到它的最小值到最大值&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;看代码吧&#34;&gt;看代码吧:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;class BSTIterator:
    def __init__(self, root: TreeNode):
        stack = []
        self.ans = []  # 储存答案
        tail = root
        while stack or tail is not None:  # 中序遍历
            if tail:
                stack.append(tail)
                tail = tail.right  # 注意和中序遍历稍有不同，因为我是用出栈的方式拿到最小值的，判断也是ans是否为空。所以我是反向的中序遍历，即中序遍历是左，中，右。而我是右，中，左。这样栈顶元素就是最小的值。
            else:
                tail = stack.pop()
                self.ans.append(tail.val)
                tail = tail.left  # 本质还是中序遍历，不用反向的应该也能做出来

    def next(self) -&amp;gt; int:
        return self.ans.pop()  # 最小值出栈，绝对的O(1)
        
    def hasNext(self) -&amp;gt; bool:
        return len(self.ans) != 0  # 这就更不用说了
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;整个程序只有中序遍历耗点时，其它两个操作根本不耗时。&lt;/li&gt;
&lt;li&gt;while 循环遍历整个树，&lt;/li&gt;
&lt;li&gt;时间复杂度应该是 O(n) n为树的节点总和&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;p&gt;二叉搜索树的中序遍历就是将二叉搜索树从小到大排列。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于博客</title>
      <link>https://ripple-zjw.github.io/about/aboutblog/</link>
      <pubDate>Thu, 15 Aug 2019 14:51:20 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/about/aboutblog/</guid>
      <description>

&lt;h1 id=&#34;关于博客&#34;&gt;关于博客&lt;/h1&gt;

&lt;p&gt;感谢Leavelt的作者&lt;strong&gt;柳志超&lt;/strong&gt;，这个基于hugo的博客框架非常的好。&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;主题官方网址: &lt;a href=&#34;https://themes.gohugo.io/leaveit/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://themes.gohugo.io/leaveit/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;中文文档网址: &lt;a href=&#34;https://liuzhichao.com/2018/hugo-theme-leaveit/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://liuzhichao.com/2018/hugo-theme-leaveit/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>https://ripple-zjw.github.io/about/aboutme/</link>
      <pubDate>Thu, 15 Aug 2019 14:51:20 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/about/aboutme/</guid>
      <description>

&lt;h1 id=&#34;关于我&#34;&gt;关于我&lt;/h1&gt;

&lt;p&gt;学生党一枚,我的网名叫:Ripple&lt;/p&gt;

&lt;p&gt;​       这是我的个人博客网站，主要写一些自己在学习编程过程中遇到的问题，以及解决的方法。同时，我也欢迎其他人来浏览我的学习成果，为我指出一些错误。如果你喜欢我的网站，可以按Ctrl + d 收藏该网站。希望在浏览的过程中我们一起学习，进步。谢谢！！！！！&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;附上我的邮箱，在浏览过程中有任何问题，都可以发到我的邮箱里。1315294982@qq.com&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我的GitHub账号, Ripple-zjw, 你可以点击左上角的LeaveIt回到主页，再点击头像下的图标前往我的GitHub账号。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我的微信，同上可以找到我的二维码&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果在浏览的过程中你觉得字体不是很清晰可以点击左上角的爱心切换为黑夜模式。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>First</title>
      <link>https://ripple-zjw.github.io/2019/first/</link>
      <pubDate>Wed, 14 Aug 2019 13:22:20 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/first/</guid>
      <description>

&lt;h1 id=&#34;我的博客测试文本&#34;&gt;我的博客测试文本&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>Git</title>
      <link>https://ripple-zjw.github.io/2019/git/</link>
      <pubDate>Wed, 14 Aug 2019 13:22:20 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/git/</guid>
      <description>

&lt;h1 id=&#34;git-版本控制工具&#34;&gt;Git 版本控制工具&lt;/h1&gt;

&lt;h2 id=&#34;学习目标&#34;&gt;学习目标&lt;/h2&gt;

&lt;p&gt;必备（项目开发中必定用到）
* 能够克隆服务器上的分支并会切换分支&lt;/p&gt;

&lt;p&gt;拓展
* 本地git操作
* 远程仓库合并
* 学会看提示信息去掌握git的方法&lt;/p&gt;

&lt;h2 id=&#34;文档&#34;&gt;文档&lt;/h2&gt;

&lt;p&gt;中文权威文档：&lt;a href=&#34;https://git-scm.com/book/zh/v2&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://git-scm.com/book/zh/v2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://git.mydoc.io/?t=154712&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;如何在码云上生成并部署SSH key&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;安装git&#34;&gt;安装Git&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;git-scm &lt;a href=&#34;https://git-scm.com/downloads/guis&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://git-scm.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;需要了解几个问题&#34;&gt;需要了解几个问题&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;为什么需要版本控制工具？&lt;/li&gt;
&lt;li&gt;了解版本控制工具的发展历程&lt;/li&gt;
&lt;li&gt;了解本地版本控制系统、集中化版本控制系统和分布式版本控制系统的异同&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;为什么需要版本控制工具&#34;&gt;为什么需要版本控制工具？&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;备份文件(U盘)&lt;/li&gt;
&lt;li&gt;记录历史(历史书)&lt;/li&gt;
&lt;li&gt;回到过去(时光机)&lt;/li&gt;
&lt;li&gt;多端共享(百度云盘)&lt;/li&gt;
&lt;li&gt;团队协作(复仇者联盟)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;版本控制工具的发展历程&#34;&gt;版本控制工具的发展历程&lt;/h2&gt;

&lt;p&gt;cvs(1985年)  &amp;mdash;  svn(2000年)  &amp;mdash;   git(2005)&lt;/p&gt;

&lt;h3 id=&#34;git诞生&#34;&gt;Git诞生&lt;/h3&gt;

&lt;p&gt;在2002年以前，世界各地的志愿者把源代码文件发给Linus，然后由Linus本人通过手工方式合并代码！&lt;/p&gt;

&lt;p&gt;因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。&lt;/p&gt;

&lt;p&gt;有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。&lt;/p&gt;

&lt;p&gt;到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。&lt;/p&gt;

&lt;p&gt;安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。&lt;/p&gt;

&lt;p&gt;Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：&lt;/p&gt;

&lt;p&gt;Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。&lt;/p&gt;

&lt;p&gt;Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。&lt;/p&gt;

&lt;p&gt;历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。&lt;/p&gt;

&lt;h2 id=&#34;集中式和分布式的区别&#34;&gt;集中式和分布式的区别&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;git-scm &lt;a href=&#34;https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%85%B3%E4%BA%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;官方说明&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;集中式：代码都保存在中央服务器，开发人员按需获取代码，修改完成后提交到中央服务器保存&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;优势：&lt;/li&gt;
&lt;li&gt;方便权限和内容统一管理&lt;/li&gt;
&lt;li&gt;可以按需检出代码，节省客户端硬盘空间&lt;/li&gt;
&lt;li&gt;劣势：&lt;/li&gt;
&lt;li&gt;连接不上服务器时，无法获取和提交更新&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;分布式：代码保存在每一个客户端中，开发人员在本地由&lt;strong&gt;完整的项目代码&lt;/strong&gt;，修改完成后保存在本地仓库。在将来通过网络或其他方式，相互交换修改历史&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;优势：&lt;/li&gt;
&lt;li&gt;分布式存储，不担心服务器故障导致的代码丢失&lt;/li&gt;
&lt;li&gt;劣势：操作&lt;strong&gt;太&lt;/strong&gt;灵活，有学习成本&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;git的优势&#34;&gt;Git的优势&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;分布式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;强大的分支&lt;/strong&gt;（支持非线性的开发模式）&lt;/li&gt;
&lt;li&gt;灵活（甚至可以修改历史）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;常用的操作&#34;&gt;常用的操作&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建仓库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git init # 在当面目录下创建仓库
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设置昵称和邮箱&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git config --global user.name &amp;quot;Gavin&amp;quot; # 设置昵称
git config --global user.email &amp;quot;Gavin@email.com&amp;quot; # 设置邮箱
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;### 注意git的设置分为“当前仓库设置&amp;rdquo;和&amp;rdquo;全局设置&amp;rdquo;，上面加了&amp;ndash;global是对全局生效的&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;创建或修改文件&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;这个就略了吧。。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;将文件加入版本控制&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git add xxx.md
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;提交此次修改&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git commit -m &amp;quot;增加了一个文件，并且修改了内容&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看修改历史&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git log
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建新分支，进行实验性的操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git checkout -b new_branch
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;合并分支&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git checkout master # 切换到接收合并的分支
git merge new_branch  # 接收new_branch 分支的合并
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;删除分支&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git branch -d new_branch
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;切换版本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git reset --hard 1j284jf  # 切换到指定了历史中
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;注意-以上命令都是你的本地仓库进行的&#34;&gt;注意！以上命令都是你的本地仓库进行的！！！！&lt;/h4&gt;

&lt;h4 id=&#34;注意-以上命令掌握之后-日常使用gui完成操作&#34;&gt;注意！以上命令掌握之后，日常使用GUI完成操作！&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;为什么？&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;如何和他人交换代码-其实就是交换history&#34;&gt;如何和他人交换代码（其实就是交换History）&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;git托管平台&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;github # 全球最大的同性交友网站&lt;/li&gt;
&lt;li&gt;gitlab # 开源的高度定制化的托管平台&lt;/li&gt;
&lt;li&gt;gogs# 国人使用go开发的开源&lt;strong&gt;精简&lt;/strong&gt;平台&lt;/li&gt;
&lt;li&gt;bitbucket # 国外的免费私有库平台&lt;/li&gt;
&lt;li&gt;gitee # 国内的免费私有库平台&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;注册&lt;br /&gt;
&lt;a href=&#34;https://gitee.com/signup&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://gitee.com/signup&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建远程仓库&lt;br /&gt;
&lt;a href=&#34;https://gitee.com/projects/new&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://gitee.com/projects/new&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;获取仓库地址&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;推送&lt;br /&gt;
push&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;思考，既然是分布式的，那么现在远程仓库和本地仓库的内容是一摸一样吗&lt;br /&gt;
  对于已经push 的分支来说是的。但是对于没有push的分支，远程仓库是没有的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;fork&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;派生一个远程仓库（注意远程仓库，是指托管平台中的仓库，本地仓库是指你电脑中的仓库）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Pull Request&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;远程仓库建的合并（请求目标仓库合并自己的仓库）&lt;/li&gt;
&lt;li&gt;前提：有fork关系&lt;/li&gt;
&lt;li&gt;本质将一个仓库的某分支合并到另一个的仓库的某分支&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;说明，获取代码是整个仓库，交换代码（更新）是以分支为单位的&lt;br /&gt;
所以，新功能一般在新分支开发，然后把整个分支合并到主分支上&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;git工作流程&#34;&gt;Git工作流程&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;获取代码&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果没有克隆仓库，先克隆仓库
&lt;code&gt;git clone git@gitee.com:DN_Ian/Vip1710.git&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;获取最新数据，使本地仓库与远程仓库一致
&lt;code&gt;git fetch&lt;/code&gt; # 注意pull命令fetch命令的区别,fetch/pull,抓取/拉取， **pull ==  fetch +  merge **&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;开发代码&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;切换到要开发的分支 (假设要对gavin分支进行开发)&lt;br /&gt;
&lt;code&gt;git checkout  origin/gavin&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;新建私有分支，进行开发&lt;br /&gt;
&lt;code&gt;git checkout -b my_branch&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;开发代码&lt;br /&gt;
&lt;code&gt;(略)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;提交&lt;br /&gt;
&lt;code&gt;git commit -a&lt;/code&gt;（在私有分支&lt;code&gt;my_branch&lt;/code&gt;上）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;上传代码&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;保存好正在开发的代码&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;获取最新数据，使本地仓库与远程仓库一致&lt;br /&gt;
&lt;code&gt;git fetch origin&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;切换到要开发的分支 (假设要对gavin分支进行开发)&lt;br /&gt;
&lt;code&gt;git checkout  origin/gavin&lt;/code&gt;&lt;br /&gt;
// 切到一个临时分支，没有名字, 版本与远程gavin分支相同&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将开发完成的私有分支合并, 如果有冲突，使用gui处理冲突&lt;br /&gt;
&lt;code&gt;git merge my_branch&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;上传修改后的gavin分支到远程仓库&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;git push origin my_branch:gavin  #1，推送到属于自己的派生仓库，2.推送到目标分支&lt;/code&gt;&lt;br /&gt;
  // 如果恰好此时远程仓库的gavin分支发生变化，会提示冲突。则重新操作&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;注意区别&#34;&gt;注意区别&lt;/h3&gt;

&lt;p&gt;本地和本地—— checkout/merge&lt;br /&gt;
本地和远程—— clone/pull/fetch/push&lt;br /&gt;
远程和远程—— fork/pull reuqets&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;-&lt;/th&gt;
&lt;th&gt;本地&lt;/th&gt;
&lt;th&gt;远程&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;本地&lt;/td&gt;
&lt;td&gt;checkout/merge&lt;/td&gt;
&lt;td&gt;clone/fetch/push&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;远程&lt;/td&gt;
&lt;td&gt;clone/fetch/push&lt;/td&gt;
&lt;td&gt;fork/pull reuqets&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>Markdown使用</title>
      <link>https://ripple-zjw.github.io/2019/markdown%E8%AF%95%E7%94%A8/</link>
      <pubDate>Wed, 14 Aug 2019 13:22:20 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/markdown%E8%AF%95%E7%94%A8/</guid>
      <description>

&lt;h1 id=&#34;一级标题&#34;&gt;一级标题&lt;/h1&gt;

&lt;h2 id=&#34;二级标题&#34;&gt;二级标题&lt;/h2&gt;

&lt;h3 id=&#34;三级标题&#34;&gt;三级标题&lt;/h3&gt;

&lt;h4 id=&#34;四级标题&#34;&gt;四级标题&lt;/h4&gt;

&lt;h5 id=&#34;五级标题&#34;&gt;五级标题&lt;/h5&gt;

&lt;h6 id=&#34;六级标题&#34;&gt;六级标题&lt;/h6&gt;

&lt;p&gt;&lt;em&gt;倾斜字体&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;++下划线++&lt;/p&gt;

&lt;p&gt;&lt;del&gt;删除线&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;加粗字体&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;分割线&#34;&gt;分割线&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;sequenceDiagram
A-&amp;gt;&amp;gt;B: How are you?
B-&amp;gt;&amp;gt;A: Great!
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;graph LR
A--&amp;gt;B
a--&amp;gt;A
a--&amp;gt;B
B--&amp;gt;a
c--&amp;gt;B
a--&amp;gt;c
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-math&#34;&gt;E = mc^2 + 6^7 * 3 /3
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;print(&#39;hello world!!!!&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
int main(){
    printf(&#39;hello world!!!!\n&#39;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>bootstrap</title>
      <link>https://ripple-zjw.github.io/2019/bootstrap/</link>
      <pubDate>Wed, 14 Aug 2019 13:22:20 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/bootstrap/</guid>
      <description>

&lt;h3 id=&#34;bootstrap&#34;&gt;bootstrap&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;简洁、直观、强悍的前端开发框架，让web开发更迅速、简单
中文网 ： http://www.bootcss.com/
英文网  :  http://getbootstrap.com/
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;容器&#34;&gt;容器&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;流体布局容器
    容器的width为auto，只是两边加了15px的padding。

固定布局
    容器的width会随设备分辨率的不同而生产变化
        分辨率阈值
            w &amp;gt;=1200                容器的width为1170   左右padding为15 （注意是borderBox）
            1200&amp;gt;w &amp;gt;=992        容器的width为970     左右padding为15 （注意是borderBox）
            992 &amp;gt; w &amp;gt;=768       容器的width为750     左右padding为15  （注意是borderBox）
            768 &amp;gt; w &amp;gt;=992       容器的width为auto    左右padding为15  （注意是borderBox）
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;栅格系统&#34;&gt;栅格系统&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; col-lg-x    
 col-md-x
 col-sm-x
 col-xs-x
 x默认拥有12个等级
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;列偏移&#34;&gt;列偏移&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;调整的是margin-left，分13个等级（0到12）
        0时为0%
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;列排序&#34;&gt;列排序&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;push的时候调整的是left，分13个等级（0到12）
        0时为auto

pull的时候调整的是right，分13个等级（0到12）
        0时为auto
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;响应式工具&#34;&gt;响应式工具&lt;/h3&gt;

&lt;h3 id=&#34;容器与栅格盒模型设计的精妙之处&#34;&gt;容器与栅格盒模型设计的精妙之处&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;    container 提供了一个15px的padding
    row 是 column 直接存在的容器，row 默认最多可有12个 column，
同时作为都是左浮动的 column 的 wrapper，自带 clearfix 的性质。
同时 row 还有一个很特殊的地方，就是左右各有 －15px 的 margin，
为了抵消 container 中15px的 padding
    每个column 也会有15px的水平方向的 padding，colunmn 只能在 row 中生存，
由于 row 的 margin 为－15px，那么位于两边的 column 就碰到了 container 的边界。
但是 colunmn 本身又有 15px 的 padding 使得它其中的内容并不会碰到 container，
同时 不同column的内容之间就有了30px的槽

目的是为了确保列与列之间有30px的槽，列与容器之间有15px的槽
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>