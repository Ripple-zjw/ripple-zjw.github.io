<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeaveIt on LeaveIt</title>
    <link>https://ripple-zjw.github.io/</link>
    <description>Recent content in LeaveIt on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 17 Aug 2019 18:58:39 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>搭建Hugo时需要注意的坑</title>
      <link>https://ripple-zjw.github.io/2019/%E6%90%AD%E5%BB%BAhugo%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9D%91/</link>
      <pubDate>Sat, 17 Aug 2019 18:58:39 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%90%AD%E5%BB%BAhugo%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9D%91/</guid>
      <description>

&lt;h1 id=&#34;搭建hugo时需要注意的坑&#34;&gt;搭建Hugo时需要注意的坑&lt;/h1&gt;

&lt;p&gt;Hugo是一种博客框架，可以说是非常优秀的博客框架。基于go语言，网页生成的速度非常的快，而且下载简单，在GitHub上就能下载，还有官方的中文文档，操作也是很简单。但是对于刚开始搭建博客的小白，还是会遇到各种各样的问题，在这里我把我遇到的坑分享给各位读者。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;从GitHub上把Hugo下载下来会慢，当然也有人网速没问题。这个问题可以找网上的一些方法，比如改hosts文件。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可能有人和我一样下载完解压后在终端输入&lt;code&gt;hugo xxx&lt;/code&gt;的命令无效，那是因为系统找不到你要输的是什么东西，有两种解决方法。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一种是每次输入命令都带上你&lt;code&gt;hugo.exe&lt;/code&gt;文件的绝对路径，但是这样太麻烦了。&lt;/li&gt;
&lt;li&gt;第二种是将&lt;code&gt;hugo.exe&lt;/code&gt;添加到你系统的环境变量中，这样直接输入hugo就能启动命令了。&lt;/li&gt;
&lt;li&gt;设置方法为：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;控制面板 &amp;gt; 系统和安全 &amp;gt; 系统 &amp;gt; 高级系统设置 &amp;gt; 高级 &amp;gt; 环境变量&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;上下两个一个是用户变量，一个是系统变量，建议两个都设置。&lt;/li&gt;
&lt;li&gt;点击&lt;code&gt;Path&lt;/code&gt;变量，然后点击&lt;code&gt;新建&lt;/code&gt;，将你&lt;code&gt;hugo.exe&lt;/code&gt;的绝对路径目录添加进去，注意是目录。不要把&lt;code&gt;hugo.exe&lt;/code&gt;带进去。例如：你的目录为&lt;code&gt;c:/xxx/xxx/hugo.exe&lt;/code&gt;，你只要添加&lt;code&gt;c:/xxx/xxx&lt;/code&gt;就行了。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;主题是下载到&lt;code&gt;themes\&lt;/code&gt;文件夹中的，用git clone。如果不会使用git，请参考我关于git的文章&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下载完之后，里面基本都会有一个&lt;code&gt;exampleSite\&lt;/code&gt;文件夹，里面放的是一个样式，你可以直接把里面的&lt;code&gt;config.toml&lt;/code&gt;中的内容复制到你的博客主目录的&lt;code&gt;config.toml&lt;/code&gt;中。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;你博客根目录的&lt;code&gt;config.toml&lt;/code&gt;文件里要把&lt;code&gt;baseURL&lt;/code&gt;参数换成你的博客网站网址，如果你还没有部署到网上，可以填你的本地网址，就是那个默认端口1313的那个。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;你部署好之后，如果想要继续添加文章，首先使用&lt;code&gt;hugo&lt;/code&gt;命令重新生成&lt;code&gt;public/&lt;/code&gt;文件夹，然后在里面用git添加，提交，上传就行了。与第一次部署时的操作一样。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;### 以上差不多就是我遇到的坑。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>字符串解码</title>
      <link>https://ripple-zjw.github.io/2019/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</link>
      <pubDate>Sat, 17 Aug 2019 18:51:43 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</guid>
      <description>

&lt;h1 id=&#34;题目-字符串解码&#34;&gt;题目：字符串解码&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个经过编码的字符串，返回它解码后的字符串。&lt;/li&gt;
&lt;li&gt;编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。&lt;/li&gt;
&lt;li&gt;你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。&lt;/li&gt;
&lt;li&gt;此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&#34;示例&#34;&gt;示例:&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;s = &amp;quot;3[a]2[bc]&amp;quot;, 返回 &amp;quot;aaabcbc&amp;quot;.
s = &amp;quot;3[a2[c]]&amp;quot;, 返回 &amp;quot;accaccacc&amp;quot;.
s = &amp;quot;2[abc]3[cd]ef&amp;quot;, 返回 &amp;quot;abcabccdcdcdef&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第394题&#34;&gt;来源：力扣（LeetCode）第394题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/decode-string&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/decode-string&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;分析&#34;&gt;分析：&lt;/h3&gt;

&lt;p&gt;两种方法，辅助栈法和递归法，递归法相对思路清晰，比较好做。其实本质两种方法是一样的，因为函数的递归调用其实也是用栈来实现的。&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;递归法：

&lt;ul&gt;
&lt;li&gt;遍历整个字符串&lt;/li&gt;
&lt;li&gt;同时要用到stack列表，tmp列表，还有一个表示下标的变量i&lt;/li&gt;
&lt;li&gt;每次递归之后stack都是该函数的stack，与外面的stack不同&lt;/li&gt;
&lt;li&gt;每次遍历字符时，tmp都要将里面的值清空&lt;/li&gt;
&lt;li&gt;遇到字母，压入stack&lt;/li&gt;
&lt;li&gt;遇到&lt;code&gt;]&lt;/code&gt;字符,结束函数并将stack返回&lt;/li&gt;
&lt;li&gt;遇到数字首先判断该数字后是否还有数字，有的话一起加入tmp，然后递归调用函数。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;辅助栈法：

&lt;ul&gt;
&lt;li&gt;遍历整个字符串&lt;/li&gt;
&lt;li&gt;res表示当前字符串，multi表示当前数字，stack储存答案&lt;/li&gt;
&lt;li&gt;遇到字母，与res拼接起来&lt;/li&gt;
&lt;li&gt;遇到数字，放入multi，注意由于两个数字放在一起要变成两位数，以此类推，所以res 写成&lt;code&gt;res = res * 10 + 当前数字&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;遇到&lt;code&gt;[&lt;/code&gt;，将res，multi同时入栈，用一个列表或元祖，并行的，不是先后入栈。&lt;/li&gt;
&lt;li&gt;遇到右括号，栈顶元素出栈，并将栈顶元素的multi与当前字符相乘，然后再与栈顶的res相加&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;上代码&#34;&gt;上代码：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;递归法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def decodeString(self, s: str) -&amp;gt; str:
        self.i = 0
        return &#39;&#39;.join(self.recursion(s))
            
    def recursion(self, s: str) -&amp;gt; list:
        stack = []
        while self.i &amp;lt; len(s):
            tmp = []
            if s[self.i].isalpha():
                stack.append(s[self.i])
            elif s[self.i] == &#39;]&#39;:
                return stack
            elif s[self.i].isdigit():
                tmp.append(s[self.i])
                while s[self.i + 1].isdigit():
                    tmp.append(s[self.i + 1])
                    self.i += 1
                self.i += 2
                stack += (int(&#39;&#39;.join(tmp)) * self.recursion(s))
            self.i += 1
        return stack
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;辅助栈法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def decodeString(self, s: str) -&amp;gt; str:
        stack, res, multi = [], &amp;quot;&amp;quot;, 0
        for c in s:
            if c == &#39;[&#39;:
                stack.append([multi, res])
                res, multi = &amp;quot;&amp;quot;, 0
            elif c == &#39;]&#39;:
                cur_multi, last_res = stack.pop()
                res = last_res + cur_multi * res
            elif &#39;0&#39; &amp;lt;= c &amp;lt;= &#39;9&#39;:
                multi = multi * 10 + int(c)            
            else:
                res += c
        return res
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;辅助栈法不是我自己写的，可以参考LeetCode上的作者：
&amp;gt; &lt;a href=&#34;https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;递归法：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为字符串长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;辅助栈法：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为字符串长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;递归是一种不错的尝试，很多时候递归的时间耗时并不是非常高，而且解题方便。&lt;/li&gt;
&lt;li&gt;写这种题目前需要理清各种情况时的行为。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>下一个更大元素</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0ii/</link>
      <pubDate>Sat, 17 Aug 2019 18:50:56 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0ii/</guid>
      <description>

&lt;h1 id=&#34;题目-下一个更大元素-ii&#34;&gt;题目：下一个更大元素 II&lt;/h1&gt;

&lt;p&gt;给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。&lt;/p&gt;

&lt;h6 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第503题&#34;&gt;来源：力扣（LeetCode）第503题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/next-greater-element-ii&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/next-greater-element-ii&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;分析&#34;&gt;分析：&lt;/h3&gt;

&lt;p&gt;循环数组和循环队列的样子差不多，这道题主要是单调栈，同样涉及两种解法，暴力法和单调栈法。这题的难点不在于单调栈，而是循环数组什么时候停下来。&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;由于是循环数组，如果只遍历一遍无法完全找到答案，所以我们遍历两边数组，使得数组较后的元素能与前面的元素比对。&lt;/li&gt;
&lt;li&gt;当下表(i)比数组的最后一个下表大时，i % len(数组)&lt;/li&gt;
&lt;li&gt;初始化所有答案均为-1(如果找不到最大的是-1，所以先全部等于-1)&lt;/li&gt;
&lt;li&gt;维护一个单调递减栈，入栈元素将比它小的栈内元素全部出栈，出栈元素的答案就是入栈元素。&lt;/li&gt;
&lt;li&gt;如此循环两次，如果栈内元素在两次循环之后均未能出栈(找到比它大的元素),那么它们就是数组中最大的元素，又由于我们初始化答案全部为-1，所以不用改变它们。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;上代码&#34;&gt;上代码:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution(object):
    def nextGreaterElements(self, nums):
        &amp;quot;&amp;quot;&amp;quot;
        :type nums: List[int]
        :rtype: List[int]
        &amp;quot;&amp;quot;&amp;quot;
        stack = []
        n = len(nums)
        res = [-1 for _ in nums]
        for i in range(2 * n):
            while stack and nums[i % n] &amp;gt; nums[stack[-1]]:
                res[stack.pop()] = nums[i % n]
            stack.append(i % n)
        return res
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一并给出暴力法(时间太长，会超时)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def nextGreaterElements(self, nums: List[int]) -&amp;gt; List[int]:
        n = len(nums)
        ans = []
        for i in range(n):
            j = i
            while True:
                j = (j + 1) % n
                if nums[j] &amp;gt; nums[i]:
                    ans.append(nums[j])
                    break
                if j + 1 == i:
                    ans.append(-1)
                    break
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;复杂地分析&#34;&gt;复杂地分析:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;暴力法:&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂地：O(n^2^)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;单调栈法:

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为数组长度

&lt;ul&gt;
&lt;li&gt;最好情况 n = 3n&lt;/li&gt;
&lt;li&gt;最差情况 n = 4n&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n) n为数组长度 n = 2n(最差)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;使用单调栈解这类题目非常合适。&lt;/li&gt;
&lt;li&gt;如果实在无法找到结束循环点，不妨全部再遍历一遍数组。&lt;/li&gt;
&lt;li&gt;单调栈不一定要全部将栈中的元素都拿出来，如果有元素没有合适的答案，留在栈中也是可以的。&lt;/li&gt;
&lt;li&gt;初始化答案数组是一个不错方法，保证数组内的元素在找不到合适的答案时也能满足题目要求。(比如这道题说如果没有比它大的元素，那么它的答案为-1，所以我们就全部初始化为-1)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>扁平化嵌套列表迭代器</title>
      <link>https://ripple-zjw.github.io/2019/%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Sat, 17 Aug 2019 18:50:30 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>

&lt;h1 id=&#34;题目-扁平化嵌套列表迭代器&#34;&gt;题目:扁平化嵌套列表迭代器&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个嵌套的整型列表。设计一个迭代器，使其能够遍历这个整型列表中的所有整数。&lt;/li&gt;
&lt;li&gt;列表中的项或者为一个整数，或者是另一个列表。&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;输入: [[1,1],2,[1,1]]
输出: [1,1,2,1,1]
解释: 通过重复调用 next 直到 hasNext 返回false，next 返回的元素的顺序应该是: [1,1,2,1,1]。
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,[4,[6]]]
输出: [1,4,6]
解释: 通过重复调用 next 直到 hasNext 返回false，next 返回的元素的顺序应该是: [1,4,6]。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第341题&#34;&gt;来源：力扣（LeetCode）第341题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/flatten-nested-list-iterator&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/flatten-nested-list-iterator&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;分析&#34;&gt;分析：&lt;/h3&gt;

&lt;p&gt;递归调用，不是很难。唯一要注意的是要看清题目，list里面是NestedIterator，需要使用他给你的方法调用才能得到integer或者list。&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;从后往前遍历&lt;/li&gt;
&lt;li&gt;判断是否是integer，是  入栈  不是  递归进去&lt;/li&gt;
&lt;li&gt;返回栈，结束。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# &amp;quot;&amp;quot;&amp;quot;
# This is the interface that allows for creating nested lists.
# You should not implement it, or speculate about its implementation
# &amp;quot;&amp;quot;&amp;quot;
#class NestedInteger(object):
#    def isInteger(self):
#        &amp;quot;&amp;quot;&amp;quot;
#        @return True if this NestedInteger holds a single integer, rather than a nested list.
#        :rtype bool
#        &amp;quot;&amp;quot;&amp;quot;
#
#    def getInteger(self):
#        &amp;quot;&amp;quot;&amp;quot;
#        @return the single integer that this NestedInteger holds, if it holds a single integer
#        Return None if this NestedInteger holds a nested list
#        :rtype int
#        &amp;quot;&amp;quot;&amp;quot;
#
#    def getList(self):
#        &amp;quot;&amp;quot;&amp;quot;
#        @return the nested list that this NestedInteger holds, if it holds a nested list
#        Return None if this NestedInteger holds a single integer
#        :rtype List[NestedInteger]
#        &amp;quot;&amp;quot;&amp;quot;

class NestedIterator(object):  # 注意看清上面的方法都是干什么的，虽然是英文但是也比较容易看懂。
    def __init__(self, nestedList):
        &amp;quot;&amp;quot;&amp;quot;
        Initialize your data structure here.
        :type nestedList: List[NestedInteger]
        &amp;quot;&amp;quot;&amp;quot;
        self.stack = []
        self.recursion(nestedList)


    def recursion(self, nestedList):
        for i in range(len(nestedList) - 1, -1, -1):
            if nestedList[i].isInteger():
                self.stack.append(nestedList[i].getInteger())
            else:
                self.recursion(nestedList[i].getList())


    def next(self):
        &amp;quot;&amp;quot;&amp;quot;
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        return self.stack.pop()
        

    def hasNext(self):
        &amp;quot;&amp;quot;&amp;quot;
        :rtype: bool
        &amp;quot;&amp;quot;&amp;quot;
        return len(self.stack) &amp;gt; 0

# Your NestedIterator object will be instantiated and called as such:
# i, v = NestedIterator(nestedList), []
# while i.hasNext(): v.append(i.next())
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n 为整个列表的元素，也就是最后stack里的元素。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;p&gt;还是很简单的，只要递归写的稍微熟练一点都能写的出来。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>二叉树的锯齿形层次遍历</title>
      <link>https://ripple-zjw.github.io/2019/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sat, 17 Aug 2019 18:48:01 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</guid>
      <description>

&lt;h1 id=&#34;题目-二叉树的锯齿形层次遍历&#34;&gt;题目: 二叉树的锯齿形层次遍历&lt;/h1&gt;

&lt;p&gt;给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。&lt;/p&gt;

&lt;h6 id=&#34;例如&#34;&gt;例如：&lt;/h6&gt;

&lt;p&gt;给定二叉树 [3,9,20,null,null,15,7],&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    3
   / \
  9  20
    /  \
   15   7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回锯齿形层次遍历如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  [3],
  [20,9],
  [15,7]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第103题&#34;&gt;来源：力扣（LeetCode）第103题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;分析&#34;&gt;分析:&lt;/h3&gt;

&lt;p&gt;层次遍历比较简单，主要是锯齿形，就是单数层从左到右，双数层从右到左。网上有很多题解，看了他们的之后觉得没有自己的好，他们基本都是使用了反转列表的操作，理论上会很耗时间。所以，我讲的是自己写的思路。&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;运用双栈法，分别储存单数层和双数层两种情况。&lt;/li&gt;
&lt;li&gt;ans为返回的总列表，res为每一层的答案，stack和helper是两个栈，方法和之前的前、中序遍历差不多。&lt;/li&gt;
&lt;li&gt;写一个主循环while，再写两个循环放在主循环中，一个遍历单数层，一个遍历双数层。&lt;/li&gt;
&lt;li&gt;两个循环里把双栈中的节点拿出来，同时也把节点的两个子节点(stack或者helper)以及他们的值(res)也存起来。&lt;/li&gt;
&lt;li&gt;最后将res的值加到ans中。主循环结束，ans值也都进去了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -&amp;gt; List[List[int]]:
        if root is None:
            return []
        stack = []
        helper = [root]
        res = []
        ans = [[root.val]]
        cnt = 1
        while stack or helper:
            for i in range(cnt):
                tail = helper.pop()
                if tail.right is not None:
                    stack.append(tail.right)
                    res.append(tail.right.val)
                if tail.left is not None:
                    stack.append(tail.left)
                    res.append(tail.left.val)
            if res:
                ans.append(res)
                res = []
                cnt = len(stack)
            else:
                break
            for i in range(cnt):
                tail = stack.pop()
                if tail.left is not None:
                    helper.append(tail.left)
                    res.append(tail.left.val)
                if tail.right is not None:
                    helper.append(tail.right)
                    res.append(tail.right.val)
            if res:
                ans.append(res)
                res = []
                cnt = len(helper)
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;虽然有一个while，两个for，但是其实只遍历了一遍节点，而且没有额外的其他耗时操作，也没有递归&lt;/li&gt;
&lt;li&gt;所以时间复杂度为O(n) n为树的总节点&lt;/li&gt;
&lt;li&gt;空间复杂度为O(n)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结:&lt;/h1&gt;

&lt;p&gt;双栈法的另一个用处，当遇到在一个循环里但是其中两次循环的条件不一眼时，可以写两个循环分别运算，再用一个主循环让两个循环不会结束。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>二叉搜索树迭代器</title>
      <link>https://ripple-zjw.github.io/2019/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Thu, 15 Aug 2019 16:42:03 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>

&lt;h2 id=&#34;题目-二叉搜索树迭代器&#34;&gt;题目：二叉搜索树迭代器&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。&lt;/li&gt;
&lt;li&gt;调用 next() 将返回二叉搜索树中的下一个最小的数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&#34;示例&#34;&gt;示例：&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;BSTIterator iterator = new BSTIterator(root);
iterator.next();    // 返回 3
iterator.next();    // 返回 7
iterator.hasNext(); // 返回 true
iterator.next();    // 返回 9
iterator.hasNext(); // 返回 true
iterator.next();    // 返回 15
iterator.hasNext(); // 返回 true
iterator.next();    // 返回 20
iterator.hasNext(); // 返回 false
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;提示&#34;&gt;提示：&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;next() 和 hasNext() 操作的时间复杂度是 O(1)，并使用O(h)内存，其中 h 是树的高度。&lt;/li&gt;
&lt;li&gt;你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 中至少存在一个下一个最小的数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第173题&#34;&gt;来源：力扣（LeetCode）第173题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/binary-search-tree-iterator&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/binary-search-tree-iterator&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;二叉搜索树的性质，任何一个节点的左子树都比自己小，任何一个节点的右子树都比自己大。&lt;/li&gt;
&lt;li&gt;然后它还有一个性质，我在哪个地方看到的有点不记得了。就是将二叉搜索树中序遍历之后得到的值是从小到大排列的有序列表。&lt;/li&gt;
&lt;li&gt;所以将二叉搜索树中序遍历就能拿到它的最小值到最大值&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;看代码吧&#34;&gt;看代码吧:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;class BSTIterator:
    def __init__(self, root: TreeNode):
        stack = []
        self.ans = []  # 储存答案
        tail = root
        while stack or tail is not None:  # 中序遍历
            if tail:
                stack.append(tail)
                tail = tail.right  # 注意和中序遍历稍有不同，因为我是用出栈的方式拿到最小值的，判断也是ans是否为空。所以我是反向的中序遍历，即中序遍历是左，中，右。而我是右，中，左。这样栈顶元素就是最小的值。
            else:
                tail = stack.pop()
                self.ans.append(tail.val)
                tail = tail.left  # 本质还是中序遍历，不用反向的应该也能做出来

    def next(self) -&amp;gt; int:
        return self.ans.pop()  # 最小值出栈，绝对的O(1)
        
    def hasNext(self) -&amp;gt; bool:
        return len(self.ans) != 0  # 这就更不用说了
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;整个程序只有中序遍历耗点时，其它两个操作根本不耗时。&lt;/li&gt;
&lt;li&gt;while 循环遍历整个树，&lt;/li&gt;
&lt;li&gt;时间复杂度应该是 O(n) n为树的节点总和&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;p&gt;二叉搜索树的中序遍历就是将二叉搜索树从小到大排列。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于博客</title>
      <link>https://ripple-zjw.github.io/about/aboutblog/</link>
      <pubDate>Thu, 15 Aug 2019 14:51:20 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/about/aboutblog/</guid>
      <description>

&lt;h1 id=&#34;关于博客&#34;&gt;关于博客&lt;/h1&gt;

&lt;p&gt;感谢Leavelt的作者&lt;strong&gt;柳志超&lt;/strong&gt;，这个基于hugo的博客框架非常的好。&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;主题官方网址: &lt;a href=&#34;https://themes.gohugo.io/leaveit/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://themes.gohugo.io/leaveit/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;中文文档网址: &lt;a href=&#34;https://liuzhichao.com/2018/hugo-theme-leaveit/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://liuzhichao.com/2018/hugo-theme-leaveit/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>https://ripple-zjw.github.io/about/aboutme/</link>
      <pubDate>Thu, 15 Aug 2019 14:51:20 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/about/aboutme/</guid>
      <description>

&lt;h1 id=&#34;关于我&#34;&gt;关于我&lt;/h1&gt;

&lt;p&gt;学生党一枚,我的网名叫:Ripple&lt;/p&gt;

&lt;p&gt;​       这是我的个人博客网站，主要写一些自己在学习编程过程中遇到的问题，以及解决的方法。同时，我也欢迎其他人来浏览我的学习成果，为我指出一些错误。如果你喜欢我的网站，可以按Ctrl + d 收藏该网站。希望在浏览的过程中我们一起学习，进步。谢谢！！！！！&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;附上我的邮箱，在浏览过程中有任何问题，都可以发到我的邮箱里。1315294982@qq.com&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我的GitHub账号, Ripple-zjw, 你可以点击左上角的LeaveIt回到主页，再点击头像下的图标前往我的GitHub账号。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我的微信，同上可以找到我的二维码&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果在浏览的过程中你觉得字体不是很清晰可以点击左上角的爱心切换为黑夜模式。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>First</title>
      <link>https://ripple-zjw.github.io/2019/first/</link>
      <pubDate>Wed, 14 Aug 2019 13:22:20 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/first/</guid>
      <description>

&lt;h1 id=&#34;我的博客测试文本&#34;&gt;我的博客测试文本&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>Git</title>
      <link>https://ripple-zjw.github.io/2019/git/</link>
      <pubDate>Wed, 14 Aug 2019 13:22:20 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/git/</guid>
      <description>

&lt;h1 id=&#34;git-版本控制工具&#34;&gt;Git 版本控制工具&lt;/h1&gt;

&lt;h2 id=&#34;学习目标&#34;&gt;学习目标&lt;/h2&gt;

&lt;p&gt;必备（项目开发中必定用到）
* 能够克隆服务器上的分支并会切换分支&lt;/p&gt;

&lt;p&gt;拓展
* 本地git操作
* 远程仓库合并
* 学会看提示信息去掌握git的方法&lt;/p&gt;

&lt;h2 id=&#34;文档&#34;&gt;文档&lt;/h2&gt;

&lt;p&gt;中文权威文档：&lt;a href=&#34;https://git-scm.com/book/zh/v2&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://git-scm.com/book/zh/v2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://git.mydoc.io/?t=154712&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;如何在码云上生成并部署SSH key&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;安装git&#34;&gt;安装Git&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;git-scm &lt;a href=&#34;https://git-scm.com/downloads/guis&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://git-scm.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;需要了解几个问题&#34;&gt;需要了解几个问题&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;为什么需要版本控制工具？&lt;/li&gt;
&lt;li&gt;了解版本控制工具的发展历程&lt;/li&gt;
&lt;li&gt;了解本地版本控制系统、集中化版本控制系统和分布式版本控制系统的异同&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;为什么需要版本控制工具&#34;&gt;为什么需要版本控制工具？&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;备份文件(U盘)&lt;/li&gt;
&lt;li&gt;记录历史(历史书)&lt;/li&gt;
&lt;li&gt;回到过去(时光机)&lt;/li&gt;
&lt;li&gt;多端共享(百度云盘)&lt;/li&gt;
&lt;li&gt;团队协作(复仇者联盟)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;版本控制工具的发展历程&#34;&gt;版本控制工具的发展历程&lt;/h2&gt;

&lt;p&gt;cvs(1985年)  &amp;mdash;  svn(2000年)  &amp;mdash;   git(2005)&lt;/p&gt;

&lt;h3 id=&#34;git诞生&#34;&gt;Git诞生&lt;/h3&gt;

&lt;p&gt;在2002年以前，世界各地的志愿者把源代码文件发给Linus，然后由Linus本人通过手工方式合并代码！&lt;/p&gt;

&lt;p&gt;因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。&lt;/p&gt;

&lt;p&gt;有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。&lt;/p&gt;

&lt;p&gt;到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。&lt;/p&gt;

&lt;p&gt;安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。&lt;/p&gt;

&lt;p&gt;Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：&lt;/p&gt;

&lt;p&gt;Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。&lt;/p&gt;

&lt;p&gt;Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。&lt;/p&gt;

&lt;p&gt;历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。&lt;/p&gt;

&lt;h2 id=&#34;集中式和分布式的区别&#34;&gt;集中式和分布式的区别&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;git-scm &lt;a href=&#34;https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%85%B3%E4%BA%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;官方说明&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;集中式：代码都保存在中央服务器，开发人员按需获取代码，修改完成后提交到中央服务器保存&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;优势：&lt;/li&gt;
&lt;li&gt;方便权限和内容统一管理&lt;/li&gt;
&lt;li&gt;可以按需检出代码，节省客户端硬盘空间&lt;/li&gt;
&lt;li&gt;劣势：&lt;/li&gt;
&lt;li&gt;连接不上服务器时，无法获取和提交更新&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;分布式：代码保存在每一个客户端中，开发人员在本地由&lt;strong&gt;完整的项目代码&lt;/strong&gt;，修改完成后保存在本地仓库。在将来通过网络或其他方式，相互交换修改历史&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;优势：&lt;/li&gt;
&lt;li&gt;分布式存储，不担心服务器故障导致的代码丢失&lt;/li&gt;
&lt;li&gt;劣势：操作&lt;strong&gt;太&lt;/strong&gt;灵活，有学习成本&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;git的优势&#34;&gt;Git的优势&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;分布式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;强大的分支&lt;/strong&gt;（支持非线性的开发模式）&lt;/li&gt;
&lt;li&gt;灵活（甚至可以修改历史）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;常用的操作&#34;&gt;常用的操作&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建仓库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git init # 在当面目录下创建仓库
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设置昵称和邮箱&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git config --global user.name &amp;quot;Gavin&amp;quot; # 设置昵称
git config --global user.email &amp;quot;Gavin@email.com&amp;quot; # 设置邮箱
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;### 注意git的设置分为“当前仓库设置&amp;rdquo;和&amp;rdquo;全局设置&amp;rdquo;，上面加了&amp;ndash;global是对全局生效的&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;创建或修改文件&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;这个就略了吧。。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;将文件加入版本控制&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git add xxx.md
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;提交此次修改&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git commit -m &amp;quot;增加了一个文件，并且修改了内容&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看修改历史&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git log
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建新分支，进行实验性的操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git checkout -b new_branch
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;合并分支&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git checkout master # 切换到接收合并的分支
git merge new_branch  # 接收new_branch 分支的合并
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;删除分支&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git branch -d new_branch
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;切换版本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git reset --hard 1j284jf  # 切换到指定了历史中
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;注意-以上命令都是你的本地仓库进行的&#34;&gt;注意！以上命令都是你的本地仓库进行的！！！！&lt;/h4&gt;

&lt;h4 id=&#34;注意-以上命令掌握之后-日常使用gui完成操作&#34;&gt;注意！以上命令掌握之后，日常使用GUI完成操作！&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;为什么？&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;如何和他人交换代码-其实就是交换history&#34;&gt;如何和他人交换代码（其实就是交换History）&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;git托管平台&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;github # 全球最大的同性交友网站&lt;/li&gt;
&lt;li&gt;gitlab # 开源的高度定制化的托管平台&lt;/li&gt;
&lt;li&gt;gogs# 国人使用go开发的开源&lt;strong&gt;精简&lt;/strong&gt;平台&lt;/li&gt;
&lt;li&gt;bitbucket # 国外的免费私有库平台&lt;/li&gt;
&lt;li&gt;gitee # 国内的免费私有库平台&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;注册&lt;br /&gt;
&lt;a href=&#34;https://gitee.com/signup&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://gitee.com/signup&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建远程仓库&lt;br /&gt;
&lt;a href=&#34;https://gitee.com/projects/new&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://gitee.com/projects/new&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;获取仓库地址&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;推送&lt;br /&gt;
push&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;思考，既然是分布式的，那么现在远程仓库和本地仓库的内容是一摸一样吗&lt;br /&gt;
  对于已经push 的分支来说是的。但是对于没有push的分支，远程仓库是没有的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;fork&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;派生一个远程仓库（注意远程仓库，是指托管平台中的仓库，本地仓库是指你电脑中的仓库）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Pull Request&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;远程仓库建的合并（请求目标仓库合并自己的仓库）&lt;/li&gt;
&lt;li&gt;前提：有fork关系&lt;/li&gt;
&lt;li&gt;本质将一个仓库的某分支合并到另一个的仓库的某分支&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;说明，获取代码是整个仓库，交换代码（更新）是以分支为单位的&lt;br /&gt;
所以，新功能一般在新分支开发，然后把整个分支合并到主分支上&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;git工作流程&#34;&gt;Git工作流程&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;获取代码&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果没有克隆仓库，先克隆仓库
&lt;code&gt;git clone git@gitee.com:DN_Ian/Vip1710.git&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;获取最新数据，使本地仓库与远程仓库一致
&lt;code&gt;git fetch&lt;/code&gt; # 注意pull命令fetch命令的区别,fetch/pull,抓取/拉取， **pull ==  fetch +  merge **&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;开发代码&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;切换到要开发的分支 (假设要对gavin分支进行开发)&lt;br /&gt;
&lt;code&gt;git checkout  origin/gavin&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;新建私有分支，进行开发&lt;br /&gt;
&lt;code&gt;git checkout -b my_branch&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;开发代码&lt;br /&gt;
&lt;code&gt;(略)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;提交&lt;br /&gt;
&lt;code&gt;git commit -a&lt;/code&gt;（在私有分支&lt;code&gt;my_branch&lt;/code&gt;上）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;上传代码&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;保存好正在开发的代码&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;获取最新数据，使本地仓库与远程仓库一致&lt;br /&gt;
&lt;code&gt;git fetch origin&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;切换到要开发的分支 (假设要对gavin分支进行开发)&lt;br /&gt;
&lt;code&gt;git checkout  origin/gavin&lt;/code&gt;&lt;br /&gt;
// 切到一个临时分支，没有名字, 版本与远程gavin分支相同&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将开发完成的私有分支合并, 如果有冲突，使用gui处理冲突&lt;br /&gt;
&lt;code&gt;git merge my_branch&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;上传修改后的gavin分支到远程仓库&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;git push origin my_branch:gavin  #1，推送到属于自己的派生仓库，2.推送到目标分支&lt;/code&gt;&lt;br /&gt;
  // 如果恰好此时远程仓库的gavin分支发生变化，会提示冲突。则重新操作&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;注意区别&#34;&gt;注意区别&lt;/h3&gt;

&lt;p&gt;本地和本地—— checkout/merge&lt;br /&gt;
本地和远程—— clone/pull/fetch/push&lt;br /&gt;
远程和远程—— fork/pull reuqets&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;-&lt;/th&gt;
&lt;th&gt;本地&lt;/th&gt;
&lt;th&gt;远程&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;本地&lt;/td&gt;
&lt;td&gt;checkout/merge&lt;/td&gt;
&lt;td&gt;clone/fetch/push&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;远程&lt;/td&gt;
&lt;td&gt;clone/fetch/push&lt;/td&gt;
&lt;td&gt;fork/pull reuqets&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>Markdown使用</title>
      <link>https://ripple-zjw.github.io/2019/markdown%E8%AF%95%E7%94%A8/</link>
      <pubDate>Wed, 14 Aug 2019 13:22:20 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/markdown%E8%AF%95%E7%94%A8/</guid>
      <description>

&lt;h1 id=&#34;一级标题&#34;&gt;一级标题&lt;/h1&gt;

&lt;h2 id=&#34;二级标题&#34;&gt;二级标题&lt;/h2&gt;

&lt;h3 id=&#34;三级标题&#34;&gt;三级标题&lt;/h3&gt;

&lt;h4 id=&#34;四级标题&#34;&gt;四级标题&lt;/h4&gt;

&lt;h5 id=&#34;五级标题&#34;&gt;五级标题&lt;/h5&gt;

&lt;h6 id=&#34;六级标题&#34;&gt;六级标题&lt;/h6&gt;

&lt;p&gt;&lt;em&gt;倾斜字体&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;++下划线++&lt;/p&gt;

&lt;p&gt;&lt;del&gt;删除线&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;加粗字体&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;分割线&#34;&gt;分割线&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;sequenceDiagram
A-&amp;gt;&amp;gt;B: How are you?
B-&amp;gt;&amp;gt;A: Great!
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;graph LR
A--&amp;gt;B
a--&amp;gt;A
a--&amp;gt;B
B--&amp;gt;a
c--&amp;gt;B
a--&amp;gt;c
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-math&#34;&gt;E = mc^2 + 6^7 * 3 /3
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;print(&#39;hello world!!!!&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
int main(){
    printf(&#39;hello world!!!!\n&#39;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>bootstrap</title>
      <link>https://ripple-zjw.github.io/2019/bootstrap/</link>
      <pubDate>Wed, 14 Aug 2019 13:22:20 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/bootstrap/</guid>
      <description>

&lt;h3 id=&#34;bootstrap&#34;&gt;bootstrap&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;简洁、直观、强悍的前端开发框架，让web开发更迅速、简单
中文网 ： http://www.bootcss.com/
英文网  :  http://getbootstrap.com/
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;容器&#34;&gt;容器&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;流体布局容器
    容器的width为auto，只是两边加了15px的padding。

固定布局
    容器的width会随设备分辨率的不同而生产变化
        分辨率阈值
            w &amp;gt;=1200                容器的width为1170   左右padding为15 （注意是borderBox）
            1200&amp;gt;w &amp;gt;=992        容器的width为970     左右padding为15 （注意是borderBox）
            992 &amp;gt; w &amp;gt;=768       容器的width为750     左右padding为15  （注意是borderBox）
            768 &amp;gt; w &amp;gt;=992       容器的width为auto    左右padding为15  （注意是borderBox）
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;栅格系统&#34;&gt;栅格系统&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; col-lg-x    
 col-md-x
 col-sm-x
 col-xs-x
 x默认拥有12个等级
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;列偏移&#34;&gt;列偏移&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;调整的是margin-left，分13个等级（0到12）
        0时为0%
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;列排序&#34;&gt;列排序&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;push的时候调整的是left，分13个等级（0到12）
        0时为auto

pull的时候调整的是right，分13个等级（0到12）
        0时为auto
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;响应式工具&#34;&gt;响应式工具&lt;/h3&gt;

&lt;h3 id=&#34;容器与栅格盒模型设计的精妙之处&#34;&gt;容器与栅格盒模型设计的精妙之处&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;    container 提供了一个15px的padding
    row 是 column 直接存在的容器，row 默认最多可有12个 column，
同时作为都是左浮动的 column 的 wrapper，自带 clearfix 的性质。
同时 row 还有一个很特殊的地方，就是左右各有 －15px 的 margin，
为了抵消 container 中15px的 padding
    每个column 也会有15px的水平方向的 padding，colunmn 只能在 row 中生存，
由于 row 的 margin 为－15px，那么位于两边的 column 就碰到了 container 的边界。
但是 colunmn 本身又有 15px 的 padding 使得它其中的内容并不会碰到 container，
同时 不同column的内容之间就有了30px的槽

目的是为了确保列与列之间有30px的槽，列与容器之间有15px的槽
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>reset 三个参数--hard --soft --mixed的区别</title>
      <link>https://ripple-zjw.github.io/2019/reset-%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0-hard-soft-mixed%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Wed, 14 Aug 2019 13:22:20 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/reset-%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0-hard-soft-mixed%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>

&lt;h1 id=&#34;hard&#34;&gt;&amp;ndash;hard&lt;/h1&gt;

&lt;p&gt;工作区，暂存区，本地库三者同时更新&lt;/p&gt;

&lt;h1 id=&#34;mixed&#34;&gt;&amp;ndash;mixed&lt;/h1&gt;

&lt;p&gt;只有本地库更新，导致本地库和（暂存区，工作区）的指针不一样，但是暂存区和工作区的文件一样。所以暂存区的文件标为绿色，表示暂存区的文件可以提交到本地库。&lt;/p&gt;

&lt;h1 id=&#34;soft&#34;&gt;&amp;ndash;soft&lt;/h1&gt;

&lt;p&gt;本地库和暂存区更新，导致暂存区的文件标为红色，表示工作区的文件和本地库的文件不一样，可以进行add到暂存区，然后进行提交。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>中序遍历二叉树</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Wed, 14 Aug 2019 13:22:20 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>

&lt;h1 id=&#34;题目-二叉树的中序遍历&#34;&gt;题目：二叉树的中序遍历&lt;/h1&gt;

&lt;p&gt;给定一个二叉树，返回它的中序遍历。&lt;/p&gt;

&lt;h6 id=&#34;示例&#34;&gt;示例:&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;进阶: 递归算法很简单，你可以通过迭代算法完成吗？&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第94题&#34;&gt;来源：力扣（LeetCode）第94题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/binary-tree-inorder-traversal&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/binary-tree-inorder-traversal&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;分析&#34;&gt;分析:&lt;/h3&gt;

&lt;p&gt;两种方法，一种是最常用的递归遍历，非常简单。第二种是迭代遍历，需要用到栈。本文章分析第二种算法。&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路:&lt;/h3&gt;

&lt;p&gt;维护一个栈，每次经过一个节点，就入栈，当节点的左节点没有值时出栈，并继续从出栈的那个节点找它的右节点。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;维护一个栈stack和要储存答案的列表ans&lt;/li&gt;
&lt;li&gt;写一个循环，不停地将左节点一层一层的入栈&lt;/li&gt;
&lt;li&gt;当左节点为None时，不要入栈，并且将栈顶节点弹出&lt;/li&gt;
&lt;li&gt;拿到栈顶节点的value，并且进入该节点的右节点（因为中序遍历是左，中，右）&lt;/li&gt;
&lt;li&gt;继续拿这个节点的左节点，重复2-4步&lt;/li&gt;
&lt;li&gt;当节点值为None 或者 stack为空时结束循环&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def inorderTraversal(self, root: TreeNode) -&amp;gt; List[int]:
        stack = []
        ans = []
        tail = root
        while tail is not None or stack:
            while tail is not None:
                stack.append(tail)
                tail = tail.left
            tail = stack.pop()
            ans.append(tail.val)
            tail = tail.right
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;顺便把递归遍历的代码一起放上来&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def inorderTraversal(self, root: TreeNode) -&amp;gt; List[int]:
        if root is None:
            return []
        stack = []
        self.recursion(stack, root)
        return stack
        
    def recursion(self, stack: List[int], root: TreeNode) -&amp;gt; None:
        if root.left != None:
            self.recursion(stack, root.left)
        stack.append(root.val)
        if root.right != None:
            self.recursion(stack, root.right)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;递归法

&lt;ul&gt;
&lt;li&gt;时间复杂度： O(n) (递归函数 T(n)=2⋅T(n/2) + 1)&lt;/li&gt;
&lt;li&gt;空间复杂度： O(logn)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;迭代法

&lt;ul&gt;
&lt;li&gt;时间复杂度： O(n)&lt;/li&gt;
&lt;li&gt;空间复杂度:  O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总体来说，迭代法比递归法速度更快，毕竟递归调用很耗时，而递归法节省的空间更多，适合资源不多时使用。&lt;/p&gt;

&lt;p&gt;LeetCode上还有一种方法叫做莫里斯遍历，复杂度与迭代法一样，没仔细看过。在这里放上链接
&amp;gt; &lt;a href=&#34;https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode/&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;p&gt;中序遍历的两种方法各有各的优点，尤其是迭代法，时间用的更少，就是实现上没有递归法那么方便。要注意通过栈来储存每次进过的节点，不然的话你再想找之前的节点就找不到了。。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使括号有效的最少添加</title>
      <link>https://ripple-zjw.github.io/2019/%E4%BD%BF%E6%8B%AC%E5%8F%B7%E6%9C%89%E6%95%88%E7%9A%84%E6%9C%80%E5%B0%91%E6%B7%BB%E5%8A%A0/</link>
      <pubDate>Wed, 14 Aug 2019 13:22:20 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%BD%BF%E6%8B%AC%E5%8F%B7%E6%9C%89%E6%95%88%E7%9A%84%E6%9C%80%E5%B0%91%E6%B7%BB%E5%8A%A0/</guid>
      <description>

&lt;h1 id=&#34;题目&#34;&gt;题目：&lt;/h1&gt;

&lt;p&gt;给定一个由 &amp;rsquo;(&amp;lsquo; 和 &amp;rsquo;)&amp;lsquo; 括号组成的字符串 S，我们需要添加最少的括号（ &amp;lsquo;(&amp;lsquo; 或是 &amp;rsquo;)&amp;lsquo;，可以在任何位置），以使得到的括号字符串有效。&lt;/p&gt;

&lt;p&gt;从形式上讲，只有满足下面几点之一，括号字符串才是有效的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;它是一个空字符串，或者&lt;/li&gt;
&lt;li&gt;它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者&lt;/li&gt;
&lt;li&gt;它可以被写作 (A)，其中 A 是有效字符串。&lt;/li&gt;
&lt;li&gt;给定一个括号字符串，返回为使结果字符串有效而必须添加的最少括号数。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;示例 1：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输入：&amp;quot;())&amp;quot;
输出：1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;示例 2：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输入：&amp;quot;(((&amp;quot;
输出：3
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;示例 3：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输入：&amp;quot;()&amp;quot;
输出：0
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;示例 4：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输入：&amp;quot;()))((&amp;quot;
输出：4
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第921题&#34;&gt;来源：力扣（LeetCode）第921题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;题目解析&#34;&gt;题目解析：&lt;/h3&gt;

&lt;p&gt;这题不是很难，比较容易就能想到，只要使用栈就能做出。在这里不讨论栈的方法，而是官方给出的一种更加巧妙和特别的方法，平衡法。&lt;/p&gt;

&lt;h3 id=&#34;解题思路&#34;&gt;解题思路：&lt;/h3&gt;

&lt;p&gt;维护两个变量ans(answer)和bal(balance)，ans是正常的结果，而bal则是题目可能发生的一种特殊情况。比如&amp;rdquo;)))(((&amp;ldquo;这种情况。这个答案应该是六，而不是0，因为右括号在前面，而左括号在后面，这就导致他们无法作为一对有效的括号。如果我们不用bal这个变量的话，应该是这样子的。&lt;/p&gt;

&lt;p&gt;先遍历整个字符串，如果是左括号的话，ans加一，如果是右括号的话，ans减一。看似这样做没什么毛病，但是就像我刚才举得例子，当右括号在左括号的前面或者又括号比左括号多，都会出问题，那怎么办呢？这时，我们bal变量就能派上用场。（可能有人会说用个绝对值就行了，同样是上面那个例子，你会发现用绝对值还是不行！！！！）&lt;/p&gt;

&lt;p&gt;还是刚才的思路，只是我们思考一下，如果右括号在前面或者右括号比左括号多的话，会导致ans的值为负数（出现了一次负数也是负数，不管它后面会不会变为正数）。一旦变成了负数（其实就是ans为-1，因为ans只有+1或-1的操作），那那个右括号一定是需要添加的括号，因为他一定是无效的括号。ans存的应该是需要添加的左括号和有效的两个括号，由于有效的两个括号一加一减没了，所以本质上就是存的无效左括号的次数，所以我们要把无效右括号的次数存在bal里面，同时为了不让右括号的-1导致左括号的次数不对，所以当ans值为-1时，bal要加一，同时ans也要加一，即相当于把ans的负数放在bal中。最后，我们只要将ans和bal相加即可得出答案。&lt;/p&gt;

&lt;h4 id=&#34;简单理解&#34;&gt;简单理解：&lt;/h4&gt;

&lt;p&gt;维护ans和bal两个变量，ans存的是无效的左括号，同时当左括号的后面找到右括号后，左括号变为有效，那么ans就减一，如果右括号太多，左括号都是有效的，那么就有了无效的右括号，把他存在bal里面，同时将它离开ans，也就是ans+1（因为右括号是-1，+1相当于ans-（-1）），这样子一左一右即可以使两边平衡，最后的答案只要把ans和bal（无效左括号和无效右括号）加起来就行了。&lt;/p&gt;

&lt;h3 id=&#34;talk-is-cheap-show-me-the-code&#34;&gt;Talk is cheap, show me the code.&lt;/h3&gt;

&lt;p&gt;平衡法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;class Solution(object):
    def minAddToMakeValid(self, S):
        ans = bal = 0
        for char in S:
            if char == &#39;(&#39;:
                ans += 1
            else:
                ans -= 1
            if ans &amp;lt; 0:
                ans += 1
                bal += 1
        return ans + bal
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;顺便再附上栈的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;class Solution:
    def minAddToMakeValid(self, S: str) -&amp;gt; int:
        validStack = []
        for char in S:
            if char == &#39;)&#39; and validStack and validStack[-1] == &amp;quot;(&amp;quot;:
                validStack.pop()
            else:
                validStack.append(char)
        return len(validStack)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h3&gt;

&lt;p&gt;平衡法
- 时间复杂度：O(n) n为S的长度（代码中的S）
- 空间复杂度：O(1)&lt;/p&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;p&gt;平衡法，我理解为把一个答案分成两类，就比如题目中把无效的括号分为无效左括号和无效右括号，分别求它们的答案，再把它们加在一起，有点像分治算法。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>