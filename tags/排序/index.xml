<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>排序 on LeaveIt</title>
    <link>https://ripple-zjw.github.io/tags/%E6%8E%92%E5%BA%8F/</link>
    <description>Recent content in 排序 on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 23 Aug 2019 13:01:17 +0800</lastBuildDate>
    
	<atom:link href="https://ripple-zjw.github.io/tags/%E6%8E%92%E5%BA%8F/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>有序数组的平方</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</link>
      <pubDate>Fri, 23 Aug 2019 13:01:17 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</guid>
      <description>题目：有序数组的平方  给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。  示例 1： 输入：[-4,-1,0,3,10] 输出：[0,1,9,16,100]  示例 2： 输入：[-7,-3,2,3,11] 输出：[4,9,9,49,121]  提示：  1 &amp;lt;= A.length &amp;lt;= 10000 10000 &amp;lt;= A[i] &amp;lt;= 10000 A已按非递减顺序排序。  来源：力扣（LeetCode）第977题  链接：https://leetcode-cn.com/problems/squares-of-a-sorted-array
 分析： 这道题的方法有两种，一种最简单，先计算，再排序。第二种用双指针做到一遍遍历解答。
思路：  由于数组是按照递增的顺序增长的，因此所有的正数都是递增的，所有的负数加上绝对值都是递减的。 我们用两个指针i和j，i从前往后遍历，j从后往前遍历。 i遇到正数就停下来，j遇到负数就停下来，然后比较他们两谁小，小的那个放到ans答案中。 然后就把放入答案中的那个指针往后前移。 最后退出循环，但是可能有一个指针并没有移到终点，因此要在循环结束后去判断两个指针的情况，把指针后面的值都加到ans中去。 最后得到答案。  代码： class Solution: def sortedSquares(self, A: List[int]) -&amp;gt; List[int]: i = 0 j = len(A) - 1 ans = [] while i &amp;lt; len(A) and j &amp;gt;= 0: # 主循环 while i &amp;lt; len(A) and A[i] &amp;lt; 0: # 遍历到第一个正数 i += 1 while j &amp;gt;= 0 and A[j] &amp;gt;= 0: # 遍历到第一个负数 j -= 1 if i &amp;lt; len(A) and j &amp;gt;= 0: # 谁小就把谁加进来 if A[i] ** 2 &amp;gt; A[j] ** 2: ans.</description>
    </item>
    
    <item>
      <title>高度检查器</title>
      <link>https://ripple-zjw.github.io/2019/%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/</link>
      <pubDate>Fri, 23 Aug 2019 12:59:06 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/</guid>
      <description>题目：高度检查器  学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。 请你返回至少有多少个学生没有站在正确位置数量。该人数指的是：能让所有学生以 非递减 高度排列的必要移动人数。  示例： 输入：[1,1,4,2,1,3] 输出：3 解释： 高度为 4、3 和最后一个 1 的学生，没有站在正确的位置。  提示：  1 &amp;lt;= heights.length &amp;lt;= 100 1 &amp;lt;= heights[i] &amp;lt;= 100  来源：力扣（LeetCode）第1051题  链接：https://leetcode-cn.com/problems/height-checker
 分析： 有两种方法。都是先排序，然后比较两者之间的差异。不同处，第一种是比较排序，第二种是计数排序。计数排序的时间复杂度相对较低，本文讲解计数排序。
思路：  因为heights[i]不会超过100，所以采用hash的思想，将所给数组每个值出现的次数作为值，将所给数组的值作为下标，这样相同值出现的次数就会被归在一起，而且值小的元素会在前面，因为下标就是值。 如果1出现了3次，那么这3次一定是在最前面的，所以我们顺序遍历原数组，如果前3次不是1，就说明这个数要移动，以此类推。  代码： class Solution: def heightChecker(self, heights: List[int]) -&amp;gt; int: ans = 0 arr = [0] * 101 # heights[i]最多不超过100个 for height in heights: # 将heights散列到arr中 arr[height] += 1 j = 0 for i in range(1, len(arr)): # 根据arr中的计数排序比较原数组 while arr[i] &amp;gt; 0: if heights[j] !</description>
    </item>
    
  </channel>
</rss>