<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>记忆化搜索 on LeaveIt</title>
    <link>https://ripple-zjw.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</link>
    <description>Recent content in 记忆化搜索 on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 09 Nov 2019 21:30:11 +0800</lastBuildDate>
    
	<atom:link href="https://ripple-zjw.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>分汤</title>
      <link>https://ripple-zjw.github.io/2019/%E5%88%86%E6%B1%A4/</link>
      <pubDate>Sat, 09 Nov 2019 21:30:11 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%88%86%E6%B1%A4/</guid>
      <description>题目：分汤  有A和B两种类型的汤。一开始每种类型的汤有N毫升。有四种分配操作： 提供 100ml 的汤A 和 0ml 的汤B。 提供 75ml 的汤A 和 25ml 的汤B。 提供 50ml 的汤A 和 50ml 的汤B。 提供 25ml 的汤A 和 75ml 的汤B。 当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为0.25的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。 注意不存在先分配100 ml汤B的操作。 需要返回的值：汤A先分配完的概率 + 汤A和汤B同时分配完的概率 / 2。  示例: 输入: N = 50 输出: 0.625 解释: 如果我们选择前两个操作，A将首先变为空。 对于第三个操作，A和B会同时变为空。 对于第四个操作，B将首先变为空。 所以A变为空的总概率加上A和B同时变为空的概率的一半是 0.25 *(1 + 1 + 0.5 + 0)= 0.625。  注释:  0 &amp;lt;= N &amp;lt;= 10^9。 返回值在10^-6的范围将被认为是正确的。  来源：力扣（LeetCode）第808题  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>多边形三角剖分的最低得分</title>
      <link>https://ripple-zjw.github.io/2019/%E5%A4%9A%E8%BE%B9%E5%BD%A2%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86%E7%9A%84%E6%9C%80%E4%BD%8E%E5%BE%97%E5%88%86/</link>
      <pubDate>Sat, 09 Nov 2019 21:25:31 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%A4%9A%E8%BE%B9%E5%BD%A2%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86%E7%9A%84%E6%9C%80%E4%BD%8E%E5%BE%97%E5%88%86/</guid>
      <description>题目：多边形三角剖分的最低得分  给定N，想象一个凸N边多边形，其顶点按顺时针顺序依次标记为A[0], A[i], ..., A[N-1]。 假设您将多边形剖分为N-2个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有N-2个三角形的值之和。 返回多边形进行三角剖分后可以得到的最低分。  示例 1： 输入：[1,2,3] 输出：6 解释：多边形已经三角化，唯一三角形的分数为 6。  示例 2： 输入：[3,7,4,5] 输出：144 解释：有两种三角剖分，可能得分分别为：3*7*5 + 4*5*7 = 245，或 3*4*5 + 3*4*7 = 144。最低分数为 144。  示例 3： 输入：[1,3,1,4,1,5] 输出：13 解释：最低分数三角剖分的得分情况为 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13。  提示：  3 &amp;lt;= A.length &amp;lt;= 50 1 &amp;lt;= A[i] &amp;lt;= 100  来源：力扣（LeetCode）第1039题  链接：https://leetcode-cn.com/problems/minimum-score-triangulation-of-polygon
 分析：  可以使用dp或者dfs两种方法(好像很多题我都会这么讲。。。) 这两种方式的思路完全一致，唯一的不同就是一个是递归一个是dp。 我们声明两个状态i，j为从第i个位置开始，到第j个位置为止。 我们发现如果i==j-1的话，是不可能会有答案的，因为中间还要有第三个位置。 至少要i+2==j才行，这样中间才能有一个位置放第三个点。 也就是说如果中间有两个位置，那么第三个点就有两种可能，以此类推。 如果中间有多个位置，我们随便选择其中的一个，一个三角形的三个点就是i,j,k(中间的那个点)，那么另外n-3个三角形的顶点的值要怎么算呢？我们发现除去i,j,k这个三角形外，其他的三角形的值我们在小一维的dp里已经算过了(就是长度比当前长度小1的那些值)。 比如现在我们要找其他的三角形那么其他的三角形的值就是dp[i][k]和dp[k][j]里面，而这两个值肯定已经算过了，因为这两个值所代表的状态肯定比当前状态的长度要小。  代码：  dp</description>
    </item>
    
    <item>
      <title>组合总和</title>
      <link>https://ripple-zjw.github.io/2019/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C4/</link>
      <pubDate>Sat, 09 Nov 2019 21:23:14 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C4/</guid>
      <description>题目：组合总和 Ⅳ  给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。  示例: nums = [1, 2, 3] target = 4 所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) 请注意，顺序不同的序列被视作不同的组合。 因此输出为 7。  进阶：  如果给定的数组中含有负数会怎么样？ 问题会产生什么变化？ 我们需要在题目中添加什么限制来允许负数的出现？  来源：力扣（LeetCode）第377题  链接：https://leetcode-cn.com/problems/combination-sum-iv
 分析：  dp和dfs两种方法。  代码：  dp
class Solution { public int combinationSum4(int[] nums, int target) { int len = nums.length; int[] dp = new int[target+1]; dp[0] = 1; for (int i = 1; i &amp;lt;= target; i++) { for (int num : nums) if (i &amp;gt;= num) dp[i] += dp[i-num]; } return dp[target]; } }  dfs + 记忆化</description>
    </item>
    
    <item>
      <title>“马”在棋盘上的概率</title>
      <link>https://ripple-zjw.github.io/2019/%E9%A9%AC%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/</link>
      <pubDate>Wed, 23 Oct 2019 20:17:40 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E9%A9%AC%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/</guid>
      <description>题目：“马”在棋盘上的概率  已知一个NxN的国际象棋棋盘，棋盘的行号和列号都是从 0 开始。即最左上角的格子记为(0, 0)，最右下角的记为(N-1, N-1)。 现有一个 “马”（也译作 “骑士”）位于(r, c)，并打算进行K 次移动。 如下图所示，国际象棋的 “马” 每一步先沿水平或垂直方向移动 2 个格子，然后向与之相垂直的方向再移动 1 个格子，共有 8 个可选的位置。  现在 “马” 每一步都从可选的位置（包括棋盘外部的）中独立随机地选择一个进行移动，直到移动了K次或跳到了棋盘外面。 求移动结束后，“马” 仍留在棋盘上的概率。  示例： 输入: 3, 2, 0, 0 输出: 0.0625 解释: 输入的数据依次为 N, K, r, c 第 1 步时，有且只有 2 种走法令 “马” 可以留在棋盘上（跳到（1,2）或（2,1））。对于以上的两种情况，各自在第2步均有且只有2种走法令 “马” 仍然留在棋盘上。 所以 “马” 在结束后仍在棋盘上的概率为 0.0625。  注意：  N 的取值范围为 [1, 25] K 的取值范围为 [0, 100] 开始时，“马” 总是位于棋盘上  来源：力扣（LeetCode）第688题  链接：https://leetcode-cn.</description>
    </item>
    
  </channel>
</rss>