<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeaveIt on LeaveIt</title>
    <link>https://ripple-zjw.github.io/</link>
    <description>Recent content in LeaveIt on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 21 Sep 2019 16:04:38 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>比特位计数</title>
      <link>https://ripple-zjw.github.io/2019/%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/</link>
      <pubDate>Sat, 21 Sep 2019 16:04:38 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/</guid>
      <description>

&lt;h1 id=&#34;题目-比特位计数&#34;&gt;题目：比特位计数&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个非负整数&lt;code&gt;num&lt;/code&gt;。对于&lt;code&gt;0 ≤ i ≤ num&lt;/code&gt; 范围中的每个数字&lt;code&gt;i&lt;/code&gt;，计算其二进制数中的&lt;code&gt;1&lt;/code&gt; 的数目并将它们作为数组返回。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: 2
输出: [0,1,1]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: 5
输出: [0,1,1,2,1,2]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;进阶&#34;&gt;进阶:&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？&lt;/li&gt;
&lt;li&gt;要求算法的空间复杂度为O(n)。&lt;/li&gt;
&lt;li&gt;你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如C++中的&lt;code&gt;__builtin_popcount&lt;/code&gt;）来执行此操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第338题&#34;&gt;来源：力扣（LeetCode）第338题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/counting-bits&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/counting-bits&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;由于偶数的二进制数最后一位是0，所以如果一个偶数做&lt;code&gt;&amp;gt;&amp;gt;1&lt;/code&gt;运算那么它的1的个数不变。同理如果一个奇数右移一位，1的个数减1。&lt;/li&gt;
&lt;li&gt;因此如果1有1个1，那么2也有1个1,3就有2个1。(正推的话做左移运算),如果2有1个1的话，那么4也是1个1,5就是2个1。&lt;/li&gt;
&lt;li&gt;所以有了状态转换公式&lt;code&gt;dp[2*i] = dp[i] dp[2*i+1] = dp[i] + 1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int[] countBits(int num) {
        int[] dp = new int[num + 1];
        for (int i = 0; i &amp;lt;= num / 2; i++) {
            dp[i&amp;lt;&amp;lt;1] = dp[i];
            if ((i&amp;lt;&amp;lt;1) + 1 &amp;lt;= num) dp[(i&amp;lt;&amp;lt;1)+1] = dp[i] + 1;
        }
        return dp;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n 为num / 2&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n) n 为num&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>有序链表转换二叉搜索树</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Sat, 21 Sep 2019 15:50:29 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>

&lt;h1 id=&#34;题目-有序链表转换二叉搜索树&#34;&gt;题目：有序链表转换二叉搜索树&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。&lt;/li&gt;
&lt;li&gt;本题中，一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过&lt;code&gt;1&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;给定的有序链表： [-10, -3, 0, 5, 9],

一个可能的答案是：[0, -3, 9, -10, null, 5],
它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第109题&#34;&gt;来源：力扣（LeetCode）第109题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;递归 + 快慢双指针

&lt;ul&gt;
&lt;li&gt;使用快慢指针找出链表的中点。&lt;/li&gt;
&lt;li&gt;然后将中点生成树的根。&lt;/li&gt;
&lt;li&gt;递归进入左右子树。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;模拟遍历中序二叉树

&lt;ul&gt;
&lt;li&gt;算出链表的长度&lt;/li&gt;
&lt;li&gt;把链表一分为二&lt;/li&gt;
&lt;li&gt;递归进入链表的左边和右边&lt;/li&gt;
&lt;li&gt;同时，在左边递归完后生成父节点&lt;/li&gt;
&lt;li&gt;再把递归得到的左右子节点放在父节点的left和right&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;递归 + 快慢双指针&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* Definition for singly-linked list.
* public class ListNode {
*     int val;
*     ListNode next;
*     ListNode(int x) { val = x; }
* }
*/
/**
* Definition for a binary tree node.
* public class TreeNode {
*     int val;
*     TreeNode left;
*     TreeNode right;
*     TreeNode(int x) { val = x; }
* }
*/
class Solution {
public TreeNode sortedListToBST(ListNode head) {
    return recursion(head,null);
}
public TreeNode recursion(ListNode point, ListNode end) {
    if (point == end) return null;
    ListNode head = point, fast = point, slow = point;
    while (fast != end &amp;amp;&amp;amp; fast.next != end) {slow = slow.next;fast = fast.next.next;}
    TreeNode node = new TreeNode(slow.val);
    node.left = recursion(head, slow);
    node.right = recursion(slow.next, end);
    return node;
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;模拟遍历中序二叉树&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* Definition for singly-linked list.
* public class ListNode {
*     int val;
*     ListNode next;
*     ListNode(int x) { val = x; }
* }
*/
/**
* Definition for a binary tree node.
* public class TreeNode {
*     int val;
*     TreeNode left;
*     TreeNode right;
*     TreeNode(int x) { val = x; }
* }
*/
class Solution {
private ListNode head;

public TreeNode sortedListToBST(ListNode head) {
    this.head = head;
    int cnt = -1;ListNode tail = head;
    while (tail != null) {cnt++;tail = tail.next;} // 拿到链表的长度
    return recursion(0, cnt);
}

public TreeNode recursion(int left, int right) {
    if (left &amp;gt; right) return null;
    int mid = (left + right) &amp;gt;&amp;gt; 1;
    TreeNode l = recursion(left, mid - 1);
    TreeNode node = new TreeNode(head.val);
    node.left = l;
    head = head.next;
    node.right = recursion(mid + 1, right);
    return node;
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
def sortedListToBST(self, head: ListNode) -&amp;gt; TreeNode:
    self.head = head
    tail = head
    cnt = -1
    while tail:
        cnt += 1
        tail = tail.next;

    def recursion(left, right):
        if left &amp;gt; right:
            return
        mid = (left + right) &amp;gt;&amp;gt; 1
        l = recursion(left, mid - 1)
        node = TreeNode(self.head.val)
        self.head = self.head.next
        node.left = l
        node.right = recursion(mid + 1, right)
        return node
    return recursion(0, cnt)   
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>回文链表</title>
      <link>https://ripple-zjw.github.io/2019/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sat, 21 Sep 2019 15:48:18 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</guid>
      <description>

&lt;h1 id=&#34;题目-回文链表&#34;&gt;题目：回文链表&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;请判断一个链表是否为回文链表。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: 1-&amp;gt;2
输出: false
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: 1-&amp;gt;2-&amp;gt;2-&amp;gt;1
输出: true
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;进阶&#34;&gt;进阶：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;你能否用&lt;code&gt;O(n)&lt;/code&gt;时间复杂度和&lt;code&gt;O(1)&lt;/code&gt;空间复杂度解决此题？&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第234题&#34;&gt;来源：力扣（LeetCode）第234题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/palindrome-linked-list&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/palindrome-linked-list&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;最常见的做法是将链表变为数组，通过数组的随机访问的特性检测回文链表。&lt;/li&gt;
&lt;li&gt;第二种更为方便的方法是使用快慢双指针找到链表的中点，然后将前半部分的链表翻转。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null)  //两种特殊情况 return true;
        ListNode slow = head, fast = head; //快慢指针
        while (fast != null &amp;amp;&amp;amp; fast.next != null) {slow = slow.next;fast = fast.next.next;} //找到链表的中间位置奇数找到的是正中间，偶数得到的是中间靠右的数
        ListNode pre = head.next, next; // 翻转前半链表，pre储存的是后面的结点，next储存的是head翻转后的head.next
        while (pre != slow) { // 如果pre等于slow，那么head会指向slow前面的那个数
            next = head;head = pre;  // 如果实在看不懂的话自己画一下就明白了
            pre = head.next;head.next = next;
        }
        if (fast != null) slow = slow.next; // 如果链表是奇数的长度，那么fast.next == null，这时slow往前移一位
        while (head != null &amp;amp;&amp;amp; slow != null) { // 检测是否回文
            if (head.val != slow.val) return false;
            head = head.next;slow = slow.next;
        }
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>环形链表</title>
      <link>https://ripple-zjw.github.io/2019/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sat, 21 Sep 2019 15:45:40 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</guid>
      <description>

&lt;h1 id=&#34;题目-环形链表&#34;&gt;题目：环形链表&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个链表，判断链表中是否有环。&lt;/li&gt;
&lt;li&gt;为了表示给定链表中的环，我们使用整数&lt;code&gt;pos&lt;/code&gt; 来表示链表尾连接到链表中的位置（索引从&lt;code&gt;0&lt;/code&gt;开始）。 如果&lt;code&gt;pos&lt;/code&gt;是&lt;code&gt;-1&lt;/code&gt;,则在该链表中没有环。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-3&#34;&gt;示例 3：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;进阶&#34;&gt;进阶：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;你能用 O(1)（即，常量）内存解决此问题吗？&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第141题&#34;&gt;来源：力扣（LeetCode）第141题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/linked-list-cycle&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/linked-list-cycle&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;这道题可以使用哈希表来做，但这样的空间复杂度是O(n),另一种方法是快慢双指针。&lt;/li&gt;
&lt;li&gt;使用两个指针，一个每次走一格，另一个每次走两格。&lt;/li&gt;
&lt;li&gt;最后看快指针会不会走到头，或者这两个指针碰到了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) return false;
        ListNode slow = head, fast = head.next;
        while (slow != fast) {
            if (fast == null || fast.next == null) return false;
            slow = slow.next;fast = fast.next.next;
        }
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用set来做&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* Definition for singly-linked list.
* class ListNode {
*     int val;
*     ListNode next;
*     ListNode(int x) {
*         val = x;
*         next = null;
*     }
* }
*/
public class Solution {
public boolean hasCycle(ListNode head) {
    Set&amp;lt;ListNode&amp;gt; cycle = new HashSet();
    while (head != null) {
        if (cycle.contains(head)) return true;
        cycle.add(head);
        head = head.next;
    }
    return false;
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>漂亮数组</title>
      <link>https://ripple-zjw.github.io/2019/%E6%BC%82%E4%BA%AE%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sat, 21 Sep 2019 15:32:09 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%BC%82%E4%BA%AE%E6%95%B0%E7%BB%84/</guid>
      <description>

&lt;h1 id=&#34;题目-漂亮数组&#34;&gt;题目：漂亮数组&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;对于某些固定的&lt;code&gt;N&lt;/code&gt;，如果数组&lt;code&gt;A&lt;/code&gt;是整数&lt;code&gt;1, 2, ...&lt;/code&gt;, &lt;code&gt;N&lt;/code&gt;组成的排列，使得：
对于每个&lt;code&gt;i &amp;lt; j&lt;/code&gt;，都不存在&lt;code&gt;k&lt;/code&gt;满足&lt;code&gt;i &amp;lt; k &amp;lt; j&lt;/code&gt;使得&lt;code&gt;A[k] * 2 = A[i] + A[j]&lt;/code&gt;。
那么数组&lt;code&gt;A&lt;/code&gt;是漂亮数组。&lt;/li&gt;
&lt;li&gt;给定&lt;code&gt;N&lt;/code&gt;，返回任意漂亮数组&lt;code&gt;A&lt;/code&gt;（保证存在一个）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：4
输出：[2,1,4,3]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：5
输出：[3,1,2,5,4]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;提示&#34;&gt;提示：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= N &amp;lt;= 1000&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第932题&#34;&gt;来源：力扣（LeetCode）第932题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/beautiful-array&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/beautiful-array&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;根据题目的要求，所谓漂亮数组就是&lt;code&gt;A[k] * 2 != A[i] + A[j]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A[k] * 2&lt;/code&gt;一定是一个偶数，那么我们只需要让&lt;code&gt;A[i] + A[j]&lt;/code&gt;是奇数就行了，如果我们把奇数放在左边，偶数放在右边，那么左右两边各取一个数相加一定是奇数。&lt;/li&gt;
&lt;li&gt;那么还有一个问题，若&lt;code&gt;i&lt;/code&gt;是偶数，&lt;code&gt;j&lt;/code&gt;也是偶数怎么办？&lt;/li&gt;
&lt;li&gt;如果我们要知道8个数的漂亮数组，首先8有4个奇数，4个偶数，我们需要知道4个数的漂亮数组，如果要知道4个数的漂亮数组又要分为2奇数，2偶数，直到为1个数时，漂亮数组为&lt;code&gt;[1]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;漂亮数组又有一个性质，如果我们把数组中每个元素都乘以a并且加上b(a,b为任意除0外的数)，那么它还是漂亮数组。&lt;/li&gt;
&lt;li&gt;同样的我们把奇偶两个漂亮数组相加，结果还是漂亮数组。&lt;/li&gt;
&lt;li&gt;既然如此，&lt;code&gt;[1]&lt;/code&gt;是漂亮数组，那么我将&lt;code&gt;1*2-1&lt;/code&gt;也是是漂亮数组，我将&lt;code&gt;1*2&lt;/code&gt;也是漂亮数组，我把这两个数放在一起，也就是&lt;code&gt;[1,2]&lt;/code&gt;也是漂亮数组。以此类推，4个数的漂亮数组就是&lt;code&gt;[1,3,2,4]&lt;/code&gt;,8个数就是&lt;code&gt;[1,5,3,7,2,6,4,8]&lt;/code&gt;。如果数不足8个多于4个，我只需要把多余的拿掉就行了。&lt;/li&gt;
&lt;li&gt;通过这种方式，可以发现，比如奇数部分的数两数相加除以2要么是偶数，要么在中间根本找不到这个数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;分治算法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def beautifulArray(self, N: int) -&amp;gt; List[int]:
    def divi(N):
        ans = {1: [1]}
        if N not in ans:
            odds = divi((N + 1) // 2)
            evens = divi(N // 2)
            ans[N] = [2 * odd - 1 for odd in odds] + [2 * even for even in evens]
        return ans[N]
    return divi(N)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;分治法的迭代版本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def beautifulArray(self, N: int) -&amp;gt; List[int]:
    ans = [1]
    while len(ans) &amp;lt; N:
        ans = [2 * odd - 1 for odd in ans] + [2 * even for even in ans]
    return [i for i in ans if i &amp;lt;= N]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(nlogn)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>数组中的第K个最大元素</title>
      <link>https://ripple-zjw.github.io/2019/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</link>
      <pubDate>Sat, 21 Sep 2019 15:30:13 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</guid>
      <description>

&lt;h1 id=&#34;题目-数组中的第k个最大元素&#34;&gt;题目：数组中的第K个最大元素&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;在未排序的数组中找到第k个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;说明&#34;&gt;说明:&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第215题&#34;&gt;来源：力扣（LeetCode）第215题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/kth-largest-element-in-an-array&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/kth-largest-element-in-an-array&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;有两种做法，一种是使用快排思想，选中一个数，对其进行&lt;code&gt;partition&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;第二种做法是使用堆，维护一个大顶堆，要拿到第k大元素就删除堆顶k次&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;快速排序改进：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def findKthLargest(self, nums: List[int], k: int) -&amp;gt; int:
    self.k = k
    ans =  self.quickSort(nums, 0, len(nums) - 1)
    return ans if ans else nums[k-1]
        
def portition(self, arr, start, end):
    pivot = arr[end]
    i = start - 1
    for j in range(start, end):
        if pivot &amp;lt; arr[j]:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i+1], arr[end] = arr[end], arr[i+1]
    return i + 1
    
def quickSort(self, arr, start, end):
    if start &amp;lt; end:
        pivot = self.portition(arr, start, end)
        if pivot + 1 == self.k:  # 唯一与快排的区别就是当pivot已经是第k大元素时就直接返回。
            return arr[pivot]
        self.quickSort(arr, start, pivot - 1)
        self.quickSort(arr, pivot + 1, end)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用堆：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def findKthLargest(self, nums: List[int], k: int) -&amp;gt; int:
    self.length = len(nums)
    for i in range(self.length // 2 - 1, -1, -1):  # 把数组构建成堆
        self.maxheapify(nums, i)
    ans = nums[0]
    for i in range(k):  # 拿到第k大元素
        ans = nums[0]
        nums[0] = nums[self.length - 1]
        self.length -= 1
        self.maxheapify(nums, 0)
    return ans

def maxheapify(self, heap, i):  # 堆的关键方法，作用是维护堆，任何涉及到堆的操作基本都需要。
    left = 2 * (i + 1) - 1
    right = 2 * (i + 1)
    largest = i
    if left &amp;lt; self.length and heap[largest] &amp;lt; heap[left]:
        largest = left
    if right &amp;lt; self.length and heap[largest] &amp;lt; heap[right]:
        largest = right
    if largest != i:
        heap[largest], heap[i] = heap[i], heap[largest]
        self.maxheapify(heap, largest)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;快速排序：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(nlogn)这是最坏情况下，最好情况下为O(n)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1) 快速排序本来就是原地排序，不需要额外的空间。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;使用堆：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(nlogn) n为二分之一的数组长度，&lt;code&gt;maxheapify&lt;/code&gt;的时间复杂度为&lt;code&gt;logn&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1) 构建堆以及拿出堆顶都只需要常数空间。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>为运算表达式设计优先级</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7/</link>
      <pubDate>Tue, 10 Sep 2019 22:59:46 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7/</guid>
      <description>

&lt;h1 id=&#34;题目-为运算表达式设计优先级&#34;&gt;题目：为运算表达式设计优先级&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含&lt;code&gt;+&lt;/code&gt;,&lt;code&gt;-&lt;/code&gt;以及&lt;code&gt;*&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;2-1-1&amp;quot;
输出: [0, 2]
解释: 
((2-1)-1) = 0 
(2-(1-1)) = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;2*3-4*5&amp;quot;
输出: [-34, -14, -10, -10, 10]
解释: 
(2*(3-(4*5))) = -34 
((2*3)-(4*5)) = -14 
((2*(3-4))*5) = -10 
(2*((3-4)*5)) = -10 
(((2*3)-4)*5) = 10
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第241题&#34;&gt;来源：力扣（LeetCode）第241题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/different-ways-to-add-parentheses&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/different-ways-to-add-parentheses&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;## 分析：
 - 动态规划+分治算法。
 - 当只有一个运算符时，只有一种情况，当有两个运算符时有两种情况，以此类推。
 - 当有三个运算符时，假设第一个运算符优先级最高，然后剩下三个数有两种情况，将两种情况与其相加，得到答案。接着判断第二个运算符优先级最低时，依次类推。&lt;/p&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from functools import lru_cache  # lru缓存淘汰算法。
class Solution:
    @lru_cache(None)
    def diffWaysToCompute(self, input: str) -&amp;gt; List[int]:
        if input.isdigit():  # 基线条件
            return [int(input)]
        opt = {&#39;-&#39;, &#39;+&#39;, &#39;*&#39;}  # 运算符集合
        ans = []  # 储存答案
        for i, char in enumerate(input):  # 判断每个运算符优先级最低的时候。
            if char in opt:  # 如果是运算符才执行
                left = self.diffWaysToCompute(input[:i])  # 拿到运算符的左边，递归
                right = self.diffWaysToCompute(input[i+1:])  # 拿到运算符的右边，递归
                ans.extend([self.operator(l, r, char) for l in left for r in right])  # 将运算符的左右两边的值按照运算符做运算。left和right拿到的是列表，就像前面说的，如果左边有不止一个运算符时答案也不止一个，右边同理。
        return ans
    def operator(self, l, r, char):  # 根据运算符做运算符操作，char就是运算符。
        if char == &#39;-&#39;:
            return l - r
        elif char == &#39;+&#39;:
            return l + r
        else:
            return l * r
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n!)n为运算符的个数，个人认为&lt;/li&gt;
&lt;li&gt;空间复杂度：实在算不出来了。。。。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>搜索插入位置</title>
      <link>https://ripple-zjw.github.io/2019/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Tue, 10 Sep 2019 22:48:08 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</guid>
      <description>

&lt;h1 id=&#34;搜索插入位置&#34;&gt;搜索插入位置&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;/li&gt;
&lt;li&gt;你可以假设数组中无重复元素。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,3,5,6], 5
输出: 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,3,5,6], 2
输出: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-3&#34;&gt;示例 3:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,3,5,6], 7
输出: 4
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-4&#34;&gt;示例 4:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,3,5,6], 0
输出: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第35题&#34;&gt;来源：力扣（LeetCode）第35题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/search-insert-position&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/search-insert-position&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;两种二分查找模版&#34;&gt;两种二分查找模版：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;target = 要查找的值
left = 0, right = arr.length
while left &amp;lt; right:
    mid = (left + right) &amp;gt;&amp;gt; 1
    // 为了防止数组溢出，也可以写成left + (right - left) &amp;gt;&amp;gt; 1
    if arr[mid] == target:
        return arr[mid]
    elif arr[mid] &amp;gt; target:
        right = mid
    else:
        left = mid + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;target = 要查找的值
left = 0, right = arr.length - 1
while left &amp;lt;= right:
    mid = (left + right) &amp;gt;&amp;gt; 1
    // 为了防止数组溢出，也可以写成left + (right - left) &amp;gt;&amp;gt; 1
    if arr[mid] == target:
        return arr[mid]
    elif arr[mid] &amp;gt; target:
        right = mid - 1
    else:
        left = mid + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def searchInsert(self, nums: List[int], target: int) -&amp;gt; int:
        left = 0
        right = len(nums)
        while left &amp;lt; right:
            mid = (left + right) &amp;gt;&amp;gt; 1
            if nums[mid] == target:
                return mid
            elif nums[mid] &amp;gt; target:
                right = mid
            else:
                left = mid + 1
        return left  # 基本和模版一样，就是如果没有找到的话，就返回left，可以自己推测出来
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left &amp;lt;= right) {
            int mid = left + ((right - left) &amp;gt;&amp;gt; 1);
            if (nums[mid] == target) return mid;
            else if (nums[mid] &amp;lt; target) left = mid + 1;
            else right = mid - 1;
        }
        return left;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(logn) 二分查找&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>使用异或运算判断奇偶性</title>
      <link>https://ripple-zjw.github.io/2019/%E4%BD%BF%E7%94%A8%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E5%88%A4%E6%96%AD%E5%A5%87%E5%81%B6%E6%80%A7/</link>
      <pubDate>Tue, 10 Sep 2019 22:46:51 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%BD%BF%E7%94%A8%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E5%88%A4%E6%96%AD%E5%A5%87%E5%81%B6%E6%80%A7/</guid>
      <description>

&lt;h1 id=&#34;使用异或运算判断奇偶性&#34;&gt;使用异或运算判断奇偶性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;原理是通过异或运算中的一个数与自己本身异或得到0，与0异或得到自己。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;解释&#34;&gt;解释：&lt;/h2&gt;

&lt;p&gt;比如说有一组数组&lt;code&gt;[1, 1, 1, 1]&lt;/code&gt;
我们使用异或判断&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;ans = [1, 1, 1, 1]
parity = ans[0]  # 拿出第一个数
for i in ans[1:]:  # 从数组的第二个数开始循环
    parity ^= i
parity == 1  # 如果等于1说明1有奇数个，如果等于0说明1有偶数个。例如1^1=0 0^1=1
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>使用最小花费爬楼梯</title>
      <link>https://ripple-zjw.github.io/2019/%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</link>
      <pubDate>Tue, 10 Sep 2019 22:45:45 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</guid>
      <description>

&lt;h1 id=&#34;题目-使用最小花费爬楼梯&#34;&gt;题目：使用最小花费爬楼梯&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值&lt;code&gt;cost[i]&lt;/code&gt;(索引从0开始)。&lt;/li&gt;
&lt;li&gt;每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。&lt;/li&gt;
&lt;li&gt;您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: cost = [10, 15, 20]
输出: 15
解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出: 6
解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;注意&#34;&gt;注意：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cost&lt;/code&gt;的长度将会在&lt;code&gt;[2, 1000]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;每一个&lt;code&gt;cost[i]&lt;/code&gt; 将会是一个Integer类型，范围为&lt;code&gt;[0, 999]&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第746题&#34;&gt;来源：力扣（LeetCode）第746题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/min-cost-climbing-stairs&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/min-cost-climbing-stairs&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;可以使用递归或者动态规划来解这道题。&lt;/li&gt;
&lt;li&gt;思路是如果要跳到第&lt;code&gt;i&lt;/code&gt;个位置，那么就要先跳到&lt;code&gt;i-1&lt;/code&gt;或者是&lt;code&gt;i-2&lt;/code&gt;个位置。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;动态规划：&lt;/li&gt;

&lt;li&gt;&lt;p&gt;python&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def minCostClimbingStairs(self, cost: List[int]) -&amp;gt; int:
    for i in range(2, len(cost)):
        cost[i] = min(cost[i-1], cost[i-2]) + cost[i]  # 你想要跳到第i个位置，就要跳先跳到i-1或i-2个位置。
    return min(cost[-1], cost[-2])  # 决定最后是从倒数第一个位置跳上去，还是倒数第二个位置跳上去。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;java&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
public int minCostClimbingStairs(int[] cost) {
    int n = cost.length;
    for (int i = 2; i &amp;lt; n; i++) {
        cost[i] = Math.min(cost[i-1], cost[i-2]) + cost[i];
    }
    return Math.min(cost[n-1], cost[n-2]);
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;递归：(超时！！！)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Python&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def minCostClimbingStairs(self, cost: List[int]) -&amp;gt; int:
    cost.append(0)
    def recursion(i):
        if i &amp;lt;= 1:
            return cost[i]
        return min(recursion(i - 1), recursion(i - 2)) + cost[i]
    return recursion(len(cost) - 1)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为数组长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1) 几乎用不到额外空间&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>合并两个有序数组</title>
      <link>https://ripple-zjw.github.io/2019/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Tue, 10 Sep 2019 22:44:21 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
      <description>

&lt;h1 id=&#34;题目-合并两个有序数组&#34;&gt;题目：合并两个有序数组&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定两个有序整数数组&lt;code&gt;nums1&lt;/code&gt;和&lt;code&gt;nums2&lt;/code&gt;，将&lt;code&gt;nums2&lt;/code&gt; 合并到&lt;code&gt;nums1&lt;/code&gt;中，使得&lt;code&gt;num1&lt;/code&gt;成为一个有序数组。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;说明&#34;&gt;说明:&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;初始化&lt;code&gt;nums1&lt;/code&gt;和&lt;code&gt;nums2&lt;/code&gt;的元素数量分别为&lt;code&gt;m&lt;/code&gt;和&lt;code&gt;n&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;你可以假设&lt;code&gt;nums1&lt;/code&gt;有足够的空间（空间大小大于或等于&lt;code&gt;m + n&lt;/code&gt;）来保存 &lt;code&gt;nums2&lt;/code&gt; 中的元素。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第88题&#34;&gt;来源：力扣（LeetCode）第88题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/merge-sorted-array&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/merge-sorted-array&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;从后往前放元素，就能解开了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Python&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&amp;gt; None:
    p1 = m - 1  # num1的指针
    p2 = n - 1  # num2的指针
    p = m + n - 1  # num1存放答案的指针
    while p1 &amp;gt;= 0 and p2 &amp;gt;= 0:  # 将两者大的值放进去。
        if nums1[p1] &amp;gt; nums2[p2]:
            nums1[p] = nums1[p1]
            p1 -= 1
        else:
            nums1[p] = nums2[p2]
            p2 -= 1
        p -= 1
    nums1[:p2+1] = nums2[:p2+1]  # 最后将nums2中还没放完的元素放进去。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
public void merge(int[] nums1, int m, int[] nums2, int n) {
    int p1 = m - 1;
    int p2 = n - 1;
    int p = m + n - 1;
    while (p1 &amp;gt;= 0 &amp;amp;&amp;amp; p2 &amp;gt;= 0) {
        if (nums1[p1] &amp;gt; nums2[p2]) {
            nums1[p--] = nums1[p1--];
        } else {
            nums1[p--] = nums2[p2--];
        }
    }
    while (p2 &amp;gt;= 0) nums1[p--] = nums2[p2--];
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;时间复杂度：O(n+m)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;空间复杂度：O(1)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>单调数列</title>
      <link>https://ripple-zjw.github.io/2019/%E5%8D%95%E8%B0%83%E6%95%B0%E5%88%97/</link>
      <pubDate>Tue, 10 Sep 2019 22:42:16 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%8D%95%E8%B0%83%E6%95%B0%E5%88%97/</guid>
      <description>

&lt;h1 id=&#34;题目-单调数列&#34;&gt;题目：单调数列&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;如果数组是单调递增或单调递减的，那么它是单调的。&lt;/li&gt;
&lt;li&gt;如果对于所有&lt;code&gt;i &amp;lt;= j&lt;/code&gt;，&lt;code&gt;A[i] &amp;lt;= A[j]&lt;/code&gt;，那么数组 A 是单调递增的。 如果对于所有&lt;code&gt;i &amp;lt;= j&lt;/code&gt;，&lt;code&gt;A[i]&amp;gt; = A[j]&lt;/code&gt;，那么数组 A 是单调递减的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当给定的数组 A 是单调数组时返回&lt;code&gt;true&lt;/code&gt;，否则返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：[1,2,2,3]
输出：true
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：[6,5,4,4]
输出：true
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-3&#34;&gt;示例 3：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：[1,3,2]
输出：false
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-4&#34;&gt;示例 4：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：[1,2,4,5]
输出：true
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-5&#34;&gt;示例 5：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：[1,1,1]
输出：true
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;提示&#34;&gt;提示：&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;1 &amp;lt;= A.length &amp;lt;= 50000&lt;/li&gt;
&lt;li&gt;-100000 &amp;lt;= A[i] &amp;lt;= 100000&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第896题&#34;&gt;来源：力扣（LeetCode）第896题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/monotonic-array&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/monotonic-array&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;通过大于为1，等于为0，小于为-1判断列表是否单调。&lt;/li&gt;
&lt;li&gt;如果一个数中既出现了1，也出现了-1，那么它不是单调数组。&lt;/li&gt;
&lt;li&gt;有一点要注意，Python2中自带cmp的函数，可以直接判断，而Python3中将cmp函数移除了，所以Python3中需要自己写一个cmp函数，而Python2中不用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Python&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def isMonotonic(self, A: List[int]) -&amp;gt; bool:
    compare = set()
    def cmp(i, j):  # 用于判断的集合
        if i &amp;gt; j:
            return 1
        elif i &amp;lt; j:
            return -1
        else:
            return 0
    for i in range(len(A) - 1):
        compare.add(cmp(A[i], A[i+1]))
        if 1 in compare and -1 in compare:
            return False
    return True
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
public boolean isMonotonic(int[] A) {
    Set&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;Integer&amp;gt;();
    for (int i = 0; i &amp;lt; A.length - 1; i++) {
        int num = Integer.compare(A[i], A[i+1]);
        set.add(num);
        if (set.contains(1) &amp;amp;&amp;amp; set.contains(-1)) {
            return false;
        }
    }
    return true;
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为数组的长度。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>数组的度</title>
      <link>https://ripple-zjw.github.io/2019/%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%A6/</link>
      <pubDate>Fri, 06 Sep 2019 20:27:15 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%A6/</guid>
      <description>

&lt;h1 id=&#34;题目-数组的度&#34;&gt;题目：数组的度&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个非空且只包含非负数的整数数组&lt;code&gt;nums&lt;/code&gt;, 数组的度的定义是指数组里任一元素出现频数的最大值。&lt;/li&gt;
&lt;li&gt;你的任务是找到与&lt;code&gt;nums&lt;/code&gt;拥有相同大小的度的最短连续子数组，返回其长度。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1, 2, 2, 3, 1]
输出: 2
解释: 
输入数组的度是2，因为元素1和2的出现频数最大，均为2.
连续子数组里面拥有相同度的有如下所示:
[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
最短连续子数组[2, 2]的长度为2，所以返回2.
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,2,2,3,1,4,2]
输出: 6
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;注意&#34;&gt;注意:&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nums.length&lt;/code&gt;在1到50,000区间范围内。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nums[i]&lt;/code&gt;是一个在0到49,999范围内的整数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第697题&#34;&gt;来源：力扣（LeetCode）第697题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/degree-of-an-array&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/degree-of-an-array&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;找到每一个元素的第一个下标和最后一个下标。&lt;/li&gt;
&lt;li&gt;然后找出出现频率最高的元素。&lt;/li&gt;
&lt;li&gt;答案就是频率最高的元素的最后一个下标减去第一个下标。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findShortestSubArray(self, nums: List[int]) -&amp;gt; int:
        left, right, count = {}, {}, {}
        for i in range(len(nums)):
            if nums[i] not in left:  # 将第一个下标保存
                left[nums[i]] = i
            right[nums[i]] = i  # 将最后一个下标保存
            count[nums[i]] = count.get(nums[i], 0) + 1  # 累加每个元素出现的频率
        maxCnt = max(count.values())  # 找出最大值
        ans = len(nums)
        for x in count:
            if count[x] == maxCnt:  # 找到最大值的第一个下标和最后一个下标，由于可能出现最高的次数一样的情况，所以要比较所有出现次数最大的元素的长度，再看哪个最小。
                ans = min(ans, right[x] - left[x] + 1)
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为nums的长度。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n) n取决于nums中有多少不重复的数。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>图片平滑器</title>
      <link>https://ripple-zjw.github.io/2019/%E5%9B%BE%E7%89%87%E5%B9%B3%E6%BB%91%E5%99%A8/</link>
      <pubDate>Fri, 06 Sep 2019 20:26:04 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%9B%BE%E7%89%87%E5%B9%B3%E6%BB%91%E5%99%A8/</guid>
      <description>

&lt;h1 id=&#34;题目-图片平滑器&#34;&gt;题目：图片平滑器&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;包含整数的二维矩阵M表示一个图片的灰度。&lt;/li&gt;
&lt;li&gt;你需要设计一个平滑器来让每一个单元的灰度成为平均灰度(向下舍入) ，平均灰度的计算是周围的8个单元和它本身的值求平均，如果周围的单元格不足八个，则尽可能多的利用它们。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入:
[[1,1,1],
 [1,0,1],
 [1,1,1]]
输出:
[[0, 0, 0],
 [0, 0, 0],
 [0, 0, 0]]
解释:
对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0
对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0
对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;注意&#34;&gt;注意:&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;给定矩阵中的整数范围为 [0, 255]。&lt;/li&gt;
&lt;li&gt;矩阵的长和宽的范围均为 [1, 150]。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第661题&#34;&gt;来源：力扣（LeetCode）第661题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/image-smoother&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/image-smoother&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;可以一个一个判断，但是不好，另一种方法，先把八个方向放在一个列表中，然后每次遍历这八个方向。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def imageSmoother(self, M: List[List[int]]) -&amp;gt; List[List[int]]:
        ans = []
        directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]  # 生成八个方向的列表。
        height = len(M)
        width = len(M[0])
        for i in range(height):
            tmp = []
            for j in range(width):
                res = M[i][j]
                cnt = 1
                for direction in directions:
                    y = direction[0] + i
                    x = direction[1] + j
                    if y &amp;lt; height and x &amp;lt; width and x &amp;gt;= 0 and y &amp;gt;= 0:  # 每次都要判断方向是否合法，防止数组越界。
                        res += M[y][x]
                        cnt += 1
                tmp.append(res // cnt)
            ans.append(tmp)
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为M的长度和宽度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>两数之和II 输入有序数组</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8Cii-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Fri, 06 Sep 2019 20:24:19 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8Cii-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
      <description>

&lt;h1 id=&#34;题目-两数之和-ii-输入有序数组&#34;&gt;题目：两数之和 II - 输入有序数组&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个已按照升序排列的有序数组，找到两个数使得它们相加之和等于目标数。&lt;/li&gt;
&lt;li&gt;函数应该返回这两个下标值 index1 和 index2，其中&lt;code&gt;index1&lt;/code&gt;必须小于&lt;code&gt;index2&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;说明&#34;&gt;说明:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;返回的下标值（index1 和 index2）不是从零开始的。
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第167题&#34;&gt;来源：力扣（LeetCode）第167题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;方法有：hash表，二分查找，双指针。&lt;/p&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;hash表:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def twoSum(self, numbers: List[int], target: int) -&amp;gt; List[int]:
    hashTable = {}
    for i in range(len(numbers)):
        if hashTable.get(target - numbers[i]) is not None:
            return hashTable[target - numbers[i]] + 1, i + 1
        hashTable[numbers[i]] = i
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;二分查找:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def twoSum(self, numbers: List[int], target: int) -&amp;gt; List[int]:
    for i in range(len(numbers)):
        ans = target - numbers[i]
        k = len(numbers) - 1
        j = i + 1
        while j &amp;lt;= k:
            mid = (j + k) // 2
            if numbers[mid] == ans:
                return i + 1, mid + 1
            elif numbers[mid] &amp;lt; ans:
                j = mid + 1
            else:
                k = mid - 1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;双指针:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def twoSum(self, numbers: List[int], target: int) -&amp;gt; List[int]:
    i = 0
    j = len(numbers) - 1
    while i &amp;lt; j:
        _sum = numbers[i] + numbers[j]
        if target == _sum:
            return i + 1, j + 1
        elif target &amp;lt; _sum:
            j -= 1
        else:
            i += 1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;hash表：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为数组长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;二分查找：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(nlogn)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;双指针：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为数组长度的一半&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>