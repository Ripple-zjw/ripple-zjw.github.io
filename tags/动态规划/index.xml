<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>动态规划 on LeaveIt</title>
    <link>https://ripple-zjw.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
    <description>Recent content in 动态规划 on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 23 Oct 2019 20:17:40 +0800</lastBuildDate>
    
	<atom:link href="https://ripple-zjw.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>“马”在棋盘上的概率</title>
      <link>https://ripple-zjw.github.io/2019/%E9%A9%AC%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/</link>
      <pubDate>Wed, 23 Oct 2019 20:17:40 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E9%A9%AC%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/</guid>
      <description>题目：“马”在棋盘上的概率  已知一个NxN的国际象棋棋盘，棋盘的行号和列号都是从 0 开始。即最左上角的格子记为(0, 0)，最右下角的记为(N-1, N-1)。 现有一个 “马”（也译作 “骑士”）位于(r, c)，并打算进行K 次移动。 如下图所示，国际象棋的 “马” 每一步先沿水平或垂直方向移动 2 个格子，然后向与之相垂直的方向再移动 1 个格子，共有 8 个可选的位置。  现在 “马” 每一步都从可选的位置（包括棋盘外部的）中独立随机地选择一个进行移动，直到移动了K次或跳到了棋盘外面。 求移动结束后，“马” 仍留在棋盘上的概率。  示例： 输入: 3, 2, 0, 0 输出: 0.0625 解释: 输入的数据依次为 N, K, r, c 第 1 步时，有且只有 2 种走法令 “马” 可以留在棋盘上（跳到（1,2）或（2,1））。对于以上的两种情况，各自在第2步均有且只有2种走法令 “马” 仍然留在棋盘上。 所以 “马” 在结束后仍在棋盘上的概率为 0.0625。  注意：  N 的取值范围为 [1, 25] K 的取值范围为 [0, 100] 开始时，“马” 总是位于棋盘上  来源：力扣（LeetCode）第688题  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>最长上升子序列</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Wed, 23 Oct 2019 20:15:25 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>题目：最长上升子序列  给定一个无序的整数数组，找到其中最长上升子序列的长度。  示例: 输入: [10,9,2,5,3,7,101,18] 输出: 4 解释: 最长的上升子序列是[2,3,7,101]，它的长度是 4。  说明:  可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为O(n^2)。 进阶: 你能将算法的时间复杂度降低到O(n logn)吗?  来源：力扣（LeetCode）第300题  链接：https://leetcode-cn.com/problems/longest-increasing-subsequence
 分析：  非常好的一道题目 可以使用动态规划来解决。 除了最常规的一种方法外还有另一种动态规划的方法，使用二分查找的思想。 具体可以看看搜索插入位置(LeetCode第35题) 动态规划：  设1个状态表示到这个数为止，最长上升子序列是多少。 然后遍历数组，当遍历到第i个状态时，查看在dp中到第i个数为止已经有多长了，那么你只要在右边找到比当前数大的值，然后在它的dp数组下加上1。 最后找到dp数组中最大的值，就是答案。  dp + 二分查找：  我们遍历数组，将每个数放进dp数组中。 由于dp数组是单调递增的，所以可以使用二分查找找到插入的位置。 有两种情况，如果找到了这个值，那么直接覆盖就行了，如果没找到这个值，那么将比它大的最小的值覆盖。其实就是插入位置。   代码：  dp
class Solution { public int lengthOfLIS(int[] nums) { int len = nums.length; int[] dp = new int[len]; Arrays.fill(dp, 1); for (int i = 0; i &amp;lt; len; i++) { for (int j = i + 1; j &amp;lt; len; j++) { if (nums[i] &amp;lt; nums[j]) dp[j] = Math.</description>
    </item>
    
    <item>
      <title>最长的斐波那契子序列的长度</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Wed, 23 Oct 2019 20:09:39 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/</guid>
      <description>题目：最长的斐波那契子序列的长度  如果序列X_1, X_2, ..., X_n满足下列条件，就说它是斐波那契式的： n &amp;gt;= 3 对于所有i + 2 &amp;lt;= n，都有X_i + X_{i+1} = X_{i+2} 给定一个严格递增的正整数数组形成序列，找到 A 中最长的斐波那契式的子序列的长度。如果一个不存在，返回0 。 （回想一下，子序列是从原序列A中派生出来的，它从A中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如，[3, 5, 8]是[3, 4, 5, 6, 7, 8]的一个子序列）  示例 1： 输入: [1,2,3,4,5,6,7,8] 输出: 5 解释: 最长的斐波那契式子序列为：[1,2,3,5,8] 。  示例2： 输入: [1,3,7,11,12,14,18] 输出: 3 解释: 最长的斐波那契式子序列有： [1,11,12]，[3,11,14] 以及 [7,11,18] 。  提示：  3 &amp;lt;= A.length &amp;lt;= 1000 1 &amp;lt;= A[0] &amp;lt; A[1] &amp;lt; &amp;hellip; &amp;lt; A[A.length - 1] &amp;lt;= 10^9 （对于以 Java，C，C++，以及C# 的提交，时间限制被减少了 50%）  来源：力扣（LeetCode）第873题  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>最大平均值和的分组</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC%E5%92%8C%E7%9A%84%E5%88%86%E7%BB%84/</link>
      <pubDate>Wed, 23 Oct 2019 20:03:28 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC%E5%92%8C%E7%9A%84%E5%88%86%E7%BB%84/</guid>
      <description>题目： 最大平均值和的分组  我们将给定的数组A分成K个相邻的非空子数组 ，我们的分数由每个子数组内的平均值的总和构成。计算我们所能得到的最大分数是多少。 注意我们必须使用A数组中的每一个数进行分组，并且分数不一定需要是整数。  示例: 输入: A = [9,1,2,3,9] K = 3 输出: 20 解释: A 的最优分组是[9], [1, 2, 3], [9]. 得到的分数是 9 + (1 + 2 + 3) / 3 + 9 = 20. 我们也可以把 A 分成[9, 1], [2], [3, 9]. 这样的分组得到的分数为 5 + 2 + 6 = 13, 但不是最大值.  说明:  1 &amp;lt;= A.length &amp;lt;= 100. 1 &amp;lt;= A[i] &amp;lt;= 10000. 1 &amp;lt;= K &amp;lt;= A.</description>
    </item>
    
    <item>
      <title>分割等和子集</title>
      <link>https://ripple-zjw.github.io/2019/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</link>
      <pubDate>Wed, 23 Oct 2019 19:58:28 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</guid>
      <description> 题目：分割等和子集  给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。  注意:  每个数组中的元素不会超过 100 数组的大小不会超过 200  示例 1: 输入: [1, 5, 11, 5] 输出: true 解释: 数组可以分割成 [1, 5, 5] 和 [11].  示例2: 输入: [1, 2, 3, 5] 输出: false 解释: 数组不能分割成两个元素和相等的子集.  来源：力扣（LeetCode）第416题  链接：https://leetcode-cn.com/problems/partition-equal-subset-sum
 分析：  动态规划题 0-1背包问题  代码： class Solution { public boolean canPartition(int[] nums) { int sum = 0; int len = nums.length; for (int num : nums) sum += num; if ((sum &amp;amp; 1) == 1) return false; // 如果是奇数，不可能分割 sum &amp;gt;&amp;gt;= 1; // 要找的答案是总和的一半。 boolean[][] dp = new boolean[len][sum+1]; // i表示nums中从0到i为止，j表示是否能找到和为j的数。 if (nums[0] &amp;lt;= sum) dp[0][nums[0]] = true; // 第一个数放在j上，其他都是false for (int i = 1; i &amp;lt; len; i++) { for (int j = 0; j &amp;lt;= sum; j++) { if (nums[i] &amp;lt;= j) // 两种选择，一种之前就找到了和为j的数，那么现在还是true。 // 如果之前没有找到和为j的数，那么我加上这次的数，要找前一次j-nums[i]的和能不能找到。 dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]]; else // 如果当前nums[i] 大于j的话，之前看它前一次是什么状态现在还是什么状态。 dp[i][j] = dp[i-1][j]; } } return dp[len-1][sum]; } }  </description>
    </item>
    
    <item>
      <title>抛掷硬币</title>
      <link>https://ripple-zjw.github.io/2019/%E6%8A%9B%E6%8E%B7%E7%A1%AC%E5%B8%81/</link>
      <pubDate>Wed, 23 Oct 2019 19:43:25 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%8A%9B%E6%8E%B7%E7%A1%AC%E5%B8%81/</guid>
      <description> 题目：抛掷硬币  有一些不规则的硬币。在这些硬币中，prob[i]表示第i枚硬币正面朝上的概率。  请对每一枚硬币抛掷一次，然后返回正面朝上的硬币数等于target的概率。
示例 1： 输入：prob = [0.4], target = 1 输出：0.40000  示例 2： 输入：prob = [0.5,0.5,0.5,0.5,0.5], target = 0 输出：0.03125  提示：  1 &amp;lt;= prob.length &amp;lt;= 1000 0 &amp;lt;= prob[i] &amp;lt;= 1 0 &amp;lt;= target&amp;lt;= prob.length 如果答案与标准答案的误差在10^-5内，则被视为正确答案。  来源：力扣（LeetCode）第5090题(临时)  链接：https://leetcode-cn.com/problems/toss-strange-coins
 分析：  概率dp 找到两个状态，一个是当前扔了第几个硬币，另一个是有几个正面朝上。  代码： class Solution { public double probabilityOfHeads(double[] prob, int target) { int n = prob.length; // 滚动数组，由于这个dp只要用到前一个状态，所以没必要把所有的硬币情况都写出来。 // dp数组表示当前有i个硬币，j个硬币正面朝上。 double[][] dp = new double[2][target+2]; dp[0][0] = 1; // 当前没有硬币，0个硬币朝上的概率为100% for (int ii = 1; ii &amp;lt;= n; ii++) { int i = ii &amp;amp; 1; // 如果最后一位是1，那么i=1，如果最后一位是0，那么i=0 int pi = i ^ 1; // 如果i=1，那么异或1得0，如果i=0，那么异或1得1 for (int j = 0; j &amp;lt;= target; j++) dp[i][j] = 0; // 由于滚动数组，所以要把之前的清空。 for (int j = 0; j &amp;lt;= target; j++) { dp[i][j] += dp[pi][j] * (1 - prob[ii-1]); // 当前有i个硬币，如果第i个硬币扔的是反面，那么i-1个硬币必须要有j个是正面。 dp[i][j+1] += dp[pi][j] * prob[ii-1]; // 如果扔的是正面，那么i-1个硬币必须要有j-1个时正面。 } } // n是奇数那么索引就是1，如果n是偶数的话，那么它答案的索引就是0 return dp[n&amp;amp;1][target]; } }  </description>
    </item>
    
    <item>
      <title>填充书架</title>
      <link>https://ripple-zjw.github.io/2019/%E5%A1%AB%E5%85%85%E4%B9%A6%E6%9E%B6/</link>
      <pubDate>Wed, 23 Oct 2019 19:34:22 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%A1%AB%E5%85%85%E4%B9%A6%E6%9E%B6/</guid>
      <description>题目：填充书架  附近的家居城促销，你买回了一直心仪的可调节书架，打算把自己的书都整理到新的书架上。 你把要摆放的书books都整理好，叠成一摞：从上往下，第i本书的厚度为books[i][0]，高度为books[i][1]。 按顺序将这些书摆放到总宽度为shelf_width的书架上。 先选几本书放在书架上（它们的厚度之和小于等于书架的宽度 shelf_width），然后再建一层书架。重复这个过程，直到把所有的书都放在书架上。 需要注意的是，在上述过程的每个步骤中，摆放书的顺序与你整理好的顺序相同。 例如，如果这里有 5 本书，那么可能的一种摆放情况是：第一和第二本书放在第一层书架上，第三本书放在第二层书架上，第四和第五本书放在最后一层书架上。 每一层所摆放的书的最大高度就是这一层书架的层高，书架整体的高度为各层高之和。 以这种方式布置书架，返回书架整体可能的最小高度。  示例： 输入：books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelf_width = 4 输出：6 解释： 3 层书架的高度和为 1 + 3 + 2 = 6 。 第 2 本书不必放在第一层书架上。  提示：
 1 &amp;lt;= books.length &amp;lt;= 1000 1 &amp;lt;= books[i][0] &amp;lt;= shelf_width &amp;lt;= 1000 1 &amp;lt;= books[i][1] &amp;lt;= 1000  来源：力扣（LeetCode）第1105题  链接：https://leetcode-cn.com/problems/filling-bookcase-shelves
 分析：  动态规划题 这道题的状态很简单，却很难想到。 我们设i为到第i本书为止的最优情况。 如果i之前都已是最优情况，那么第i种情况怎么算呢？ 首先直接换行，那么就是i-1时的最优情况加上这本书的高度。 第二种，我们把第i-1本书和第i本书放在一起，那么就是第i本书和第i-1本最高的那本加上i-2时的最优情况。 以此类推，直到把所有书都放在同一行，或者宽度不够了，下一本书放不进去了。  代码： class Solution { public int minHeightShelves(int[][] books, int shelf_width) { int m = books.</description>
    </item>
    
    <item>
      <title>掷骰子模拟</title>
      <link>https://ripple-zjw.github.io/2019/%E6%8E%B7%E9%AA%B0%E5%AD%90%E6%A8%A1%E6%8B%9F/</link>
      <pubDate>Wed, 23 Oct 2019 19:26:07 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%8E%B7%E9%AA%B0%E5%AD%90%E6%A8%A1%E6%8B%9F/</guid>
      <description>题目：掷骰子模拟  有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。 不过我们在使用它时有个约束，就是使得投掷骰子时，连续 掷出数字i的次数不能超过rollMax[i]（i从 1 开始编号）。  现在，给你一个整数数组rollMax和一个整数n，请你来计算掷n次骰子可得到的不同点数序列的数量。
假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 模10^9 + 7之后的结果。
示例 1： 输入：n = 2, rollMax = [1,1,2,2,2,3] 输出：34 解释：我们掷 2 次骰子，如果没有约束的话，共有 6 * 6 = 36 种可能的组合。但是根据 rollMax 数组，数字 1 和 2 最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。因此，最终答案是 36-2 = 34。  示例 2： 输入：n = 2, rollMax = [1,1,1,1,1,1] 输出：30 示例 3： 输入：n = 3, rollMax = [1,1,1,2,2,3] 输出：181  提示：  1 &amp;lt;= n &amp;lt;= 5000 rollMax.</description>
    </item>
    
    <item>
      <title>一和零</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%80%E5%92%8C%E9%9B%B6/</link>
      <pubDate>Wed, 23 Oct 2019 19:21:28 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%80%E5%92%8C%E9%9B%B6/</guid>
      <description>题目： 一和零  在计算机界中，我们总是追求用有限的资源获取最大的收益。 现在，假设你分别支配着 m 个0和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。 你的任务是使用给定的m个0和n 个1，找到能拼出存在于数组中的字符串的最大数量。每个0和1至多被使用一次。  注意:  给定0和1的数量都不会超过100。 给定字符串数组的长度不会超过600。  示例 1: 输入: Array = {&amp;quot;10&amp;quot;, &amp;quot;0001&amp;quot;, &amp;quot;111001&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;},m = 5, n = 3 输出: 4 解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 &amp;quot;10&amp;quot;,&amp;quot;0001&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot; 。  示例 2: 输入: Array = {&amp;quot;10&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;}, m = 1, n = 1 输出: 2 解释: 你可以拼出 &amp;quot;10&amp;quot;，但之后就没有剩余数字了。更好的选择是拼出 &amp;quot;0&amp;quot; 和 &amp;quot;1&amp;quot; 。  来源：力扣（LeetCode）第474题  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>删除与获得点数</title>
      <link>https://ripple-zjw.github.io/2019/%E5%88%A0%E9%99%A4%E4%B8%8E%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0/</link>
      <pubDate>Wed, 23 Oct 2019 19:13:59 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%88%A0%E9%99%A4%E4%B8%8E%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0/</guid>
      <description>删除与获得点数  给定一个整数数组nums，你可以对它进行一些操作。 每次操作中，选择任意一个nums[i]，删除它并获得nums[i]的点数。之后，你必须删除每个等于nums[i] - 1或nums[i] + 1的元素。 开始你拥有0个点数。返回你能通过这些操作获得的最大点数。  示例 1: 输入: nums = [3, 4, 2] 输出: 6 解释: 删除 4 来获得 4 个点数，因此 3 也被删除。 之后，删除 2 来获得 2 个点数。总共获得 6 个点数。  示例 2: 输入: nums = [2, 2, 3, 3, 3, 4] 输出: 9 解释: 删除 3 来获得 3 个点数，接着要删除两个 2 和 4 。 之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。 总共获得 9 个点数。  注意:  nums的长度最大为20000。 每个整数nums[i]的大小都在[1, 10000]范围内。  来源：力扣（LeetCode）第740题  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>石子游戏II</title>
      <link>https://ripple-zjw.github.io/2019/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8Fii/</link>
      <pubDate>Wed, 23 Oct 2019 19:06:38 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8Fii/</guid>
      <description>题目：石子游戏 II  亚历克斯和李继续他们的石子游戏。许多堆石子排成一行，每堆都有正整数颗石子piles[i]。游戏以谁手中的石子最多来决出胜负。 亚历克斯和李轮流进行，亚历克斯先开始。最初，M = 1。 在每个玩家的回合中，该玩家可以拿走剩下的前X堆的所有石子，其中1 &amp;lt;= X &amp;lt;= 2M。然后，令M = max(M, X)。 游戏一直持续到所有石子都被拿走。 假设亚历克斯和李都发挥出最佳水平，返回亚历克斯可以得到的最大数量的石头。  示例： 输入：piles = [2,7,9,4,4] 输出：10 解释： 如果亚历克斯在开始时拿走一堆石子，李拿走两堆，接着亚历克斯也拿走两堆。在这种情况下，亚历克斯可以拿到 2 + 4 + 4 = 10 颗石子。 如果亚历克斯在开始时拿走两堆石子，那么李就可以拿走剩下全部三堆石子。在这种情况下，亚历克斯可以拿到 2 + 7 = 9 颗石子。 所以我们返回更大的 10。  提示：  1 &amp;lt;= piles.length &amp;lt;= 100 1 &amp;lt;= piles[i] &amp;lt;= 10 ^ 4  来源：力扣（LeetCode）第1140题  链接：https://leetcode-cn.com/problems/stone-game-ii
 分析：  这道题可以采用递归加记忆化搜索的方式进行。 我们需要穷举出所有的状态。 由于重复计算的地方太多，所以使用记忆化搜索，也可以说使用了动态规划。  代码： class Solution { int len; int[] sum;int[][] dp; public int stoneGameII(int[] piles) { dp = new int[150][150]; // dp数组用来存放算过的值。 len = piles.</description>
    </item>
    
    <item>
      <title>叶值的最小代价生成树</title>
      <link>https://ripple-zjw.github.io/2019/%E5%8F%B6%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7%E7%94%9F%E6%88%90%E6%A0%91/</link>
      <pubDate>Wed, 23 Oct 2019 19:00:35 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%8F%B6%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7%E7%94%9F%E6%88%90%E6%A0%91/</guid>
      <description>题目：叶值的最小代价生成树  给你一个正整数数组arr，考虑所有满足以下条件的二叉树：  每个节点都有 0 个或是 2 个子节点。 数组arr中的值与树的中序遍历中每个叶节点的值一一对应。（知识回顾：如果一个节点有 0 个子节点，那么该节点为叶节点。） 每个非叶节点的值等于其左子树和右子树中叶节点的最大值的乘积。 在所有这样的二叉树中，返回每个非叶节点的值的最小可能总和。这个和的值是一个32 位整数。   示例： 输入：arr = [6,2,4] 输出：32 解释： 有两种可能的树，第一种的非叶节点的总和为 36，第二种非叶节点的总和为 32。 24 24 / \ / \ 12 4 6 8 / \ / \ 6 2 2 4  提示：  2 &amp;lt;= arr.length &amp;lt;= 40 1 &amp;lt;= arr[i] &amp;lt;= 15 答案保证是一个 32 位带符号整数，即小于2^31。  来源：力扣（LeetCode）第1130题  链接：https://leetcode-cn.com/problems/minimum-cost-tree-from-leaf-values
 分析：  这道题有两种解法，一种是动态规划，另一种是使用单调栈。  代码： 动态规划：  我们发现数组中的数可以划分为两部分，一半是左子树，一半是右子树，根节点就是左边最大和右边最大的乘积。 而左右子树里面的值就是当数组中的数为左子树的叶子节点时的情况，右边一样。 直到数组中的数只有2个时，答案就是左边右边相乘。 因此我们可以这么看，如果2个数后面又加了一个数，那么我们可以以01为一个节点再和2划分,也可以0一个节点和12划分。 树的左右两边至少有1个叶子结点。 如果有四个数，有0 123, 01 23, 012 3,同时3个数又有之前的情况。 因此我可以这样找状态，i代表起始点,j代表结束位置。如果我想知道4个数的答案，我就把上面划分的情况算出来，每一个情况还要加上左边和右边的最大值的乘积，作为根节点。 于是乎我就是要穷举所有状态。</description>
    </item>
    
    <item>
      <title>统计元音字母序列的数目</title>
      <link>https://ripple-zjw.github.io/2019/%E7%BB%9F%E8%AE%A1%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D%E5%BA%8F%E5%88%97%E7%9A%84%E6%95%B0%E7%9B%AE/</link>
      <pubDate>Wed, 23 Oct 2019 18:58:05 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%BB%9F%E8%AE%A1%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D%E5%BA%8F%E5%88%97%E7%9A%84%E6%95%B0%E7%9B%AE/</guid>
      <description>题目：统计元音字母序列的数目  给你一个整数n，请你帮忙统计一下我们可以按下述规则形成多少个长度为n的字符串 字符串中的每个字符都应当是小写元音字母（&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, &#39;u&#39;） 每个元音&#39;a&#39;后面都只能跟着&#39;e&#39; 每个元音&#39;e&#39;后面只能跟着&#39;a&#39;或者是&#39;i&#39; 每个元音&#39;i&#39;后面不能再跟着另一个&#39;i&#39; 每个元音&#39;o&#39;后面只能跟着&#39;i&#39;或者是&#39;u&#39; 每个元音&#39;u&#39;后面只能跟着&#39;a&#39; 由于答案可能会很大，所以请你返回 模10^9 + 7之后的结果。  示例 1： 输入：n = 1 输出：5 解释：所有可能的字符串分别是：&amp;quot;a&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;i&amp;quot; , &amp;quot;o&amp;quot; 和 &amp;quot;u&amp;quot;。  示例 2： 输入：n = 2 输出：10 解释：所有可能的字符串分别是：&amp;quot;ae&amp;quot;, &amp;quot;ea&amp;quot;, &amp;quot;ei&amp;quot;, &amp;quot;ia&amp;quot;, &amp;quot;ie&amp;quot;, &amp;quot;io&amp;quot;, &amp;quot;iu&amp;quot;, &amp;quot;oi&amp;quot;, &amp;quot;ou&amp;quot; 和 &amp;quot;ua&amp;quot;。  示例 3： 输入：n = 5 输出：68  提示：  1 &amp;lt;= n &amp;lt;= 2 * 10^4  来源：力扣（LeetCode）第5216题(临时)  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>大礼包</title>
      <link>https://ripple-zjw.github.io/2019/%E5%A4%A7%E7%A4%BC%E5%8C%85/</link>
      <pubDate>Tue, 01 Oct 2019 21:49:17 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%A4%A7%E7%A4%BC%E5%8C%85/</guid>
      <description>题目：大礼包  在LeetCode商店中， 有许多在售的物品。 然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。 现给定每个物品的价格，每个大礼包包含物品的清单，以及待购物品清单。请输出确切完成待购清单的最低花费。 每个大礼包的由一个数组中的一组数据描述，最后一个数字代表大礼包的价格，其他数字分别表示内含的其他种类物品的数量。 任意大礼包可无限次购买。  示例 1: 输入: [2,5], [[3,0,5],[1,2,10]], [3,2] 输出: 14 解释: 有A和B两种物品，价格分别为¥2和¥5。 大礼包1，你可以以¥5的价格购买3A和0B。 大礼包2， 你可以以¥10的价格购买1A和2B。 你需要购买3个A和2个B， 所以你付了¥10购买了1A和2B（大礼包2），以及¥4购买2A。  示例 2: 输入: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1] 输出: 11 解释: A，B，C的价格分别为¥2，¥3，¥4. 你可以用¥4购买1A和1B，也可以用¥9购买2A，2B和1C。 你需要买1A，2B和1C，所以你付了¥4买了1A和1B（大礼包1），以及¥3购买1B， ¥4购买1C。 你不可以购买超出待购清单的物品，尽管购买大礼包2更加便宜。  说明:  最多6种物品， 100种大礼包。 每种物品，你最多只需要购买6个。 你不可以购买超出待购清单的物品，即使更便宜。  来源：力扣（LeetCode）第638题  链接：https://leetcode-cn.com/problems/shopping-offers
 分析：  动态规划解法，常规解法需要使用六维数组，实在太麻烦，而且每次的维度还不一样。 使用状压dp的思想，把六维数组归为1维。 因为每一维的长度是0-6，所以我们把这7个数变为一个七进制的数字，但是把它变为10进制存在一个一维数组中。 比如111就是57，它表示a,b,c各有1个。如果是4个1，那就是a,b,c,d各有1个，然后它也有对应的十进制数。 因此，我们把needs中的数看成是一个七进制数，然后把它以十进制表示出来。 比如need如果是121，那么结果是64。那么我们就开辟一个65个的数组。最后把dp[64]返回就是最终答案了。  代码： class Solution { public int shoppingOffers(List&amp;lt;Integer&amp;gt; price, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; special, List&amp;lt;Integer&amp;gt; needs) { int[] Decinal = {1, 7, 49, 343, 2401, 16807, 117649}; // 7的一次方，7的二次方.</description>
    </item>
    
    <item>
      <title>穿过迷宫的最少移动次数</title>
      <link>https://ripple-zjw.github.io/2019/%E7%A9%BF%E8%BF%87%E8%BF%B7%E5%AE%AB%E7%9A%84%E6%9C%80%E5%B0%91%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0/</link>
      <pubDate>Tue, 01 Oct 2019 21:43:48 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%A9%BF%E8%BF%87%E8%BF%B7%E5%AE%AB%E7%9A%84%E6%9C%80%E5%B0%91%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0/</guid>
      <description>题目：穿过迷宫的最少移动次数  你还记得那条风靡全球的贪吃蛇吗？ 我们在一个n*n的网格上构建了新的迷宫地图，蛇的长度为 2，也就是说它会占去两个单元格。蛇会从左上角(0, 0)和(0, 1)开始移动。我们用 0 表示空单元格，用 1 表示障碍物。蛇需要移动到迷宫的右下角(n-1, n-2)和(n-1, n-1)。 每次移动，蛇可以这样走：  如果没有障碍，则向右移动一个单元格。并仍然保持身体的水平／竖直状态。 如果没有障碍，则向下移动一个单元格。并仍然保持身体的水平／竖直状态。 如果它处于水平状态并且其下面的两个单元都是空的，就顺时针旋转 90 度。蛇从（(r, c)、(r, c+1)）移动到 （(r, c)、(r+1, c)）。  如果它处于竖直状态并且其右面的两个单元都是空的，就逆时针旋转 90 度。蛇从（(r, c)、(r+1, c)）移动到（(r, c)、(r, c+1)）。   返回蛇抵达目的地所需的最少移动次数。 如果无法到达目的地，请返回-1。  示例 1： 输入：grid = [[0,0,0,0,0,1], [1,1,0,0,1,0], [0,0,0,0,1,1], [0,0,1,0,1,0], [0,1,1,0,0,0], [0,1,1,0,0,0]] 输出：11 解释： 一种可能的解决方案是 [右, 右, 顺时针旋转, 右, 下, 下, 下, 下, 逆时针旋转, 右, 下]。  示例 2： 输入：grid = [[0,0,1,1,1,1], [0,0,0,0,1,1], [1,1,0,0,0,1], [1,1,1,0,0,1], [1,1,1,0,0,1], [1,1,1,0,0,0]] 输出：9  提示：  2 &amp;lt;= n &amp;lt;= 100 0 &amp;lt;= grid[i][j] &amp;lt;= 1 蛇保证从空单元格开始出发。  来源：力扣（LeetCode）第5208题(临时)  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>买卖股票的最佳时机含手续费</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/</link>
      <pubDate>Tue, 01 Oct 2019 21:42:37 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/</guid>
      <description>题目：买卖股票的最佳时机含手续费  给定一个整数数组prices，其中第i个元素代表了第i天的股票价格 ；非负整数fee代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。  示例 1: 输入: prices = [1, 3, 2, 8, 4, 9], fee = 2 输出: 8 解释: 能够达到的最大利润: 在此处买入 prices[0] = 1 在此处卖出 prices[3] = 8 在此处买入 prices[4] = 4 在此处卖出 prices[5] = 9 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.  注意:  0 &amp;lt; prices.length &amp;lt;= 50000. 0 &amp;lt; prices[i] &amp;lt; 50000. 0 &amp;lt;= fee &amp;lt; 50000.</description>
    </item>
    
    <item>
      <title>两个字符串的最小ASCII删除和</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8Fascii%E5%88%A0%E9%99%A4%E5%92%8C/</link>
      <pubDate>Tue, 01 Oct 2019 21:36:41 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8Fascii%E5%88%A0%E9%99%A4%E5%92%8C/</guid>
      <description>题目：两个字符串的最小ASCII删除和  给定两个字符串s1,s2，找到使两个字符串相等所需删除字符的ASCII值的最小和。  示例 1: 输入: s1 = &amp;quot;sea&amp;quot;, s2 = &amp;quot;eat&amp;quot; 输出: 231 解释: 在 &amp;quot;sea&amp;quot; 中删除 &amp;quot;s&amp;quot; 并将 &amp;quot;s&amp;quot; 的值(115)加入总和。 在 &amp;quot;eat&amp;quot; 中删除 &amp;quot;t&amp;quot; 并将 116 加入总和。 结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。  示例 2: 输入: s1 = &amp;quot;delete&amp;quot;, s2 = &amp;quot;leet&amp;quot; 输出: 403 解释: 在 &amp;quot;delete&amp;quot; 中删除 &amp;quot;dee&amp;quot; 字符串变成 &amp;quot;let&amp;quot;， 将 100[d]+101[e]+101[e] 加入总和。在 &amp;quot;leet&amp;quot; 中删除 &amp;quot;e&amp;quot; 将 101[e] 加入总和。 结束时，两个字符串都等于 &amp;quot;let&amp;quot;，结果即为 100+101+101+101 = 403 。 如果改为将两个字符串转换为 &amp;quot;lee&amp;quot; 或 &amp;quot;eet&amp;quot;，我们会得到 433 或 417 的结果，比答案更大。  注意:  0 &amp;lt; s1.</description>
    </item>
    
    <item>
      <title>不同的二叉搜索树II</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91ii/</link>
      <pubDate>Tue, 01 Oct 2019 21:34:34 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91ii/</guid>
      <description>题目：不同的二叉搜索树 II  给定一个整数n，生成所有由1...n为节点所组成的二叉搜索树。  示例: 输入: 3 输出: [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ] 解释: 以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3  来源：力扣（LeetCode）第95题  链接：https://leetcode-cn.com/problems/unique-binary-search-trees-ii
 分析：  可以使用递归，但我怕超时就没写。 但是几乎所有的递归都可以转换为动态规划，所以这题用dp求解。 思路和前面找个数一样，状态都是第n个数的内容，选择是谁为根节点。 不一样的是状态转移方程稍稍有点复杂，我在代码中说明。  代码： /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public List&amp;lt;TreeNode&amp;gt; generateTrees(int n) { List&amp;lt;TreeNode&amp;gt;[] dp = new ArrayList[n+1]; dp[0] = new ArrayList(); // 如果left或right为0，就会出现空指针异常。 if (n == 0) return dp[0]; dp[0].</description>
    </item>
    
    <item>
      <title>石子游戏</title>
      <link>https://ripple-zjw.github.io/2019/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/</link>
      <pubDate>Tue, 01 Oct 2019 21:32:58 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/</guid>
      <description>题目：石子游戏  亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子piles[i]。 游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。 亚历克斯和李轮流进行，亚历克斯先开始。每回合，玩家从行的开始或结束处取走整堆石头。这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。 假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回true，当李赢得比赛时返回false。  示例： 输入：[5,3,4,5] 输出：true 解释： 亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。 假设他取了前 5 颗，这一行就变成了 [3,4,5] 。 如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。 如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。 这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。  提示：  2 &amp;lt;= piles.length &amp;lt;= 500 piles.length 是偶数。 1 &amp;lt;= piles[i] &amp;lt;= 500 sum(piles)是奇数。  来源：力扣（LeetCode）第877题  链接：https://leetcode-cn.com/problems/stone-game
 分析：  这是一道典型的动态规划题。 要做出动态规划问题，首先要找到问题的状态和选择。 以这道题为例，状态有三种，分别是开始位置索引i，结束位置索引j，还有在i到j这段位置时，先手的值和后手的值。 举个例子，i = 0, j = 0时，表明在第一个索引0时先手明显是piles[0]，而后手没有东西，所以是0。 说完状态再来看选择，根据题意，选择就是你可以从开始位置i拿，也可以从结束位置j拿。 然后是状态转移方程，首先每一个i和j所对应的位置都有先后手两种情况，如果我选择拿了i的值，那么剩下留给另一个人的元素就是i + 1 到 j,而i + 1 到 j是另一个人先手拿的(i+1,j先手就是i,j的后手，因为一人一次)，所以你拿的是i+1, j的后手。 同理如果你拿的是右边的j，那么剩下的就是i, j - 1的后手。 因此状态转移方程就是：max(piles[i] + dp[i+1][j][1], piles[j] + dp[i][j-1][1])。dp是一个三维数组，前两个表示的是i,j位置索引，而1表示的是后手情况，那么0表示的是先手情况。(不一定是0,1也可以是别的，无所谓) 最后我要的结果就是从0到piles长度的下标，即dp[0][piles.</description>
    </item>
    
    <item>
      <title>比特位计数</title>
      <link>https://ripple-zjw.github.io/2019/%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/</link>
      <pubDate>Sat, 21 Sep 2019 16:04:38 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/</guid>
      <description> 题目：比特位计数  给定一个非负整数num。对于0 ≤ i ≤ num 范围中的每个数字i，计算其二进制数中的1 的数目并将它们作为数组返回。  示例 1: 输入: 2 输出: [0,1,1]  示例 2: 输入: 5 输出: [0,1,1,2,1,2]  进阶:  给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？ 要求算法的空间复杂度为O(n)。 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如C++中的__builtin_popcount）来执行此操作。  来源：力扣（LeetCode）第338题  链接：https://leetcode-cn.com/problems/counting-bits
 分析：  由于偶数的二进制数最后一位是0，所以如果一个偶数做&amp;gt;&amp;gt;1运算那么它的1的个数不变。同理如果一个奇数右移一位，1的个数减1。 因此如果1有1个1，那么2也有1个1,3就有2个1。(正推的话做左移运算),如果2有1个1的话，那么4也是1个1,5就是2个1。 所以有了状态转换公式dp[2*i] = dp[i] dp[2*i+1] = dp[i] + 1  代码： class Solution { public int[] countBits(int num) { int[] dp = new int[num + 1]; for (int i = 0; i &amp;lt;= num / 2; i++) { dp[i&amp;lt;&amp;lt;1] = dp[i]; if ((i&amp;lt;&amp;lt;1) + 1 &amp;lt;= num) dp[(i&amp;lt;&amp;lt;1)+1] = dp[i] + 1; } return dp; } }  复杂度分析：  时间复杂度：O(n) n 为num / 2 空间复杂度：O(n) n 为num  </description>
    </item>
    
    <item>
      <title>为运算表达式设计优先级</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7/</link>
      <pubDate>Tue, 10 Sep 2019 22:59:46 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7/</guid>
      <description>题目：为运算表达式设计优先级  给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含+,-以及*。  示例 1: 输入: &amp;quot;2-1-1&amp;quot; 输出: [0, 2] 解释: ((2-1)-1) = 0 (2-(1-1)) = 2  示例 2: 输入: &amp;quot;2*3-4*5&amp;quot; 输出: [-34, -14, -10, -10, 10] 解释: (2*(3-(4*5))) = -34 ((2*3)-(4*5)) = -14 ((2*(3-4))*5) = -10 (2*((3-4)*5)) = -10 (((2*3)-4)*5) = 10  来源：力扣（LeetCode）第241题  链接：https://leetcode-cn.com/problems/different-ways-to-add-parentheses
 ## 分析： - 动态规划+分治算法。 - 当只有一个运算符时，只有一种情况，当有两个运算符时有两种情况，以此类推。 - 当有三个运算符时，假设第一个运算符优先级最高，然后剩下三个数有两种情况，将两种情况与其相加，得到答案。接着判断第二个运算符优先级最低时，依次类推。
代码： from functools import lru_cache # lru缓存淘汰算法。 class Solution: @lru_cache(None) def diffWaysToCompute(self, input: str) -&amp;gt; List[int]: if input.</description>
    </item>
    
    <item>
      <title>使用最小花费爬楼梯</title>
      <link>https://ripple-zjw.github.io/2019/%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</link>
      <pubDate>Tue, 10 Sep 2019 22:45:45 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</guid>
      <description>题目：使用最小花费爬楼梯  数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值cost[i](索引从0开始)。 每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。 您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。  示例 1: 输入: cost = [10, 15, 20] 输出: 15 解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。  示例 2: 输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 输出: 6 解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。  注意：  cost的长度将会在[2, 1000]。 每一个cost[i] 将会是一个Integer类型，范围为[0, 999]。  来源：力扣（LeetCode）第746题  链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs
 分析：  可以使用递归或者动态规划来解这道题。 思路是如果要跳到第i个位置，那么就要先跳到i-1或者是i-2个位置。  代码：  动态规划： python
class Solution: def minCostClimbingStairs(self, cost: List[int]) -&amp;gt; int: for i in range(2, len(cost)): cost[i] = min(cost[i-1], cost[i-2]) + cost[i] # 你想要跳到第i个位置，就要跳先跳到i-1或i-2个位置。 return min(cost[-1], cost[-2]) # 决定最后是从倒数第一个位置跳上去，还是倒数第二个位置跳上去。  java</description>
    </item>
    
    <item>
      <title>杨辉三角</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</link>
      <pubDate>Fri, 30 Aug 2019 19:22:10 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</guid>
      <description> 题目：杨辉三角  给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。  示例: 输入: 5 输出: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ]  来源：力扣（LeetCode）第118题  链接：https://leetcode-cn.com/problems/pascals-triangle
 分析： 这题可以使用动态规划，是一道非常简单的题目。我们可以把所要求的值看成是前一行的两个值的相加，而且这两个值的位置是有规律的。
思路：  两个循环，第一遍遍历所有的层。 第二遍遍历每一层中的值。 每一层中的值只有第一个和最后一个是1，其他的值都是前一行的前一个位置和现在的位置的和。  代码： class Solution: def generate(self, numRows: int) -&amp;gt; List[List[int]]: ans = [] for i in range(numRows): numRow = [1 for _ in range(i + 1)] for j in range(1, i): numRow[j] = ans[i-1][j-1] + ans[i-1][j] ans.append(numRow) return ans  复杂度分析：  时间复杂度：O(n^2^) n 为numRows 空间复杂度：O(n^2^)  </description>
    </item>
    
    <item>
      <title>接雨水</title>
      <link>https://ripple-zjw.github.io/2019/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</link>
      <pubDate>Fri, 23 Aug 2019 12:55:03 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</guid>
      <description>题目：接雨水  给定n个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。   上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。感谢 Marcos 贡献此图。  示例: 输入: [0,1,0,2,1,0,1,3,2,1,2,1] 输出: 6  来源：力扣（LeetCode）第42题  链接：https://leetcode-cn.com/problems/trapping-rain-water
 分析： 方法太多了，一道极难题，从暴力法，到动态规划，再到单调栈，再到双指针。方法非常多，也很难理解，暴力法最好理解，dp和双指针稍难，我这里讲单调栈的方法。
思路：  维护一个单调递减栈。 当有值比栈顶元素大的时候做这么几件事情：  先出栈一个元素并保存到top中。 然后判断stack是否是空，如果是空的话，说明出栈的左边没有东西，所以无法装雨水。(一定要两边都要有东西并且两边的墙比出栈的墙要长，这样才能装雨水) 算出当前元素与栈顶元素中间的距离dis(注意现在是出栈之后的栈顶元素) 算出当前元素与栈顶元素中哪个值最小，并将小的那个值与出栈的那个元素相减，得到floor_cnt 为什么要叫floor_cnt呢，因为将floor_cnt与dis(也就是两栋大墙之间的距离)相乘，你就能得到在这两栋墙之间一层的雨水数量。 将它们加到ans答案中。例如：如果两栋墙最小的那栋是3，那么就会有3层，每一层的雨水数量可能是不一样的，所以要算3遍。 最后返回ans得到答案。  如果值比栈顶元素小的话就入栈就行了，这样就能维护单调递减栈。(注意栈中存的是数组下标，为了算起来方便。)  Talk is cheap,show me the code. class Solution(object): def trap(self, height): stack = [] ans = 0 cur = 0 while cur &amp;lt; len(height): while stack and height[stack[-1]] &amp;lt; height[cur]: top = stack.</description>
    </item>
    
  </channel>
</rss>