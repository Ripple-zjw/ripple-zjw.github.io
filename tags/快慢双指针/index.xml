<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>快慢双指针 on LeaveIt</title>
    <link>https://ripple-zjw.github.io/tags/%E5%BF%AB%E6%85%A2%E5%8F%8C%E6%8C%87%E9%92%88/</link>
    <description>Recent content in 快慢双指针 on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 21 Sep 2019 15:50:29 +0800</lastBuildDate>
    
	<atom:link href="https://ripple-zjw.github.io/tags/%E5%BF%AB%E6%85%A2%E5%8F%8C%E6%8C%87%E9%92%88/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>有序链表转换二叉搜索树</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Sat, 21 Sep 2019 15:50:29 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>题目：有序链表转换二叉搜索树  给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。  示例: 给定的有序链表： [-10, -3, 0, 5, 9], 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5  来源：力扣（LeetCode）第109题  链接：https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree
 分析：  递归 + 快慢双指针  使用快慢指针找出链表的中点。 然后将中点生成树的根。 递归进入左右子树。  模拟遍历中序二叉树  算出链表的长度 把链表一分为二 递归进入链表的左边和右边 同时，在左边递归完后生成父节点 再把递归得到的左右子节点放在父节点的left和right   代码：  递归 + 快慢双指针
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>回文链表</title>
      <link>https://ripple-zjw.github.io/2019/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sat, 21 Sep 2019 15:48:18 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</guid>
      <description>题目：回文链表  请判断一个链表是否为回文链表。  示例 1: 输入: 1-&amp;gt;2 输出: false  示例 2: 输入: 1-&amp;gt;2-&amp;gt;2-&amp;gt;1 输出: true  进阶：  你能否用O(n)时间复杂度和O(1)空间复杂度解决此题？  来源：力扣（LeetCode）第234题  链接：https://leetcode-cn.com/problems/palindrome-linked-list
 分析：  最常见的做法是将链表变为数组，通过数组的随机访问的特性检测回文链表。 第二种更为方便的方法是使用快慢双指针找到链表的中点，然后将前半部分的链表翻转。  代码： /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public boolean isPalindrome(ListNode head) { if (head == null || head.</description>
    </item>
    
    <item>
      <title>环形链表</title>
      <link>https://ripple-zjw.github.io/2019/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sat, 21 Sep 2019 15:45:40 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</guid>
      <description>题目：环形链表  给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数pos 来表示链表尾连接到链表中的位置（索引从0开始）。 如果pos是-1,则在该链表中没有环。  示例 1： 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。  示例 2： 输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。  示例 3： 输入：head = [1], pos = -1 输出：false 解释：链表中没有环。  进阶：  你能用 O(1)（即，常量）内存解决此问题吗？  来源：力扣（LeetCode）第141题  链接：https://leetcode-cn.com/problems/linked-list-cycle
 分析：  这道题可以使用哈希表来做，但这样的空间复杂度是O(n),另一种方法是快慢双指针。 使用两个指针，一个每次走一格，另一个每次走两格。 最后看快指针会不会走到头，或者这两个指针碰到了。  代码： /** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public boolean hasCycle(ListNode head) { if (head == null || head.</description>
    </item>
    
  </channel>
</rss>