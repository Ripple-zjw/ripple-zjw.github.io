<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>博弈类问题 on LeaveIt</title>
    <link>https://ripple-zjw.github.io/tags/%E5%8D%9A%E5%BC%88%E7%B1%BB%E9%97%AE%E9%A2%98/</link>
    <description>Recent content in 博弈类问题 on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 01 Oct 2019 21:32:58 +0800</lastBuildDate>
    
	<atom:link href="https://ripple-zjw.github.io/tags/%E5%8D%9A%E5%BC%88%E7%B1%BB%E9%97%AE%E9%A2%98/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>石子游戏</title>
      <link>https://ripple-zjw.github.io/2019/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/</link>
      <pubDate>Tue, 01 Oct 2019 21:32:58 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/</guid>
      <description>题目：石子游戏  亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子piles[i]。 游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。 亚历克斯和李轮流进行，亚历克斯先开始。每回合，玩家从行的开始或结束处取走整堆石头。这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。 假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回true，当李赢得比赛时返回false。  示例： 输入：[5,3,4,5] 输出：true 解释： 亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。 假设他取了前 5 颗，这一行就变成了 [3,4,5] 。 如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。 如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。 这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。  提示：  2 &amp;lt;= piles.length &amp;lt;= 500 piles.length 是偶数。 1 &amp;lt;= piles[i] &amp;lt;= 500 sum(piles)是奇数。  来源：力扣（LeetCode）第877题  链接：https://leetcode-cn.com/problems/stone-game
 分析：  这是一道典型的动态规划题。 要做出动态规划问题，首先要找到问题的状态和选择。 以这道题为例，状态有三种，分别是开始位置索引i，结束位置索引j，还有在i到j这段位置时，先手的值和后手的值。 举个例子，i = 0, j = 0时，表明在第一个索引0时先手明显是piles[0]，而后手没有东西，所以是0。 说完状态再来看选择，根据题意，选择就是你可以从开始位置i拿，也可以从结束位置j拿。 然后是状态转移方程，首先每一个i和j所对应的位置都有先后手两种情况，如果我选择拿了i的值，那么剩下留给另一个人的元素就是i + 1 到 j,而i + 1 到 j是另一个人先手拿的(i+1,j先手就是i,j的后手，因为一人一次)，所以你拿的是i+1, j的后手。 同理如果你拿的是右边的j，那么剩下的就是i, j - 1的后手。 因此状态转移方程就是：max(piles[i] + dp[i+1][j][1], piles[j] + dp[i][j-1][1])。dp是一个三维数组，前两个表示的是i,j位置索引，而1表示的是后手情况，那么0表示的是先手情况。(不一定是0,1也可以是别的，无所谓) 最后我要的结果就是从0到piles长度的下标，即dp[0][piles.</description>
    </item>
    
  </channel>
</rss>