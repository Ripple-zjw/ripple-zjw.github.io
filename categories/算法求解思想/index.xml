<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法求解思想 on LeaveIt</title>
    <link>https://ripple-zjw.github.io/categories/%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E6%80%9D%E6%83%B3/</link>
    <description>Recent content in 算法求解思想 on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 23 Oct 2019 20:17:40 +0800</lastBuildDate>
    
	<atom:link href="https://ripple-zjw.github.io/categories/%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E6%80%9D%E6%83%B3/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>“马”在棋盘上的概率</title>
      <link>https://ripple-zjw.github.io/2019/%E9%A9%AC%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/</link>
      <pubDate>Wed, 23 Oct 2019 20:17:40 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E9%A9%AC%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/</guid>
      <description>题目：“马”在棋盘上的概率  已知一个NxN的国际象棋棋盘，棋盘的行号和列号都是从 0 开始。即最左上角的格子记为(0, 0)，最右下角的记为(N-1, N-1)。 现有一个 “马”（也译作 “骑士”）位于(r, c)，并打算进行K 次移动。 如下图所示，国际象棋的 “马” 每一步先沿水平或垂直方向移动 2 个格子，然后向与之相垂直的方向再移动 1 个格子，共有 8 个可选的位置。  现在 “马” 每一步都从可选的位置（包括棋盘外部的）中独立随机地选择一个进行移动，直到移动了K次或跳到了棋盘外面。 求移动结束后，“马” 仍留在棋盘上的概率。  示例： 输入: 3, 2, 0, 0 输出: 0.0625 解释: 输入的数据依次为 N, K, r, c 第 1 步时，有且只有 2 种走法令 “马” 可以留在棋盘上（跳到（1,2）或（2,1））。对于以上的两种情况，各自在第2步均有且只有2种走法令 “马” 仍然留在棋盘上。 所以 “马” 在结束后仍在棋盘上的概率为 0.0625。  注意：  N 的取值范围为 [1, 25] K 的取值范围为 [0, 100] 开始时，“马” 总是位于棋盘上  来源：力扣（LeetCode）第688题  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>最长上升子序列</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Wed, 23 Oct 2019 20:15:25 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>题目：最长上升子序列  给定一个无序的整数数组，找到其中最长上升子序列的长度。  示例: 输入: [10,9,2,5,3,7,101,18] 输出: 4 解释: 最长的上升子序列是[2,3,7,101]，它的长度是 4。  说明:  可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为O(n^2)。 进阶: 你能将算法的时间复杂度降低到O(n logn)吗?  来源：力扣（LeetCode）第300题  链接：https://leetcode-cn.com/problems/longest-increasing-subsequence
 分析：  非常好的一道题目 可以使用动态规划来解决。 除了最常规的一种方法外还有另一种动态规划的方法，使用二分查找的思想。 具体可以看看搜索插入位置(LeetCode第35题) 动态规划：  设1个状态表示到这个数为止，最长上升子序列是多少。 然后遍历数组，当遍历到第i个状态时，查看在dp中到第i个数为止已经有多长了，那么你只要在右边找到比当前数大的值，然后在它的dp数组下加上1。 最后找到dp数组中最大的值，就是答案。  dp + 二分查找：  我们遍历数组，将每个数放进dp数组中。 由于dp数组是单调递增的，所以可以使用二分查找找到插入的位置。 有两种情况，如果找到了这个值，那么直接覆盖就行了，如果没找到这个值，那么将比它大的最小的值覆盖。其实就是插入位置。   代码：  dp
class Solution { public int lengthOfLIS(int[] nums) { int len = nums.length; int[] dp = new int[len]; Arrays.fill(dp, 1); for (int i = 0; i &amp;lt; len; i++) { for (int j = i + 1; j &amp;lt; len; j++) { if (nums[i] &amp;lt; nums[j]) dp[j] = Math.</description>
    </item>
    
    <item>
      <title>最长的斐波那契子序列的长度</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Wed, 23 Oct 2019 20:09:39 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/</guid>
      <description>题目：最长的斐波那契子序列的长度  如果序列X_1, X_2, ..., X_n满足下列条件，就说它是斐波那契式的： n &amp;gt;= 3 对于所有i + 2 &amp;lt;= n，都有X_i + X_{i+1} = X_{i+2} 给定一个严格递增的正整数数组形成序列，找到 A 中最长的斐波那契式的子序列的长度。如果一个不存在，返回0 。 （回想一下，子序列是从原序列A中派生出来的，它从A中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如，[3, 5, 8]是[3, 4, 5, 6, 7, 8]的一个子序列）  示例 1： 输入: [1,2,3,4,5,6,7,8] 输出: 5 解释: 最长的斐波那契式子序列为：[1,2,3,5,8] 。  示例2： 输入: [1,3,7,11,12,14,18] 输出: 3 解释: 最长的斐波那契式子序列有： [1,11,12]，[3,11,14] 以及 [7,11,18] 。  提示：  3 &amp;lt;= A.length &amp;lt;= 1000 1 &amp;lt;= A[0] &amp;lt; A[1] &amp;lt; &amp;hellip; &amp;lt; A[A.length - 1] &amp;lt;= 10^9 （对于以 Java，C，C++，以及C# 的提交，时间限制被减少了 50%）  来源：力扣（LeetCode）第873题  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>最大平均值和的分组</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC%E5%92%8C%E7%9A%84%E5%88%86%E7%BB%84/</link>
      <pubDate>Wed, 23 Oct 2019 20:03:28 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC%E5%92%8C%E7%9A%84%E5%88%86%E7%BB%84/</guid>
      <description>题目： 最大平均值和的分组  我们将给定的数组A分成K个相邻的非空子数组 ，我们的分数由每个子数组内的平均值的总和构成。计算我们所能得到的最大分数是多少。 注意我们必须使用A数组中的每一个数进行分组，并且分数不一定需要是整数。  示例: 输入: A = [9,1,2,3,9] K = 3 输出: 20 解释: A 的最优分组是[9], [1, 2, 3], [9]. 得到的分数是 9 + (1 + 2 + 3) / 3 + 9 = 20. 我们也可以把 A 分成[9, 1], [2], [3, 9]. 这样的分组得到的分数为 5 + 2 + 6 = 13, 但不是最大值.  说明:  1 &amp;lt;= A.length &amp;lt;= 100. 1 &amp;lt;= A[i] &amp;lt;= 10000. 1 &amp;lt;= K &amp;lt;= A.</description>
    </item>
    
    <item>
      <title>分割等和子集</title>
      <link>https://ripple-zjw.github.io/2019/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</link>
      <pubDate>Wed, 23 Oct 2019 19:58:28 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</guid>
      <description> 题目：分割等和子集  给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。  注意:  每个数组中的元素不会超过 100 数组的大小不会超过 200  示例 1: 输入: [1, 5, 11, 5] 输出: true 解释: 数组可以分割成 [1, 5, 5] 和 [11].  示例2: 输入: [1, 2, 3, 5] 输出: false 解释: 数组不能分割成两个元素和相等的子集.  来源：力扣（LeetCode）第416题  链接：https://leetcode-cn.com/problems/partition-equal-subset-sum
 分析：  动态规划题 0-1背包问题  代码： class Solution { public boolean canPartition(int[] nums) { int sum = 0; int len = nums.length; for (int num : nums) sum += num; if ((sum &amp;amp; 1) == 1) return false; // 如果是奇数，不可能分割 sum &amp;gt;&amp;gt;= 1; // 要找的答案是总和的一半。 boolean[][] dp = new boolean[len][sum+1]; // i表示nums中从0到i为止，j表示是否能找到和为j的数。 if (nums[0] &amp;lt;= sum) dp[0][nums[0]] = true; // 第一个数放在j上，其他都是false for (int i = 1; i &amp;lt; len; i++) { for (int j = 0; j &amp;lt;= sum; j++) { if (nums[i] &amp;lt;= j) // 两种选择，一种之前就找到了和为j的数，那么现在还是true。 // 如果之前没有找到和为j的数，那么我加上这次的数，要找前一次j-nums[i]的和能不能找到。 dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]]; else // 如果当前nums[i] 大于j的话，之前看它前一次是什么状态现在还是什么状态。 dp[i][j] = dp[i-1][j]; } } return dp[len-1][sum]; } }  </description>
    </item>
    
    <item>
      <title>分享巧克力</title>
      <link>https://ripple-zjw.github.io/2019/%E5%88%86%E4%BA%AB%E5%B7%A7%E5%85%8B%E5%8A%9B/</link>
      <pubDate>Wed, 23 Oct 2019 19:48:36 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%88%86%E4%BA%AB%E5%B7%A7%E5%85%8B%E5%8A%9B/</guid>
      <description>题目：分享巧克力  你有一大块巧克力，它由一些甜度不完全相同的小块组成。我们用数组sweetness来表示每一小块的甜度。 你打算和K名朋友一起分享这块巧克力，所以你需要将切割K次才能得到K+1块，每一块都由一些 连续的小块组成。 为了表现出你的慷慨，你将会吃掉总甜度最小 的一块，并将其余几块分给你的朋友们。 请找出一个最佳的切割策略，使得你所分得的巧克力总甜度最大，并返回这个 最大总甜度。  示例 1： 输入：sweetness = [1,2,3,4,5,6,7,8,9], K = 5 输出：6 解释：你可以把巧克力分成 [1,2,3], [4,5], [6], [7], [8], [9]。  示例 2： 输入：sweetness = [5,6,7,8,9,1,2,3,4], K = 8 输出：1 解释：只有一种办法可以把巧克力分成 9 块。  示例 3： 输入：sweetness = [1,2,2,1,2,2,1,2,2], K = 2 输出：5 解释：你可以把巧克力分成 [1,2,2], [1,2,2], [1,2,2]。  提示：  0 &amp;lt;= K &amp;lt;sweetness.length&amp;lt;= 10^4 1 &amp;lt;= sweetness[i] &amp;lt;= 10^5  来源：力扣（LeetCode）第5111题(临时)  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>删除子文件夹</title>
      <link>https://ripple-zjw.github.io/2019/%E5%88%A0%E9%99%A4%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9/</link>
      <pubDate>Wed, 23 Oct 2019 19:45:43 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%88%A0%E9%99%A4%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9/</guid>
      <description>题目： 删除子文件夹  你是一位系统管理员，手里有一份文件夹列表 folder，你的任务是要删除该列表中的所有 子文件夹，并以 任意顺序 返回剩下的文件夹。 我们这样定义「子文件夹」： 如果文件夹folder[i]位于另一个文件夹folder[j]下，那么folder[i]就是folder[j]的子文件夹。 文件夹的「路径」是由一个或多个按以下格式串联形成的字符串： /后跟一个或者多个小写英文字母。 例如，/leetcode和/leetcode/problems都是有效的路径，而空字符串和/不是。  示例 1： 输入：folder = [&amp;quot;/a&amp;quot;,&amp;quot;/a/b&amp;quot;,&amp;quot;/c/d&amp;quot;,&amp;quot;/c/d/e&amp;quot;,&amp;quot;/c/f&amp;quot;] 输出：[&amp;quot;/a&amp;quot;,&amp;quot;/c/d&amp;quot;,&amp;quot;/c/f&amp;quot;] 解释：&amp;quot;/a/b/&amp;quot; 是 &amp;quot;/a&amp;quot; 的子文件夹，而 &amp;quot;/c/d/e&amp;quot; 是 &amp;quot;/c/d&amp;quot; 的子文件夹。  示例 2： 输入：folder = [&amp;quot;/a&amp;quot;,&amp;quot;/a/b/c&amp;quot;,&amp;quot;/a/b/d&amp;quot;] 输出：[&amp;quot;/a&amp;quot;] 解释：文件夹 &amp;quot;/a/b/c&amp;quot; 和 &amp;quot;/a/b/d/&amp;quot; 都会被删除，因为它们都是 &amp;quot;/a&amp;quot; 的子文件夹。  示例 3： 输入：folder = [&amp;quot;/a/b/c&amp;quot;,&amp;quot;/a/b/d&amp;quot;,&amp;quot;/a/b/ca&amp;quot;] 输出：[&amp;quot;/a/b/c&amp;quot;,&amp;quot;/a/b/ca&amp;quot;,&amp;quot;/a/b/d&amp;quot;]  提示：  1 &amp;lt;= folder.length&amp;lt;= 4 * 10^4 2 &amp;lt;= folder[i].length &amp;lt;= 100 folder[i]只包含小写字母和 / folder[i]总是以字符/起始 每个文件夹名都是唯一的  来源：力扣（LeetCode）第5231题(临时)  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>抛掷硬币</title>
      <link>https://ripple-zjw.github.io/2019/%E6%8A%9B%E6%8E%B7%E7%A1%AC%E5%B8%81/</link>
      <pubDate>Wed, 23 Oct 2019 19:43:25 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%8A%9B%E6%8E%B7%E7%A1%AC%E5%B8%81/</guid>
      <description> 题目：抛掷硬币  有一些不规则的硬币。在这些硬币中，prob[i]表示第i枚硬币正面朝上的概率。  请对每一枚硬币抛掷一次，然后返回正面朝上的硬币数等于target的概率。
示例 1： 输入：prob = [0.4], target = 1 输出：0.40000  示例 2： 输入：prob = [0.5,0.5,0.5,0.5,0.5], target = 0 输出：0.03125  提示：  1 &amp;lt;= prob.length &amp;lt;= 1000 0 &amp;lt;= prob[i] &amp;lt;= 1 0 &amp;lt;= target&amp;lt;= prob.length 如果答案与标准答案的误差在10^-5内，则被视为正确答案。  来源：力扣（LeetCode）第5090题(临时)  链接：https://leetcode-cn.com/problems/toss-strange-coins
 分析：  概率dp 找到两个状态，一个是当前扔了第几个硬币，另一个是有几个正面朝上。  代码： class Solution { public double probabilityOfHeads(double[] prob, int target) { int n = prob.length; // 滚动数组，由于这个dp只要用到前一个状态，所以没必要把所有的硬币情况都写出来。 // dp数组表示当前有i个硬币，j个硬币正面朝上。 double[][] dp = new double[2][target+2]; dp[0][0] = 1; // 当前没有硬币，0个硬币朝上的概率为100% for (int ii = 1; ii &amp;lt;= n; ii++) { int i = ii &amp;amp; 1; // 如果最后一位是1，那么i=1，如果最后一位是0，那么i=0 int pi = i ^ 1; // 如果i=1，那么异或1得0，如果i=0，那么异或1得1 for (int j = 0; j &amp;lt;= target; j++) dp[i][j] = 0; // 由于滚动数组，所以要把之前的清空。 for (int j = 0; j &amp;lt;= target; j++) { dp[i][j] += dp[pi][j] * (1 - prob[ii-1]); // 当前有i个硬币，如果第i个硬币扔的是反面，那么i-1个硬币必须要有j个是正面。 dp[i][j+1] += dp[pi][j] * prob[ii-1]; // 如果扔的是正面，那么i-1个硬币必须要有j-1个时正面。 } } // n是奇数那么索引就是1，如果n是偶数的话，那么它答案的索引就是0 return dp[n&amp;amp;1][target]; } }  </description>
    </item>
    
    <item>
      <title>安排会议日程</title>
      <link>https://ripple-zjw.github.io/2019/%E5%AE%89%E6%8E%92%E4%BC%9A%E8%AE%AE%E6%97%A5%E7%A8%8B/</link>
      <pubDate>Wed, 23 Oct 2019 19:41:34 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%AE%89%E6%8E%92%E4%BC%9A%E8%AE%AE%E6%97%A5%E7%A8%8B/</guid>
      <description>题目：安排会议日程  你是一名行政助理，手里有两位客户的空闲时间表：slots1 和 slots2，以及会议的预计持续时间duration，请你为他们安排合适的会议时间。 「会议时间」是两位客户都有空参加，并且持续时间能够满足预计时间duration的 最早的时间间隔。 如果没有满足要求的会议时间，就请返回一个 空数组。 「空闲时间」的格式是[start, end]，由开始时间start和结束时间end组成，表示从start开始，到end结束。 题目保证数据有效：同一个人的空闲时间不会出现交叠的情况，也就是说，对于同一个人的两个空闲时间[start1, end1]和[start2, end2]，要么start1 &amp;gt; end2，要么start2 &amp;gt; end1。  示例 1： 输入：slots1 = [[10,50],[60,120],[140,210]], slots2 = [[0,15],[60,70]], duration = 8 输出：[60,68]  示例 2： 输入：slots1 = [[10,50],[60,120],[140,210]], slots2 = [[0,15],[60,70]], duration = 12 输出：[]  提示：  1 &amp;lt;= slots1.length, slots2.length &amp;lt;= 10^4 slots1[i].length, slots2[i].length == 2 slots1[i][0] &amp;lt; slots1[i][1] slots2[i][0] &amp;lt; slots2[i][1] 0 &amp;lt;= slots1[i][j], slots2[i][j] &amp;lt;= 10^9 1 &amp;lt;= duration &amp;lt;= 10^6  来源：力扣（LeetCode）第5089题(临时)  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>等差数列中缺失的数字</title>
      <link>https://ripple-zjw.github.io/2019/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Wed, 23 Oct 2019 19:40:20 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>题目：等差数列中缺失的数字  有一个数组，其中的值符合等差数列的数值规律，也就是说： 在0 &amp;lt;= i &amp;lt; arr.length - 1的前提下，arr[i+1] - arr[i]的值都相等。 我们会从该数组中删除一个既不是第一个也不是最后一个的值，得到一个新的数组arr。 给你这个缺值的数组arr，请你帮忙找出被删除的那个数。  示例 1： 输入：arr = [5,7,11,13] 输出：9 解释：原来的数组是 [5,7,9,11,13]。  示例 2： 输入：arr = [15,13,12] 输出：14 解释：原来的数组是 [15,14,13,12]。  提示：  3 &amp;lt;= arr.length &amp;lt;= 1000 0 &amp;lt;= arr[i] &amp;lt;= 10^5  来源：力扣（LeetCode）第5088题(临时)  链接：https://leetcode-cn.com/problems/missing-number-in-arithmetic-progression
 分析：  我们算出数组中的总值，然后用等差数列求和公式求出原来的总值，相减一下就得到了答案。  代码： class Solution { public int missingNumber(int[] arr) { int sum = 0; for (int a : arr) sum += a; return (arr.</description>
    </item>
    
    <item>
      <title>填充书架</title>
      <link>https://ripple-zjw.github.io/2019/%E5%A1%AB%E5%85%85%E4%B9%A6%E6%9E%B6/</link>
      <pubDate>Wed, 23 Oct 2019 19:34:22 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%A1%AB%E5%85%85%E4%B9%A6%E6%9E%B6/</guid>
      <description>题目：填充书架  附近的家居城促销，你买回了一直心仪的可调节书架，打算把自己的书都整理到新的书架上。 你把要摆放的书books都整理好，叠成一摞：从上往下，第i本书的厚度为books[i][0]，高度为books[i][1]。 按顺序将这些书摆放到总宽度为shelf_width的书架上。 先选几本书放在书架上（它们的厚度之和小于等于书架的宽度 shelf_width），然后再建一层书架。重复这个过程，直到把所有的书都放在书架上。 需要注意的是，在上述过程的每个步骤中，摆放书的顺序与你整理好的顺序相同。 例如，如果这里有 5 本书，那么可能的一种摆放情况是：第一和第二本书放在第一层书架上，第三本书放在第二层书架上，第四和第五本书放在最后一层书架上。 每一层所摆放的书的最大高度就是这一层书架的层高，书架整体的高度为各层高之和。 以这种方式布置书架，返回书架整体可能的最小高度。  示例： 输入：books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelf_width = 4 输出：6 解释： 3 层书架的高度和为 1 + 3 + 2 = 6 。 第 2 本书不必放在第一层书架上。  提示：
 1 &amp;lt;= books.length &amp;lt;= 1000 1 &amp;lt;= books[i][0] &amp;lt;= shelf_width &amp;lt;= 1000 1 &amp;lt;= books[i][1] &amp;lt;= 1000  来源：力扣（LeetCode）第1105题  链接：https://leetcode-cn.com/problems/filling-bookcase-shelves
 分析：  动态规划题 这道题的状态很简单，却很难想到。 我们设i为到第i本书为止的最优情况。 如果i之前都已是最优情况，那么第i种情况怎么算呢？ 首先直接换行，那么就是i-1时的最优情况加上这本书的高度。 第二种，我们把第i-1本书和第i本书放在一起，那么就是第i本书和第i-1本最高的那本加上i-2时的最优情况。 以此类推，直到把所有书都放在同一行，或者宽度不够了，下一本书放不进去了。  代码： class Solution { public int minHeightShelves(int[][] books, int shelf_width) { int m = books.</description>
    </item>
    
    <item>
      <title>掷骰子模拟</title>
      <link>https://ripple-zjw.github.io/2019/%E6%8E%B7%E9%AA%B0%E5%AD%90%E6%A8%A1%E6%8B%9F/</link>
      <pubDate>Wed, 23 Oct 2019 19:26:07 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%8E%B7%E9%AA%B0%E5%AD%90%E6%A8%A1%E6%8B%9F/</guid>
      <description>题目：掷骰子模拟  有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。 不过我们在使用它时有个约束，就是使得投掷骰子时，连续 掷出数字i的次数不能超过rollMax[i]（i从 1 开始编号）。  现在，给你一个整数数组rollMax和一个整数n，请你来计算掷n次骰子可得到的不同点数序列的数量。
假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 模10^9 + 7之后的结果。
示例 1： 输入：n = 2, rollMax = [1,1,2,2,2,3] 输出：34 解释：我们掷 2 次骰子，如果没有约束的话，共有 6 * 6 = 36 种可能的组合。但是根据 rollMax 数组，数字 1 和 2 最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。因此，最终答案是 36-2 = 34。  示例 2： 输入：n = 2, rollMax = [1,1,1,1,1,1] 输出：30 示例 3： 输入：n = 3, rollMax = [1,1,1,2,2,3] 输出：181  提示：  1 &amp;lt;= n &amp;lt;= 5000 rollMax.</description>
    </item>
    
    <item>
      <title>一和零</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%80%E5%92%8C%E9%9B%B6/</link>
      <pubDate>Wed, 23 Oct 2019 19:21:28 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%80%E5%92%8C%E9%9B%B6/</guid>
      <description>题目： 一和零  在计算机界中，我们总是追求用有限的资源获取最大的收益。 现在，假设你分别支配着 m 个0和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。 你的任务是使用给定的m个0和n 个1，找到能拼出存在于数组中的字符串的最大数量。每个0和1至多被使用一次。  注意:  给定0和1的数量都不会超过100。 给定字符串数组的长度不会超过600。  示例 1: 输入: Array = {&amp;quot;10&amp;quot;, &amp;quot;0001&amp;quot;, &amp;quot;111001&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;},m = 5, n = 3 输出: 4 解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 &amp;quot;10&amp;quot;,&amp;quot;0001&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot; 。  示例 2: 输入: Array = {&amp;quot;10&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;}, m = 1, n = 1 输出: 2 解释: 你可以拼出 &amp;quot;10&amp;quot;，但之后就没有剩余数字了。更好的选择是拼出 &amp;quot;0&amp;quot; 和 &amp;quot;1&amp;quot; 。  来源：力扣（LeetCode）第474题  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>删除与获得点数</title>
      <link>https://ripple-zjw.github.io/2019/%E5%88%A0%E9%99%A4%E4%B8%8E%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0/</link>
      <pubDate>Wed, 23 Oct 2019 19:13:59 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%88%A0%E9%99%A4%E4%B8%8E%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0/</guid>
      <description>删除与获得点数  给定一个整数数组nums，你可以对它进行一些操作。 每次操作中，选择任意一个nums[i]，删除它并获得nums[i]的点数。之后，你必须删除每个等于nums[i] - 1或nums[i] + 1的元素。 开始你拥有0个点数。返回你能通过这些操作获得的最大点数。  示例 1: 输入: nums = [3, 4, 2] 输出: 6 解释: 删除 4 来获得 4 个点数，因此 3 也被删除。 之后，删除 2 来获得 2 个点数。总共获得 6 个点数。  示例 2: 输入: nums = [2, 2, 3, 3, 3, 4] 输出: 9 解释: 删除 3 来获得 3 个点数，接着要删除两个 2 和 4 。 之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。 总共获得 9 个点数。  注意:  nums的长度最大为20000。 每个整数nums[i]的大小都在[1, 10000]范围内。  来源：力扣（LeetCode）第740题  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>石子游戏II</title>
      <link>https://ripple-zjw.github.io/2019/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8Fii/</link>
      <pubDate>Wed, 23 Oct 2019 19:06:38 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8Fii/</guid>
      <description>题目：石子游戏 II  亚历克斯和李继续他们的石子游戏。许多堆石子排成一行，每堆都有正整数颗石子piles[i]。游戏以谁手中的石子最多来决出胜负。 亚历克斯和李轮流进行，亚历克斯先开始。最初，M = 1。 在每个玩家的回合中，该玩家可以拿走剩下的前X堆的所有石子，其中1 &amp;lt;= X &amp;lt;= 2M。然后，令M = max(M, X)。 游戏一直持续到所有石子都被拿走。 假设亚历克斯和李都发挥出最佳水平，返回亚历克斯可以得到的最大数量的石头。  示例： 输入：piles = [2,7,9,4,4] 输出：10 解释： 如果亚历克斯在开始时拿走一堆石子，李拿走两堆，接着亚历克斯也拿走两堆。在这种情况下，亚历克斯可以拿到 2 + 4 + 4 = 10 颗石子。 如果亚历克斯在开始时拿走两堆石子，那么李就可以拿走剩下全部三堆石子。在这种情况下，亚历克斯可以拿到 2 + 7 = 9 颗石子。 所以我们返回更大的 10。  提示：  1 &amp;lt;= piles.length &amp;lt;= 100 1 &amp;lt;= piles[i] &amp;lt;= 10 ^ 4  来源：力扣（LeetCode）第1140题  链接：https://leetcode-cn.com/problems/stone-game-ii
 分析：  这道题可以采用递归加记忆化搜索的方式进行。 我们需要穷举出所有的状态。 由于重复计算的地方太多，所以使用记忆化搜索，也可以说使用了动态规划。  代码： class Solution { int len; int[] sum;int[][] dp; public int stoneGameII(int[] piles) { dp = new int[150][150]; // dp数组用来存放算过的值。 len = piles.</description>
    </item>
    
    <item>
      <title>叶值的最小代价生成树</title>
      <link>https://ripple-zjw.github.io/2019/%E5%8F%B6%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7%E7%94%9F%E6%88%90%E6%A0%91/</link>
      <pubDate>Wed, 23 Oct 2019 19:00:35 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%8F%B6%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7%E7%94%9F%E6%88%90%E6%A0%91/</guid>
      <description>题目：叶值的最小代价生成树  给你一个正整数数组arr，考虑所有满足以下条件的二叉树：  每个节点都有 0 个或是 2 个子节点。 数组arr中的值与树的中序遍历中每个叶节点的值一一对应。（知识回顾：如果一个节点有 0 个子节点，那么该节点为叶节点。） 每个非叶节点的值等于其左子树和右子树中叶节点的最大值的乘积。 在所有这样的二叉树中，返回每个非叶节点的值的最小可能总和。这个和的值是一个32 位整数。   示例： 输入：arr = [6,2,4] 输出：32 解释： 有两种可能的树，第一种的非叶节点的总和为 36，第二种非叶节点的总和为 32。 24 24 / \ / \ 12 4 6 8 / \ / \ 6 2 2 4  提示：  2 &amp;lt;= arr.length &amp;lt;= 40 1 &amp;lt;= arr[i] &amp;lt;= 15 答案保证是一个 32 位带符号整数，即小于2^31。  来源：力扣（LeetCode）第1130题  链接：https://leetcode-cn.com/problems/minimum-cost-tree-from-leaf-values
 分析：  这道题有两种解法，一种是动态规划，另一种是使用单调栈。  代码： 动态规划：  我们发现数组中的数可以划分为两部分，一半是左子树，一半是右子树，根节点就是左边最大和右边最大的乘积。 而左右子树里面的值就是当数组中的数为左子树的叶子节点时的情况，右边一样。 直到数组中的数只有2个时，答案就是左边右边相乘。 因此我们可以这么看，如果2个数后面又加了一个数，那么我们可以以01为一个节点再和2划分,也可以0一个节点和12划分。 树的左右两边至少有1个叶子结点。 如果有四个数，有0 123, 01 23, 012 3,同时3个数又有之前的情况。 因此我可以这样找状态，i代表起始点,j代表结束位置。如果我想知道4个数的答案，我就把上面划分的情况算出来，每一个情况还要加上左边和右边的最大值的乘积，作为根节点。 于是乎我就是要穷举所有状态。</description>
    </item>
    
    <item>
      <title>统计元音字母序列的数目</title>
      <link>https://ripple-zjw.github.io/2019/%E7%BB%9F%E8%AE%A1%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D%E5%BA%8F%E5%88%97%E7%9A%84%E6%95%B0%E7%9B%AE/</link>
      <pubDate>Wed, 23 Oct 2019 18:58:05 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%BB%9F%E8%AE%A1%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D%E5%BA%8F%E5%88%97%E7%9A%84%E6%95%B0%E7%9B%AE/</guid>
      <description>题目：统计元音字母序列的数目  给你一个整数n，请你帮忙统计一下我们可以按下述规则形成多少个长度为n的字符串 字符串中的每个字符都应当是小写元音字母（&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, &#39;u&#39;） 每个元音&#39;a&#39;后面都只能跟着&#39;e&#39; 每个元音&#39;e&#39;后面只能跟着&#39;a&#39;或者是&#39;i&#39; 每个元音&#39;i&#39;后面不能再跟着另一个&#39;i&#39; 每个元音&#39;o&#39;后面只能跟着&#39;i&#39;或者是&#39;u&#39; 每个元音&#39;u&#39;后面只能跟着&#39;a&#39; 由于答案可能会很大，所以请你返回 模10^9 + 7之后的结果。  示例 1： 输入：n = 1 输出：5 解释：所有可能的字符串分别是：&amp;quot;a&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;i&amp;quot; , &amp;quot;o&amp;quot; 和 &amp;quot;u&amp;quot;。  示例 2： 输入：n = 2 输出：10 解释：所有可能的字符串分别是：&amp;quot;ae&amp;quot;, &amp;quot;ea&amp;quot;, &amp;quot;ei&amp;quot;, &amp;quot;ia&amp;quot;, &amp;quot;ie&amp;quot;, &amp;quot;io&amp;quot;, &amp;quot;iu&amp;quot;, &amp;quot;oi&amp;quot;, &amp;quot;ou&amp;quot; 和 &amp;quot;ua&amp;quot;。  示例 3： 输入：n = 5 输出：68  提示：  1 &amp;lt;= n &amp;lt;= 2 * 10^4  来源：力扣（LeetCode）第5216题(临时)  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>黄金矿工</title>
      <link>https://ripple-zjw.github.io/2019/%E9%BB%84%E9%87%91%E7%9F%BF%E5%B7%A5/</link>
      <pubDate>Wed, 23 Oct 2019 18:55:10 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E9%BB%84%E9%87%91%E7%9F%BF%E5%B7%A5/</guid>
      <description>题目：黄金矿工  你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为m*n的网格grid进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。 为了使收益最大化，矿工需要按以下规则来开采黄金： 每当矿工进入一个单元，就会收集该单元格中的所有黄金。 矿工每次可以从当前位置向上下左右四个方向走。 每个单元格只能被开采（进入）一次。 不得开采（进入）黄金数目为 0 的单元格。 矿工可以从网格中任意一个有黄金的单元格出发或者是停止。  示例 1： 输入：grid = [[0,6,0],[5,8,7],[0,9,0]] 输出：24 解释： [[0,6,0], [5,8,7], [0,9,0]] 一种收集最多黄金的路线是：9 -&amp;gt; 8 -&amp;gt; 7。  示例 2： 输入：grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]] 输出：28 解释： [[1,0,7], [2,0,6], [3,4,5], [0,3,0], [9,0,20]] 一种收集最多黄金的路线是：1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 5 -&amp;gt; 6 -&amp;gt; 7。  提示：  1 &amp;lt;= grid.length,grid[i].length &amp;lt;= 15 0 &amp;lt;= grid[i][j] &amp;lt;= 100 最多25个单元格中有黄金。  来源：力扣（LeetCode）第5215题(临时)  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>大礼包</title>
      <link>https://ripple-zjw.github.io/2019/%E5%A4%A7%E7%A4%BC%E5%8C%85/</link>
      <pubDate>Tue, 01 Oct 2019 21:49:17 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%A4%A7%E7%A4%BC%E5%8C%85/</guid>
      <description>题目：大礼包  在LeetCode商店中， 有许多在售的物品。 然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。 现给定每个物品的价格，每个大礼包包含物品的清单，以及待购物品清单。请输出确切完成待购清单的最低花费。 每个大礼包的由一个数组中的一组数据描述，最后一个数字代表大礼包的价格，其他数字分别表示内含的其他种类物品的数量。 任意大礼包可无限次购买。  示例 1: 输入: [2,5], [[3,0,5],[1,2,10]], [3,2] 输出: 14 解释: 有A和B两种物品，价格分别为¥2和¥5。 大礼包1，你可以以¥5的价格购买3A和0B。 大礼包2， 你可以以¥10的价格购买1A和2B。 你需要购买3个A和2个B， 所以你付了¥10购买了1A和2B（大礼包2），以及¥4购买2A。  示例 2: 输入: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1] 输出: 11 解释: A，B，C的价格分别为¥2，¥3，¥4. 你可以用¥4购买1A和1B，也可以用¥9购买2A，2B和1C。 你需要买1A，2B和1C，所以你付了¥4买了1A和1B（大礼包1），以及¥3购买1B， ¥4购买1C。 你不可以购买超出待购清单的物品，尽管购买大礼包2更加便宜。  说明:  最多6种物品， 100种大礼包。 每种物品，你最多只需要购买6个。 你不可以购买超出待购清单的物品，即使更便宜。  来源：力扣（LeetCode）第638题  链接：https://leetcode-cn.com/problems/shopping-offers
 分析：  动态规划解法，常规解法需要使用六维数组，实在太麻烦，而且每次的维度还不一样。 使用状压dp的思想，把六维数组归为1维。 因为每一维的长度是0-6，所以我们把这7个数变为一个七进制的数字，但是把它变为10进制存在一个一维数组中。 比如111就是57，它表示a,b,c各有1个。如果是4个1，那就是a,b,c,d各有1个，然后它也有对应的十进制数。 因此，我们把needs中的数看成是一个七进制数，然后把它以十进制表示出来。 比如need如果是121，那么结果是64。那么我们就开辟一个65个的数组。最后把dp[64]返回就是最终答案了。  代码： class Solution { public int shoppingOffers(List&amp;lt;Integer&amp;gt; price, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; special, List&amp;lt;Integer&amp;gt; needs) { int[] Decinal = {1, 7, 49, 343, 2401, 16807, 117649}; // 7的一次方，7的二次方.</description>
    </item>
    
    <item>
      <title>穿过迷宫的最少移动次数</title>
      <link>https://ripple-zjw.github.io/2019/%E7%A9%BF%E8%BF%87%E8%BF%B7%E5%AE%AB%E7%9A%84%E6%9C%80%E5%B0%91%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0/</link>
      <pubDate>Tue, 01 Oct 2019 21:43:48 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%A9%BF%E8%BF%87%E8%BF%B7%E5%AE%AB%E7%9A%84%E6%9C%80%E5%B0%91%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0/</guid>
      <description>题目：穿过迷宫的最少移动次数  你还记得那条风靡全球的贪吃蛇吗？ 我们在一个n*n的网格上构建了新的迷宫地图，蛇的长度为 2，也就是说它会占去两个单元格。蛇会从左上角(0, 0)和(0, 1)开始移动。我们用 0 表示空单元格，用 1 表示障碍物。蛇需要移动到迷宫的右下角(n-1, n-2)和(n-1, n-1)。 每次移动，蛇可以这样走：  如果没有障碍，则向右移动一个单元格。并仍然保持身体的水平／竖直状态。 如果没有障碍，则向下移动一个单元格。并仍然保持身体的水平／竖直状态。 如果它处于水平状态并且其下面的两个单元都是空的，就顺时针旋转 90 度。蛇从（(r, c)、(r, c+1)）移动到 （(r, c)、(r+1, c)）。  如果它处于竖直状态并且其右面的两个单元都是空的，就逆时针旋转 90 度。蛇从（(r, c)、(r+1, c)）移动到（(r, c)、(r, c+1)）。   返回蛇抵达目的地所需的最少移动次数。 如果无法到达目的地，请返回-1。  示例 1： 输入：grid = [[0,0,0,0,0,1], [1,1,0,0,1,0], [0,0,0,0,1,1], [0,0,1,0,1,0], [0,1,1,0,0,0], [0,1,1,0,0,0]] 输出：11 解释： 一种可能的解决方案是 [右, 右, 顺时针旋转, 右, 下, 下, 下, 下, 逆时针旋转, 右, 下]。  示例 2： 输入：grid = [[0,0,1,1,1,1], [0,0,0,0,1,1], [1,1,0,0,0,1], [1,1,1,0,0,1], [1,1,1,0,0,1], [1,1,1,0,0,0]] 输出：9  提示：  2 &amp;lt;= n &amp;lt;= 100 0 &amp;lt;= grid[i][j] &amp;lt;= 1 蛇保证从空单元格开始出发。  来源：力扣（LeetCode）第5208题(临时)  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>买卖股票的最佳时机含手续费</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/</link>
      <pubDate>Tue, 01 Oct 2019 21:42:37 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/</guid>
      <description>题目：买卖股票的最佳时机含手续费  给定一个整数数组prices，其中第i个元素代表了第i天的股票价格 ；非负整数fee代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。  示例 1: 输入: prices = [1, 3, 2, 8, 4, 9], fee = 2 输出: 8 解释: 能够达到的最大利润: 在此处买入 prices[0] = 1 在此处卖出 prices[3] = 8 在此处买入 prices[4] = 4 在此处卖出 prices[5] = 9 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.  注意:  0 &amp;lt; prices.length &amp;lt;= 50000. 0 &amp;lt; prices[i] &amp;lt; 50000. 0 &amp;lt;= fee &amp;lt; 50000.</description>
    </item>
    
    <item>
      <title>机器人大冒险</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%A4%A7%E5%86%92%E9%99%A9/</link>
      <pubDate>Tue, 01 Oct 2019 21:40:38 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%A4%A7%E5%86%92%E9%99%A9/</guid>
      <description>题目：机器人大冒险  力扣团队买了一个可编程机器人，机器人初始位置在原点(0, 0)。小伙伴事先给机器人输入一串指令command，机器人就会无限循环这条指令的步骤进行移动。指令有两种：   U: 向y轴正方向移动一格 R: 向x轴正方向移动一格。   不幸的是，在xy平面上还有一些障碍物，他们的坐标用obstacles表示。机器人一旦碰到障碍物就会被损毁。 给定终点坐标(x,y)，返回机器人能否完好地到达终点。如果能，返回true；否则返回false。  示例 1： 输入：command = &amp;quot;URR&amp;quot;, obstacles = [], x = 3, y = 2 输出：true 解释：U(0, 1) -&amp;gt; R(1, 1) -&amp;gt; R(2, 1) -&amp;gt; U(2, 2) -&amp;gt; R(3, 2)。  示例 2： 输入：command = &amp;quot;URR&amp;quot;, obstacles = [[2, 2]], x = 3, y = 2 输出：false 解释：机器人在到达终点前会碰到(2, 2)的障碍物。  示例 3： 输入：command = &amp;quot;URR&amp;quot;, obstacles = [[4, 2]], x = 3, y = 2 输出：true 解释：到达终点后，再碰到障碍物也不影响返回结果。  限制：  2 &amp;lt;= command的长度&amp;lt;= 1000 command由U，R构成，且至少有一个U，至少有一个R 0 &amp;lt;= x &amp;lt;= 1e9,0 &amp;lt;= y &amp;lt;= 1e9 0 &amp;lt;= obstacles的长度&amp;lt;= 1000 obstacles[i]不为原点或者终点  来源：力扣（LeetCode）LCP.</description>
    </item>
    
    <item>
      <title>两个字符串的最小ASCII删除和</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8Fascii%E5%88%A0%E9%99%A4%E5%92%8C/</link>
      <pubDate>Tue, 01 Oct 2019 21:36:41 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8Fascii%E5%88%A0%E9%99%A4%E5%92%8C/</guid>
      <description>题目：两个字符串的最小ASCII删除和  给定两个字符串s1,s2，找到使两个字符串相等所需删除字符的ASCII值的最小和。  示例 1: 输入: s1 = &amp;quot;sea&amp;quot;, s2 = &amp;quot;eat&amp;quot; 输出: 231 解释: 在 &amp;quot;sea&amp;quot; 中删除 &amp;quot;s&amp;quot; 并将 &amp;quot;s&amp;quot; 的值(115)加入总和。 在 &amp;quot;eat&amp;quot; 中删除 &amp;quot;t&amp;quot; 并将 116 加入总和。 结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。  示例 2: 输入: s1 = &amp;quot;delete&amp;quot;, s2 = &amp;quot;leet&amp;quot; 输出: 403 解释: 在 &amp;quot;delete&amp;quot; 中删除 &amp;quot;dee&amp;quot; 字符串变成 &amp;quot;let&amp;quot;， 将 100[d]+101[e]+101[e] 加入总和。在 &amp;quot;leet&amp;quot; 中删除 &amp;quot;e&amp;quot; 将 101[e] 加入总和。 结束时，两个字符串都等于 &amp;quot;let&amp;quot;，结果即为 100+101+101+101 = 403 。 如果改为将两个字符串转换为 &amp;quot;lee&amp;quot; 或 &amp;quot;eet&amp;quot;，我们会得到 433 或 417 的结果，比答案更大。  注意:  0 &amp;lt; s1.</description>
    </item>
    
    <item>
      <title>不同的二叉搜索树II</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91ii/</link>
      <pubDate>Tue, 01 Oct 2019 21:34:34 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91ii/</guid>
      <description>题目：不同的二叉搜索树 II  给定一个整数n，生成所有由1...n为节点所组成的二叉搜索树。  示例: 输入: 3 输出: [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ] 解释: 以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3  来源：力扣（LeetCode）第95题  链接：https://leetcode-cn.com/problems/unique-binary-search-trees-ii
 分析：  可以使用递归，但我怕超时就没写。 但是几乎所有的递归都可以转换为动态规划，所以这题用dp求解。 思路和前面找个数一样，状态都是第n个数的内容，选择是谁为根节点。 不一样的是状态转移方程稍稍有点复杂，我在代码中说明。  代码： /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public List&amp;lt;TreeNode&amp;gt; generateTrees(int n) { List&amp;lt;TreeNode&amp;gt;[] dp = new ArrayList[n+1]; dp[0] = new ArrayList(); // 如果left或right为0，就会出现空指针异常。 if (n == 0) return dp[0]; dp[0].</description>
    </item>
    
    <item>
      <title>石子游戏</title>
      <link>https://ripple-zjw.github.io/2019/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/</link>
      <pubDate>Tue, 01 Oct 2019 21:32:58 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/</guid>
      <description>题目：石子游戏  亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子piles[i]。 游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。 亚历克斯和李轮流进行，亚历克斯先开始。每回合，玩家从行的开始或结束处取走整堆石头。这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。 假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回true，当李赢得比赛时返回false。  示例： 输入：[5,3,4,5] 输出：true 解释： 亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。 假设他取了前 5 颗，这一行就变成了 [3,4,5] 。 如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。 如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。 这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。  提示：  2 &amp;lt;= piles.length &amp;lt;= 500 piles.length 是偶数。 1 &amp;lt;= piles[i] &amp;lt;= 500 sum(piles)是奇数。  来源：力扣（LeetCode）第877题  链接：https://leetcode-cn.com/problems/stone-game
 分析：  这是一道典型的动态规划题。 要做出动态规划问题，首先要找到问题的状态和选择。 以这道题为例，状态有三种，分别是开始位置索引i，结束位置索引j，还有在i到j这段位置时，先手的值和后手的值。 举个例子，i = 0, j = 0时，表明在第一个索引0时先手明显是piles[0]，而后手没有东西，所以是0。 说完状态再来看选择，根据题意，选择就是你可以从开始位置i拿，也可以从结束位置j拿。 然后是状态转移方程，首先每一个i和j所对应的位置都有先后手两种情况，如果我选择拿了i的值，那么剩下留给另一个人的元素就是i + 1 到 j,而i + 1 到 j是另一个人先手拿的(i+1,j先手就是i,j的后手，因为一人一次)，所以你拿的是i+1, j的后手。 同理如果你拿的是右边的j，那么剩下的就是i, j - 1的后手。 因此状态转移方程就是：max(piles[i] + dp[i+1][j][1], piles[j] + dp[i][j-1][1])。dp是一个三维数组，前两个表示的是i,j位置索引，而1表示的是后手情况，那么0表示的是先手情况。(不一定是0,1也可以是别的，无所谓) 最后我要的结果就是从0到piles长度的下标，即dp[0][piles.</description>
    </item>
    
    <item>
      <title>比特位计数</title>
      <link>https://ripple-zjw.github.io/2019/%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/</link>
      <pubDate>Sat, 21 Sep 2019 16:04:38 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/</guid>
      <description> 题目：比特位计数  给定一个非负整数num。对于0 ≤ i ≤ num 范围中的每个数字i，计算其二进制数中的1 的数目并将它们作为数组返回。  示例 1: 输入: 2 输出: [0,1,1]  示例 2: 输入: 5 输出: [0,1,1,2,1,2]  进阶:  给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？ 要求算法的空间复杂度为O(n)。 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如C++中的__builtin_popcount）来执行此操作。  来源：力扣（LeetCode）第338题  链接：https://leetcode-cn.com/problems/counting-bits
 分析：  由于偶数的二进制数最后一位是0，所以如果一个偶数做&amp;gt;&amp;gt;1运算那么它的1的个数不变。同理如果一个奇数右移一位，1的个数减1。 因此如果1有1个1，那么2也有1个1,3就有2个1。(正推的话做左移运算),如果2有1个1的话，那么4也是1个1,5就是2个1。 所以有了状态转换公式dp[2*i] = dp[i] dp[2*i+1] = dp[i] + 1  代码： class Solution { public int[] countBits(int num) { int[] dp = new int[num + 1]; for (int i = 0; i &amp;lt;= num / 2; i++) { dp[i&amp;lt;&amp;lt;1] = dp[i]; if ((i&amp;lt;&amp;lt;1) + 1 &amp;lt;= num) dp[(i&amp;lt;&amp;lt;1)+1] = dp[i] + 1; } return dp; } }  复杂度分析：  时间复杂度：O(n) n 为num / 2 空间复杂度：O(n) n 为num  </description>
    </item>
    
    <item>
      <title>有序链表转换二叉搜索树</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Sat, 21 Sep 2019 15:50:29 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>题目：有序链表转换二叉搜索树  给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。  示例: 给定的有序链表： [-10, -3, 0, 5, 9], 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5  来源：力扣（LeetCode）第109题  链接：https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree
 分析：  递归 + 快慢双指针  使用快慢指针找出链表的中点。 然后将中点生成树的根。 递归进入左右子树。  模拟遍历中序二叉树  算出链表的长度 把链表一分为二 递归进入链表的左边和右边 同时，在左边递归完后生成父节点 再把递归得到的左右子节点放在父节点的left和right   代码：  递归 + 快慢双指针
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>回文链表</title>
      <link>https://ripple-zjw.github.io/2019/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sat, 21 Sep 2019 15:48:18 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</guid>
      <description>题目：回文链表  请判断一个链表是否为回文链表。  示例 1: 输入: 1-&amp;gt;2 输出: false  示例 2: 输入: 1-&amp;gt;2-&amp;gt;2-&amp;gt;1 输出: true  进阶：  你能否用O(n)时间复杂度和O(1)空间复杂度解决此题？  来源：力扣（LeetCode）第234题  链接：https://leetcode-cn.com/problems/palindrome-linked-list
 分析：  最常见的做法是将链表变为数组，通过数组的随机访问的特性检测回文链表。 第二种更为方便的方法是使用快慢双指针找到链表的中点，然后将前半部分的链表翻转。  代码： /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public boolean isPalindrome(ListNode head) { if (head == null || head.</description>
    </item>
    
    <item>
      <title>环形链表</title>
      <link>https://ripple-zjw.github.io/2019/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sat, 21 Sep 2019 15:45:40 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</guid>
      <description>题目：环形链表  给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数pos 来表示链表尾连接到链表中的位置（索引从0开始）。 如果pos是-1,则在该链表中没有环。  示例 1： 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。  示例 2： 输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。  示例 3： 输入：head = [1], pos = -1 输出：false 解释：链表中没有环。  进阶：  你能用 O(1)（即，常量）内存解决此问题吗？  来源：力扣（LeetCode）第141题  链接：https://leetcode-cn.com/problems/linked-list-cycle
 分析：  这道题可以使用哈希表来做，但这样的空间复杂度是O(n),另一种方法是快慢双指针。 使用两个指针，一个每次走一格，另一个每次走两格。 最后看快指针会不会走到头，或者这两个指针碰到了。  代码： /** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public boolean hasCycle(ListNode head) { if (head == null || head.</description>
    </item>
    
    <item>
      <title>漂亮数组</title>
      <link>https://ripple-zjw.github.io/2019/%E6%BC%82%E4%BA%AE%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sat, 21 Sep 2019 15:32:09 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%BC%82%E4%BA%AE%E6%95%B0%E7%BB%84/</guid>
      <description>题目：漂亮数组  对于某些固定的N，如果数组A是整数1, 2, ..., N组成的排列，使得： 对于每个i &amp;lt; j，都不存在k满足i &amp;lt; k &amp;lt; j使得A[k] * 2 = A[i] + A[j]。 那么数组A是漂亮数组。 给定N，返回任意漂亮数组A（保证存在一个）。  示例 1： 输入：4 输出：[2,1,4,3]  示例 2： 输入：5 输出：[3,1,2,5,4]  提示：  1 &amp;lt;= N &amp;lt;= 1000  来源：力扣（LeetCode）第932题  链接：https://leetcode-cn.com/problems/beautiful-array
 分析：  根据题目的要求，所谓漂亮数组就是A[k] * 2 != A[i] + A[j]。 A[k] * 2一定是一个偶数，那么我们只需要让A[i] + A[j]是奇数就行了，如果我们把奇数放在左边，偶数放在右边，那么左右两边各取一个数相加一定是奇数。 那么还有一个问题，若i是偶数，j也是偶数怎么办？ 如果我们要知道8个数的漂亮数组，首先8有4个奇数，4个偶数，我们需要知道4个数的漂亮数组，如果要知道4个数的漂亮数组又要分为2奇数，2偶数，直到为1个数时，漂亮数组为[1]。 漂亮数组又有一个性质，如果我们把数组中每个元素都乘以a并且加上b(a,b为任意除0外的数)，那么它还是漂亮数组。 同样的我们把奇偶两个漂亮数组相加，结果还是漂亮数组。 既然如此，[1]是漂亮数组，那么我将1*2-1也是是漂亮数组，我将1*2也是漂亮数组，我把这两个数放在一起，也就是[1,2]也是漂亮数组。以此类推，4个数的漂亮数组就是[1,3,2,4],8个数就是[1,5,3,7,2,6,4,8]。如果数不足8个多于4个，我只需要把多余的拿掉就行了。 通过这种方式，可以发现，比如奇数部分的数两数相加除以2要么是偶数，要么在中间根本找不到这个数。  代码：  分治算法：
class Solution: def beautifulArray(self, N: int) -&amp;gt; List[int]: def divi(N): ans = {1: [1]} if N not in ans: odds = divi((N + 1) // 2) evens = divi(N // 2) ans[N] = [2 * odd - 1 for odd in odds] + [2 * even for even in evens] return ans[N] return divi(N)  分治法的迭代版本：</description>
    </item>
    
    <item>
      <title>数组中的第K个最大元素</title>
      <link>https://ripple-zjw.github.io/2019/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</link>
      <pubDate>Sat, 21 Sep 2019 15:30:13 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</guid>
      <description>题目：数组中的第K个最大元素  在未排序的数组中找到第k个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。  示例 1: 输入: [3,2,1,5,6,4] 和 k = 2 输出: 5  示例 2: 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4 输出: 4  说明:  你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。  来源：力扣（LeetCode）第215题  链接：https://leetcode-cn.com/problems/kth-largest-element-in-an-array
 分析：  有两种做法，一种是使用快排思想，选中一个数，对其进行partition。 第二种做法是使用堆，维护一个大顶堆，要拿到第k大元素就删除堆顶k次  代码：  快速排序改进：
class Solution: def findKthLargest(self, nums: List[int], k: int) -&amp;gt; int: self.k = k ans = self.quickSort(nums, 0, len(nums) - 1) return ans if ans else nums[k-1] def portition(self, arr, start, end): pivot = arr[end] i = start - 1 for j in range(start, end): if pivot &amp;lt; arr[j]: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i+1], arr[end] = arr[end], arr[i+1] return i + 1 def quickSort(self, arr, start, end): if start &amp;lt; end: pivot = self.</description>
    </item>
    
    <item>
      <title>为运算表达式设计优先级</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7/</link>
      <pubDate>Tue, 10 Sep 2019 22:59:46 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7/</guid>
      <description>题目：为运算表达式设计优先级  给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含+,-以及*。  示例 1: 输入: &amp;quot;2-1-1&amp;quot; 输出: [0, 2] 解释: ((2-1)-1) = 0 (2-(1-1)) = 2  示例 2: 输入: &amp;quot;2*3-4*5&amp;quot; 输出: [-34, -14, -10, -10, 10] 解释: (2*(3-(4*5))) = -34 ((2*3)-(4*5)) = -14 ((2*(3-4))*5) = -10 (2*((3-4)*5)) = -10 (((2*3)-4)*5) = 10  来源：力扣（LeetCode）第241题  链接：https://leetcode-cn.com/problems/different-ways-to-add-parentheses
 ## 分析： - 动态规划+分治算法。 - 当只有一个运算符时，只有一种情况，当有两个运算符时有两种情况，以此类推。 - 当有三个运算符时，假设第一个运算符优先级最高，然后剩下三个数有两种情况，将两种情况与其相加，得到答案。接着判断第二个运算符优先级最低时，依次类推。
代码： from functools import lru_cache # lru缓存淘汰算法。 class Solution: @lru_cache(None) def diffWaysToCompute(self, input: str) -&amp;gt; List[int]: if input.</description>
    </item>
    
    <item>
      <title>搜索插入位置</title>
      <link>https://ripple-zjw.github.io/2019/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Tue, 10 Sep 2019 22:48:08 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</guid>
      <description>搜索插入位置  给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。  示例 1: 输入: [1,3,5,6], 5 输出: 2  示例 2: 输入: [1,3,5,6], 2 输出: 1  示例 3: 输入: [1,3,5,6], 7 输出: 4  示例 4: 输入: [1,3,5,6], 0 输出: 0  来源：力扣（LeetCode）第35题  链接：https://leetcode-cn.com/problems/search-insert-position
 两种二分查找模版： target = 要查找的值 left = 0, right = arr.length while left &amp;lt; right: mid = (left + right) &amp;gt;&amp;gt; 1 // 为了防止数组溢出，也可以写成left + (right - left) &amp;gt;&amp;gt; 1 if arr[mid] == target: return arr[mid] elif arr[mid] &amp;gt; target: right = mid else: left = mid + 1  target = 要查找的值 left = 0, right = arr.</description>
    </item>
    
    <item>
      <title>使用异或运算判断奇偶性</title>
      <link>https://ripple-zjw.github.io/2019/%E4%BD%BF%E7%94%A8%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E5%88%A4%E6%96%AD%E5%A5%87%E5%81%B6%E6%80%A7/</link>
      <pubDate>Tue, 10 Sep 2019 22:46:51 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%BD%BF%E7%94%A8%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E5%88%A4%E6%96%AD%E5%A5%87%E5%81%B6%E6%80%A7/</guid>
      <description> 使用异或运算判断奇偶性  原理是通过异或运算中的一个数与自己本身异或得到0，与0异或得到自己。  解释： 比如说有一组数组[1, 1, 1, 1] 我们使用异或判断
ans = [1, 1, 1, 1] parity = ans[0] # 拿出第一个数 for i in ans[1:]: # 从数组的第二个数开始循环 parity ^= i parity == 1 # 如果等于1说明1有奇数个，如果等于0说明1有偶数个。例如1^1=0 0^1=1  </description>
    </item>
    
    <item>
      <title>使用最小花费爬楼梯</title>
      <link>https://ripple-zjw.github.io/2019/%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</link>
      <pubDate>Tue, 10 Sep 2019 22:45:45 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</guid>
      <description>题目：使用最小花费爬楼梯  数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值cost[i](索引从0开始)。 每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。 您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。  示例 1: 输入: cost = [10, 15, 20] 输出: 15 解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。  示例 2: 输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 输出: 6 解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。  注意：  cost的长度将会在[2, 1000]。 每一个cost[i] 将会是一个Integer类型，范围为[0, 999]。  来源：力扣（LeetCode）第746题  链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs
 分析：  可以使用递归或者动态规划来解这道题。 思路是如果要跳到第i个位置，那么就要先跳到i-1或者是i-2个位置。  代码：  动态规划： python
class Solution: def minCostClimbingStairs(self, cost: List[int]) -&amp;gt; int: for i in range(2, len(cost)): cost[i] = min(cost[i-1], cost[i-2]) + cost[i] # 你想要跳到第i个位置，就要跳先跳到i-1或i-2个位置。 return min(cost[-1], cost[-2]) # 决定最后是从倒数第一个位置跳上去，还是倒数第二个位置跳上去。  java</description>
    </item>
    
    <item>
      <title>合并两个有序数组</title>
      <link>https://ripple-zjw.github.io/2019/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Tue, 10 Sep 2019 22:44:21 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
      <description>题目：合并两个有序数组  给定两个有序整数数组nums1和nums2，将nums2 合并到nums1中，使得num1成为一个有序数组。  说明:  初始化nums1和nums2的元素数量分别为m和n。 你可以假设nums1有足够的空间（空间大小大于或等于m + n）来保存 nums2 中的元素。  示例: 输入: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 输出: [1,2,2,3,5,6]  来源：力扣（LeetCode）第88题  链接：https://leetcode-cn.com/problems/merge-sorted-array
 分析：  从后往前放元素，就能解开了。  代码：  Python
class Solution: def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&amp;gt; None: p1 = m - 1 # num1的指针 p2 = n - 1 # num2的指针 p = m + n - 1 # num1存放答案的指针 while p1 &amp;gt;= 0 and p2 &amp;gt;= 0: # 将两者大的值放进去。 if nums1[p1] &amp;gt; nums2[p2]: nums1[p] = nums1[p1] p1 -= 1 else: nums1[p] = nums2[p2] p2 -= 1 p -= 1 nums1[:p2+1] = nums2[:p2+1] # 最后将nums2中还没放完的元素放进去。  Java</description>
    </item>
    
    <item>
      <title>单调数列</title>
      <link>https://ripple-zjw.github.io/2019/%E5%8D%95%E8%B0%83%E6%95%B0%E5%88%97/</link>
      <pubDate>Tue, 10 Sep 2019 22:42:16 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%8D%95%E8%B0%83%E6%95%B0%E5%88%97/</guid>
      <description>题目：单调数列  如果数组是单调递增或单调递减的，那么它是单调的。 如果对于所有i &amp;lt;= j，A[i] &amp;lt;= A[j]，那么数组 A 是单调递增的。 如果对于所有i &amp;lt;= j，A[i]&amp;gt; = A[j]，那么数组 A 是单调递减的。  当给定的数组 A 是单调数组时返回true，否则返回 false。
示例 1： 输入：[1,2,2,3] 输出：true  示例 2： 输入：[6,5,4,4] 输出：true  示例 3： 输入：[1,3,2] 输出：false  示例 4： 输入：[1,2,4,5] 输出：true  示例 5： 输入：[1,1,1] 输出：true  提示：  1 &amp;lt;= A.length &amp;lt;= 50000 -100000 &amp;lt;= A[i] &amp;lt;= 100000  来源：力扣（LeetCode）第896题  链接：https://leetcode-cn.com/problems/monotonic-array
 分析：  通过大于为1，等于为0，小于为-1判断列表是否单调。 如果一个数中既出现了1，也出现了-1，那么它不是单调数组。 有一点要注意，Python2中自带cmp的函数，可以直接判断，而Python3中将cmp函数移除了，所以Python3中需要自己写一个cmp函数，而Python2中不用。  代码：  Python</description>
    </item>
    
    <item>
      <title>数组的度</title>
      <link>https://ripple-zjw.github.io/2019/%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%A6/</link>
      <pubDate>Fri, 06 Sep 2019 20:27:15 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%A6/</guid>
      <description>题目：数组的度  给定一个非空且只包含非负数的整数数组nums, 数组的度的定义是指数组里任一元素出现频数的最大值。 你的任务是找到与nums拥有相同大小的度的最短连续子数组，返回其长度。  示例 1: 输入: [1, 2, 2, 3, 1] 输出: 2 解释: 输入数组的度是2，因为元素1和2的出现频数最大，均为2. 连续子数组里面拥有相同度的有如下所示: [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2] 最短连续子数组[2, 2]的长度为2，所以返回2.  示例 2: 输入: [1,2,2,3,1,4,2] 输出: 6  注意:  nums.length在1到50,000区间范围内。 nums[i]是一个在0到49,999范围内的整数。  来源：力扣（LeetCode）第697题  链接：https://leetcode-cn.com/problems/degree-of-an-array
 分析：  找到每一个元素的第一个下标和最后一个下标。 然后找出出现频率最高的元素。 答案就是频率最高的元素的最后一个下标减去第一个下标。  代码： class Solution: def findShortestSubArray(self, nums: List[int]) -&amp;gt; int: left, right, count = {}, {}, {} for i in range(len(nums)): if nums[i] not in left: # 将第一个下标保存 left[nums[i]] = i right[nums[i]] = i # 将最后一个下标保存 count[nums[i]] = count.</description>
    </item>
    
    <item>
      <title>图片平滑器</title>
      <link>https://ripple-zjw.github.io/2019/%E5%9B%BE%E7%89%87%E5%B9%B3%E6%BB%91%E5%99%A8/</link>
      <pubDate>Fri, 06 Sep 2019 20:26:04 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%9B%BE%E7%89%87%E5%B9%B3%E6%BB%91%E5%99%A8/</guid>
      <description>题目：图片平滑器  包含整数的二维矩阵M表示一个图片的灰度。 你需要设计一个平滑器来让每一个单元的灰度成为平均灰度(向下舍入) ，平均灰度的计算是周围的8个单元和它本身的值求平均，如果周围的单元格不足八个，则尽可能多的利用它们。  示例 1: 输入: [[1,1,1], [1,0,1], [1,1,1]] 输出: [[0, 0, 0], [0, 0, 0], [0, 0, 0]] 解释: 对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0 对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0 对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0  注意:  给定矩阵中的整数范围为 [0, 255]。 矩阵的长和宽的范围均为 [1, 150]。  来源：力扣（LeetCode）第661题  链接：https://leetcode-cn.com/problems/image-smoother
 分析：  可以一个一个判断，但是不好，另一种方法，先把八个方向放在一个列表中，然后每次遍历这八个方向。  代码： class Solution: def imageSmoother(self, M: List[List[int]]) -&amp;gt; List[List[int]]: ans = [] directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]] # 生成八个方向的列表。 height = len(M) width = len(M[0]) for i in range(height): tmp = [] for j in range(width): res = M[i][j] cnt = 1 for direction in directions: y = direction[0] + i x = direction[1] + j if y &amp;lt; height and x &amp;lt; width and x &amp;gt;= 0 and y &amp;gt;= 0: # 每次都要判断方向是否合法，防止数组越界。 res += M[y][x] cnt += 1 tmp.</description>
    </item>
    
    <item>
      <title>两数之和II 输入有序数组</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8Cii-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Fri, 06 Sep 2019 20:24:19 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8Cii-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
      <description>题目：两数之和 II - 输入有序数组  给定一个已按照升序排列的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中index1必须小于index2。  说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。  示例: 输入: numbers = [2, 7, 11, 15], target = 9 输出: [1,2] 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。  来源：力扣（LeetCode）第167题  链接：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted
 分析： 方法有：hash表，二分查找，双指针。
代码：  hash表:
class Solution: def twoSum(self, numbers: List[int], target: int) -&amp;gt; List[int]: hashTable = {} for i in range(len(numbers)): if hashTable.</description>
    </item>
    
    <item>
      <title>缺失数字</title>
      <link>https://ripple-zjw.github.io/2019/%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97/</link>
      <pubDate>Fri, 06 Sep 2019 20:21:39 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97/</guid>
      <description> 题目：缺失数字  给定一个包含0, 1, 2, ..., n中n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。  示例 1: 输入: [3,0,1] 输出: 2  示例 2: 输入: [9,6,4,2,3,5,7,0,1] 输出: 8  说明:  你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?  来源：力扣（LeetCode）第268题  链接：https://leetcode-cn.com/problems/missing-number
 分析： 使用排序和哈希可以很容易做出来，但是不符合题意O(1)的空间复杂度。还有两种方法，一种是位运算，另一种是通过数学定理来解题。
位运算解题：  异或运算的性质：  异或运算（XOR）满足结合律，并且对一个数进行两次完全相同的异或运算会得到原来的数。 比如：a ^ b ^ b == a 任意一个数对0进行异或运算，等于它原来的数。 比如：a ^ 0 == a 任意一个数对它本身进行异或运算，等于0. 比如：a ^ a == 0  因此，在0-n个数的数组中必定缺少一个数。我们把数组的下标和数组中的数进行异或运算，所有的数都会找到下标相等的数，只有缺失的那个数字找不到，最后算出来的结果就是那个缺失的数。  代码： class Solution: def missingNumber(self, nums: List[int]) -&amp;gt; int: ans = len(nums) # 由于数组没有长度为nums长度的下标，因为从0开始索引的，所以我们要先加上去。 for i in range(len(nums)): ans ^= i ^ nums[i] return ans  数学定理解题：  等差数列求和公式：  n * (n+1) / 2  我们把从0到数组最后的下标累加，再加上数组的长度。 再把数组中的所有元素累加。 然后两个相减，最后得到的就是缺失的数字。  代码： class Solution: def missingNumber(self, nums: List[int]) -&amp;gt; int: n = len(nums) return n * (n + 1) // 2 - sum(nums)  复杂度分析：  两种方法复杂度一样：  时间复杂度：O(n) 空间复杂度：O(1)   </description>
    </item>
    
    <item>
      <title>找到所有数组中消失的数字</title>
      <link>https://ripple-zjw.github.io/2019/%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Fri, 06 Sep 2019 20:19:35 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>题目：找到所有数组中消失的数字  给定一个范围在1 ≤ a[i] ≤ n (n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。 找到所有在 [1, n] 范围之间没有出现在数组中的数字。 您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。  示例: 输入: [4,3,2,7,8,2,3,1] 输出: [5,6]  来源：力扣（LeetCode）第448题  链接：https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array
 分析： 有多种方法，第一种是用抽屉原理和异或运算的方式交换值。第二种是一种更为巧妙的方式。
使用异或运算交换两个值的方法： a = a ^ b b = a ^ b a = a ^ b 这样就可以在不使用第三个变量的前提下交换两个变量的值。  抽屉原理：  如果每个抽屉代表一个集合，每一个苹果就可以代表一个元素，假如有 n + 1 个元素放到 n 个集合中去，其中必定有一个集合里至少有两个元素。” 抽屉原理有时也被称为鸽巢原理。它是组合数学中一个重要的原理。  思路：  第一种：  遍历整个数组，从第一个开始i，不停地把这个位置上的元素i与它的值所对应的下标位置上的元素进行交换。 一旦当前遍历的这个位置上的元素i与它值所对应的下标位置上的元素相等，那么就遍历数组的下一个元素i。 这样的目的是，要么当前位置上i存的是正确的位置，比如i = 0的位置上存的是1，因为数组中的元素是从1开始的；要么当前位置i上存的是出现了两次的元素。 这样最后判断每个元素的值是否是其下标+1。  第二种：  遍历整个数组，将该元素的值所对应的下标位置的值变为负数。 遍历完后，如果数组中还有位置上的值是正数，那么说明没有值等于该位置的下标，即数组中没有遍历到这个值。   两种方法的代码：  第一种：</description>
    </item>
    
    <item>
      <title>组合总和</title>
      <link>https://ripple-zjw.github.io/2019/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</link>
      <pubDate>Fri, 06 Sep 2019 20:18:05 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</guid>
      <description>题目：组合总和  给定一个无重复元素的数组candidates和一个目标数target，找出candidates中所有可以使数字和为target的组合。 candidates中的数字可以无限制重复被选取。  说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。  示例 1: 输入: candidates = [2,3,6,7], target = 7, 所求解集为: [ [7], [2,2,3] ]  示例 2: 输入: candidates = [2,3,5], target = 8, 所求解集为: [ [2,2,2,2], [2,3,3], [3,5] ]  来源：力扣（LeetCode）  链接：https://leetcode-cn.com/problems/combination-sum
 分析： 回溯算法+栈，这是我的做法，看到很多算法高手的思路和方法都很棒，有用回溯的，有用dp的。
我放上两个比较好的题解:  回溯算法： &amp;gt; https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/ 动态规划： &amp;gt; https://leetcode-cn.com/problems/combination-sum/solution/chao-qiang-gifzhu-ni-shi-yong-dong-tai-gui-hua-qiu/  思路：  回溯算法一般都用递归来完成。最好的方法是画递归树。 通过对每一层的递归，将所有等于target的答案全部都得到。  代码： class Solution: def combinationSum(self, candidates: List[int], target: int) -&amp;gt; List[List[int]]: ans = [] def recursion(cand, i): for j in range(i, len(candidates)): stack.</description>
    </item>
    
    <item>
      <title>复写零</title>
      <link>https://ripple-zjw.github.io/2019/%E5%A4%8D%E5%86%99%E9%9B%B6/</link>
      <pubDate>Fri, 06 Sep 2019 20:16:32 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%A4%8D%E5%86%99%E9%9B%B6/</guid>
      <description>题目：复写零  给你一个长度固定的整数数组arr，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。 注意：请不要在超过该数组长度的位置写入元素。 要求：请对输入的数组就地进行上述修改，不要从函数返回任何东西。  示例 1： 输入：[1,0,2,3,0,4,5,0] 输出：null 解释：调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4]  示例 2： 输入：[1,2,3] 输出：null 解释：调用函数后，输入的数组将被修改为：[1,2,3]  提示：  1 &amp;lt;= arr.length &amp;lt;= 10000 0 &amp;lt;= arr[i] &amp;lt;= 9  来源：力扣（LeetCode）第1089题  链接：https://leetcode-cn.com/problems/duplicate-zeros
 分析： 这道题的难点在于要在原数组上操作，不可以申请新的数组。因此，快慢双指针就派上用场了。
思路：  声明两个指针i,j 一个指针正常遍历i，另一个j遇到0就往前再+1 遍历完之后i之后的数都是被移出去的，j指针在最后一位 依次将i指针的元素赋在j的位置，遇到0，j不仅要将i的值赋上，还要往前一位再赋上0。  代码：  双指针法：
class Solution: def duplicateZeros(self, arr: List[int]) -&amp;gt; None: i = j = 0 n = len(arr) while j &amp;lt; n: if arr[i] == 0: j += 1 i += 1 j += 1 i -= 1 j -= 1 while i &amp;gt;= 0: if j &amp;lt; n: arr[j] = arr[i] if arr[i] == 0: j -= 1 arr[j] = 0 j -= 1 i -= 1  非原地解法：</description>
    </item>
    
    <item>
      <title>数组的相对排序</title>
      <link>https://ripple-zjw.github.io/2019/%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Fri, 30 Aug 2019 19:27:49 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/</guid>
      <description>题目：数组的相对排序  给你两个数组，arr1 和arr2，  arr2中的元素各不相同 arr2 中的每个元素都出现在arr1中  对arr1中的元素进行排序，使arr1中项的相对顺序和arr2中的相对顺序相同。 未在arr2中出现过的元素需要按照升序放在arr1的末尾。  示例： 输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6] 输出：[2,2,2,1,4,3,3,9,6,7,19]  提示：  arr1.length, arr2.length &amp;lt;= 1000 0 &amp;lt;= arr1[i], arr2[i] &amp;lt;= 1000 arr2中的元素arr2[i]各不相同 arr2 中的每个元素arr2[i]都出现在arr1中  来源：力扣（LeetCode）第1122题  链接：https://leetcode-cn.com/problems/relative-sort-array
 分析：  最近一直在做数组的题目，这种题一眼就想到了计数排序，唯一的不同就是在排序的时候要按arr2的顺序排。 我的代码是遍历了两边，第一遍是遍历arr2，第二遍遍历整个排序，如果你有更好的计数排序方法，欢迎你告诉我。 不知道你们有没有遇到过计数排序，我尽可能的把注释写的详细一点，好给没接触过的人参考一下。（反正多遇到几次就写的很熟了） 其实就是用到了hash表。  代码： class Solution: def relativeSortArray(self, arr1: List[int], arr2: List[int]) -&amp;gt; List[int]: arr = [0 for _ in range(1001)] # 由于题目说arr1的范围在0-1000，所以生成一个1001大小的数组用来存放每个数出现的次数。 ans = [] # 储存答案的数组。 for i in range(len(arr1)): # 遍历arr1，把整个arr1的数的出现次数储存在arr上，arr的下标对应arr1的值，arr的值对应arr1中值出现的次数。 arr[arr1[i]] += 1 # 如果遇到了这个数，就把和它值一样的下标位置上+1，表示这个数在这个下标i上出现了1次。 for i in range(len(arr2)): # 遍历arr2，现在开始要输出答案了。 while arr[arr2[i]] &amp;gt; 0: # 如果arr2的值在arr所对应的下标位置出现次数大于0，那么就说明arr中的这个位置存在值。 ans.</description>
    </item>
    
    <item>
      <title>杨辉三角</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</link>
      <pubDate>Fri, 30 Aug 2019 19:22:10 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</guid>
      <description> 题目：杨辉三角  给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。  示例: 输入: 5 输出: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ]  来源：力扣（LeetCode）第118题  链接：https://leetcode-cn.com/problems/pascals-triangle
 分析： 这题可以使用动态规划，是一道非常简单的题目。我们可以把所要求的值看成是前一行的两个值的相加，而且这两个值的位置是有规律的。
思路：  两个循环，第一遍遍历所有的层。 第二遍遍历每一层中的值。 每一层中的值只有第一个和最后一个是1，其他的值都是前一行的前一个位置和现在的位置的和。  代码： class Solution: def generate(self, numRows: int) -&amp;gt; List[List[int]]: ans = [] for i in range(numRows): numRow = [1 for _ in range(i + 1)] for j in range(1, i): numRow[j] = ans[i-1][j-1] + ans[i-1][j] ans.append(numRow) return ans  复杂度分析：  时间复杂度：O(n^2^) n 为numRows 空间复杂度：O(n^2^)  </description>
    </item>
    
    <item>
      <title>按奇偶排序数组</title>
      <link>https://ripple-zjw.github.io/2019/%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%842/</link>
      <pubDate>Fri, 30 Aug 2019 19:20:28 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%842/</guid>
      <description>题目：按奇偶排序数组 II  给定一个非负整数数组A，A中一半整数是奇数，一半整数是偶数。 对数组进行排序，以便当A[i] 为奇数时，i也是奇数；当A[i]为偶数时，i 也是偶数。 你可以返回任何满足上述条件的数组作为答案。  示例： 输入：[4,2,5,7] 输出：[4,5,2,7] 解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。  提示：  2 &amp;lt;= A.length &amp;lt;= 20000 A.length % 2 == 0 0 &amp;lt;= A[i] &amp;lt;= 1000  来源：力扣（LeetCode）第922题  链接：https://leetcode-cn.com/problems/sort-array-by-parity-ii
 分析： 一遍遍历数组即可求解。但是为了追求极致，采用双指针法可以实现原地交换。
思路：  使用两个指针i,j。 一个遍历偶数下标，一个遍历奇数下标。 如果i在偶数的下标中找到了一个奇数，那么就从j奇数下标中找一个偶数。 将两者交换位置。  代码：  双指针法：
class Solution: def sortArrayByParityII(self, A: List[int]) -&amp;gt; List[int]: j = 1 for i in range(0, len(A), 2): if A[i] % 2 == 1: while A[j] % 2 == 1: j += 2 A[i], A[j] = A[j], A[i] return A  正常一次遍历：</description>
    </item>
    
    <item>
      <title>求众数</title>
      <link>https://ripple-zjw.github.io/2019/%E6%B1%82%E4%BC%97%E6%95%B0/</link>
      <pubDate>Fri, 30 Aug 2019 19:17:44 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%B1%82%E4%BC%97%E6%95%B0/</guid>
      <description>题目：求众数  给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于⌊ n/2 ⌋的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。  示例 1: 输入: [3,2,3] 输出: 3  示例 2: 输入: [2,2,1,1,1,2,2] 输出: 2  来源：力扣（LeetCode）第169题  链接：https://leetcode-cn.com/problems/majority-element
 分析： 这道题很经典，方法有很多，暴力法，分治法，哈希法，排序法，随机法，投票法。我自己用了哈希法做出来的，但是官方的投票法真的是太秀了，这里着重讲投票法。
思路：  先让第一个人作为candidate， 然后和它一样的元素给他加票，不一样的元素给它减票， 当票数为0时，就换掉candidate，让新的元素担任。 最后成为candidate的元素就是众数。 当然，前提是题目给出地假设一定存在众数。  代码：  投票法：
class Solution: def majorityElement(self, nums: List[int]) -&amp;gt; int: candidate = 0 count = 0 for num in nums: if count == 0: candidate = num count += 1 if num == candidate else -1 return candidate  哈希法：(自己做的)</description>
    </item>
    
    <item>
      <title>有序数组的平方</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</link>
      <pubDate>Fri, 23 Aug 2019 13:01:17 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</guid>
      <description>题目：有序数组的平方  给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。  示例 1： 输入：[-4,-1,0,3,10] 输出：[0,1,9,16,100]  示例 2： 输入：[-7,-3,2,3,11] 输出：[4,9,9,49,121]  提示：  1 &amp;lt;= A.length &amp;lt;= 10000 10000 &amp;lt;= A[i] &amp;lt;= 10000 A已按非递减顺序排序。  来源：力扣（LeetCode）第977题  链接：https://leetcode-cn.com/problems/squares-of-a-sorted-array
 分析： 这道题的方法有两种，一种最简单，先计算，再排序。第二种用双指针做到一遍遍历解答。
思路：  由于数组是按照递增的顺序增长的，因此所有的正数都是递增的，所有的负数加上绝对值都是递减的。 我们用两个指针i和j，i从前往后遍历，j从后往前遍历。 i遇到正数就停下来，j遇到负数就停下来，然后比较他们两谁小，小的那个放到ans答案中。 然后就把放入答案中的那个指针往后前移。 最后退出循环，但是可能有一个指针并没有移到终点，因此要在循环结束后去判断两个指针的情况，把指针后面的值都加到ans中去。 最后得到答案。  代码： class Solution: def sortedSquares(self, A: List[int]) -&amp;gt; List[int]: i = 0 j = len(A) - 1 ans = [] while i &amp;lt; len(A) and j &amp;gt;= 0: # 主循环 while i &amp;lt; len(A) and A[i] &amp;lt; 0: # 遍历到第一个正数 i += 1 while j &amp;gt;= 0 and A[j] &amp;gt;= 0: # 遍历到第一个负数 j -= 1 if i &amp;lt; len(A) and j &amp;gt;= 0: # 谁小就把谁加进来 if A[i] ** 2 &amp;gt; A[j] ** 2: ans.</description>
    </item>
    
    <item>
      <title>高度检查器</title>
      <link>https://ripple-zjw.github.io/2019/%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/</link>
      <pubDate>Fri, 23 Aug 2019 12:59:06 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/</guid>
      <description>题目：高度检查器  学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。 请你返回至少有多少个学生没有站在正确位置数量。该人数指的是：能让所有学生以 非递减 高度排列的必要移动人数。  示例： 输入：[1,1,4,2,1,3] 输出：3 解释： 高度为 4、3 和最后一个 1 的学生，没有站在正确的位置。  提示：  1 &amp;lt;= heights.length &amp;lt;= 100 1 &amp;lt;= heights[i] &amp;lt;= 100  来源：力扣（LeetCode）第1051题  链接：https://leetcode-cn.com/problems/height-checker
 分析： 有两种方法。都是先排序，然后比较两者之间的差异。不同处，第一种是比较排序，第二种是计数排序。计数排序的时间复杂度相对较低，本文讲解计数排序。
思路：  因为heights[i]不会超过100，所以采用hash的思想，将所给数组每个值出现的次数作为值，将所给数组的值作为下标，这样相同值出现的次数就会被归在一起，而且值小的元素会在前面，因为下标就是值。 如果1出现了3次，那么这3次一定是在最前面的，所以我们顺序遍历原数组，如果前3次不是1，就说明这个数要移动，以此类推。  代码： class Solution: def heightChecker(self, heights: List[int]) -&amp;gt; int: ans = 0 arr = [0] * 101 # heights[i]最多不超过100个 for height in heights: # 将heights散列到arr中 arr[height] += 1 j = 0 for i in range(1, len(arr)): # 根据arr中的计数排序比较原数组 while arr[i] &amp;gt; 0: if heights[j] !</description>
    </item>
    
    <item>
      <title>求最大子数组</title>
      <link>https://ripple-zjw.github.io/2019/%E6%B1%82%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</link>
      <pubDate>Fri, 23 Aug 2019 12:57:06 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%B1%82%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</guid>
      <description>题目：求最大子数组  在一个数组中找到和最大的子数组。 数组中有正有负，但都是integer类型。  题目来源：算法导论第38页 4.1 最大子数组问题 分析： 根据书中的问题，采用分治思想来解题。具体可参考算法导论。
思路：  将整个数组一分为二，每次分完之后做四件事件：  查看是否是最小数组即长度是1，因为数组长度是1那么总和就是这一个数的值。 如果不是1，那就分别递归进左边的数组和右边的数组继续分，直到分到1再返回。 每次递归除了左边的最大子数组和右边的最大子数组外，还有交叉在中间的最大子数组。所以要把中间的最大子数组也算出来。 算出三者的各自的和将和最大的那个子数组并返回，同时返回它的两端下标。  每次递归都会返回左边，右边，中间的最大的那个子数组。 最后一次递归返回最大的子数组，答案就出来了。  代码： class FindMaxNum: def _find_crossing(self, A, low, mid, high): # 寻找穿过中间值的最大子数组 leftSum = float(&#39;-inf&#39;) ans = 0 maxLeft = mid maxRight = mid + 1 for i in range(mid, low - 1, -1): # 找到左边的最大子数组 ans += A[i] if ans &amp;gt; leftSum: leftSum = ans maxLeft = i rightSum = float(&#39;-inf&#39;) ans = 0 for j in range(mid + 1, high + 1): # 找到右边的最大子数组 ans += A[j] if ans &amp;gt; rightSum: rightSum = ans maxRight = j return maxLeft, maxRight, leftSum + rightSum # 返回最大的子数组以及它的两端下标 def find_max_num(self, A, low, high): if low == high: # 如果分到了1，那么就返回 return low, high, A[low] else: mid = (low + high) // 2 # 将数组一分为二 left_low, left_high, left_sum = self.</description>
    </item>
    
    <item>
      <title>接雨水</title>
      <link>https://ripple-zjw.github.io/2019/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</link>
      <pubDate>Fri, 23 Aug 2019 12:55:03 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</guid>
      <description>题目：接雨水  给定n个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。   上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。感谢 Marcos 贡献此图。  示例: 输入: [0,1,0,2,1,0,1,3,2,1,2,1] 输出: 6  来源：力扣（LeetCode）第42题  链接：https://leetcode-cn.com/problems/trapping-rain-water
 分析： 方法太多了，一道极难题，从暴力法，到动态规划，再到单调栈，再到双指针。方法非常多，也很难理解，暴力法最好理解，dp和双指针稍难，我这里讲单调栈的方法。
思路：  维护一个单调递减栈。 当有值比栈顶元素大的时候做这么几件事情：  先出栈一个元素并保存到top中。 然后判断stack是否是空，如果是空的话，说明出栈的左边没有东西，所以无法装雨水。(一定要两边都要有东西并且两边的墙比出栈的墙要长，这样才能装雨水) 算出当前元素与栈顶元素中间的距离dis(注意现在是出栈之后的栈顶元素) 算出当前元素与栈顶元素中哪个值最小，并将小的那个值与出栈的那个元素相减，得到floor_cnt 为什么要叫floor_cnt呢，因为将floor_cnt与dis(也就是两栋大墙之间的距离)相乘，你就能得到在这两栋墙之间一层的雨水数量。 将它们加到ans答案中。例如：如果两栋墙最小的那栋是3，那么就会有3层，每一层的雨水数量可能是不一样的，所以要算3遍。 最后返回ans得到答案。  如果值比栈顶元素小的话就入栈就行了，这样就能维护单调递减栈。(注意栈中存的是数组下标，为了算起来方便。)  Talk is cheap,show me the code. class Solution(object): def trap(self, height): stack = [] ans = 0 cur = 0 while cur &amp;lt; len(height): while stack and height[stack[-1]] &amp;lt; height[cur]: top = stack.</description>
    </item>
    
    <item>
      <title>任务调度器</title>
      <link>https://ripple-zjw.github.io/2019/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/</link>
      <pubDate>Fri, 23 Aug 2019 12:52:54 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/</guid>
      <description> 题目：任务调度器  给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。 任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。 CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。 然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。 你需要计算完成所有任务所需要的最短时间。  示例 1： 输入: tasks = [&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;,&amp;quot;B&amp;quot;,&amp;quot;B&amp;quot;,&amp;quot;B&amp;quot;], n = 2 输出: 8 执行顺序: A -&amp;gt; B -&amp;gt; (待命) -&amp;gt; A -&amp;gt; B -&amp;gt; (待命) -&amp;gt; A -&amp;gt; B.  注：  任务的总个数为 [1, 10000]。 n 的取值范围为 [0, 100]。  来源：力扣（LeetCode）第621题  链接：https://leetcode-cn.com/problems/task-scheduler
 分析： 写在队列的标签里，本质上用的却是贪心算法，不知道为什么，同时还用到了一点hashmap的知识。
思路：  要知道最短时间首先要找到出现次数最多的那个值，如果出现次数一样多，选哪个都无所谓。 然后看A-Z中总共有几个数字出现了，假设最多次数的值是A，那么第一个A到第二个A之间总共还能再放n个不一样的值。 A -&amp;gt; (单位时间) -&amp;gt; (单位时间) -&amp;gt; A -&amp;gt; (单位时间) -&amp;gt; (单位时间) -&amp;gt; A 如果填不满那就为等待时间。 如果填满了，那就说明不需要等待时间就能得到最短时间，所以最短时间就是数组的长度。 如果没填满，那么我们可以计算(出现的次数最多的元素 - 1) * (n + 1) + 出现次数一样多的元素的个数 我们依靠出现的次数最多的元素A把整个答案划分为a份(a为A的次数)，每一份就是n+1，由于最后一份不一定是n+1，所以是(a-1)*(n+1)，最后在把不相等的最后一份加进去就得到了答案。  代码： class Solution: def leastInterval(self, tasks: List[str], n: int) -&amp;gt; int: count = [0] * 26 for task in tasks: count[ord(task) - 65] += 1 # 这里是我自己写的简单hash函数，也可以用字典，我这里觉得简单就没用字典。 maxNum = max(count) maxCount = 0 for c in count: if c == maxNum: maxCount += 1 return max((maxNum - 1) * (n + 1) + maxCount, len(tasks))  复杂度分析：  时间复杂度：O(n) n为tasks的长度 空间复杂度：O(1)  总结：  第一次写贪心算法题，标签写错了，本来有想到贪心算法的，可是标签是队列我就一直在想队列，想了半天没有思路。 贪心算法得到的有可能是近似解，在使用贪心算法时要想清楚特殊的情况。  </description>
    </item>
    
    <item>
      <title>二叉树的后序遍历</title>
      <link>https://ripple-zjw.github.io/2019/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Fri, 23 Aug 2019 12:49:52 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>题目：二叉树的后序遍历  给定一个二叉树，返回它的 后序 遍历。  示例: 输入: [1,null,2,3] 1 \ 2 / 3 输出: [3,2,1]  进阶:递归算法很简单，你可以通过迭代算法完成吗？
来源：力扣（LeetCode）第145题  链接：https://leetcode-cn.com/problems/binary-tree-postorder-traversal
 分析： 方法有很多，递归法最简单，迭代法使用栈辅助完成，还有莫里斯遍历。本文讲解官方写的题解迭代法。虽然我也写出了迭代法，但是官方的解法既简单又高效，非常厉害。使用了迭代法+逆向工作法。
思路：  后序遍历是左，右，中。可是中在最后，如果正常解后序遍历的话有的复杂。 如果我们用中，右，左这样来遍历的话岂不是将后序遍历变成了前序遍历的翻版类型。 这样的话答案只是与我们要求的答案相反，翻转一下列表就可以了。 所以解法就是一个反向的先序遍历方法。  代码：  官方的迭代法+逆向工作法
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def postorderTraversal(self, root: TreeNode) -&amp;gt; List[int]: if root is None: return [] stack = [root] res = [] while stack: root = stack.</description>
    </item>
    
    <item>
      <title>132模式</title>
      <link>https://ripple-zjw.github.io/2019/132%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 19 Aug 2019 22:52:15 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/132%E6%A8%A1%E5%BC%8F/</guid>
      <description>题目：132模式 给定一个整数序列：a1, a2, ..., an，一个132模式的子序列ai, aj, ak被定义为：当 i &amp;lt; j &amp;lt; k时，ai &amp;lt; ak &amp;lt; aj。设计一个算法，当给定有 n 个数字的序列时，验证这个序列中是否含有132模式的子序列。 - 注意：n 的值小于15000。
示例1: 输入: [1, 2, 3, 4] 输出: False 解释: 序列中不存在132模式的子序列。  示例 2: 输入: [3, 1, 4, 2] 输出: True 解释: 序列中有 1 个132模式的子序列： [1, 4, 2].  示例 3: 输入: [-1, 3, 2, 0] 输出: True 解释: 序列中有 3 个132模式的的子序列: [-1, 3, 2], [-1, 3, 0] 和 [-1, 2, 0].</description>
    </item>
    
    <item>
      <title>验证二叉树的前序序列化</title>
      <link>https://ripple-zjw.github.io/2019/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96/</link>
      <pubDate>Mon, 19 Aug 2019 22:51:58 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
      <description>题目：验证二叉树的前序序列化 序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。
 _9_ / \ 3 2 / \ / \ 4 1 # 6 / \ / \ / \ # # # # # #   例如，上面的二叉树可以被序列化为字符串 &amp;quot;9,3,4,#,#,1,#,#,2,#,6,#,#&amp;quot;，其中 #代表一个空节点。 给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。 每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 &#39;#&#39; 。 你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如&amp;quot;1,,3&amp;quot;。  示例 1: 输入: &amp;quot;9,3,4,#,#,1,#,#,2,#,6,#,#&amp;quot; 输出: true  示例 2: 输入: &amp;quot;1,#&amp;quot; 输出: false  示例 3: 输入: &amp;quot;9,#,#,1&amp;quot; 输出: false  来源：力扣（LeetCode）第331题  链接：https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree
 分析：  就是每个爸爸都要找到两个儿子。(两个儿子可以是数字也可以是#) #爸爸什么都没有，比较惨。 上面两条任意一条不对都不合法。  思路:  前序遍历严格遵守中，左，右的顺序。 所以第一个为根节点，到第一个#为止，前面这些数字都是根节点的最左边的左子节点 维护一个栈stack，栈中存的是未确认它是否有两个子节点的节点，就是说如果该节点找到了他的两个子节点，就出栈(#也算它的子节点)。 凡是找到数字，全都入栈，因为一开始找到数字，你只能确认它的左子节点是下一个值(数字或#)，无法知道它的右子节点。 当找到第一个#时，开始遍历右子节点。因为没有左子节点了，遍历最近的节点的右子节点，也就是栈顶元素！！！ 一旦遍历了右子节点，那么该节点的左右子节点都找到了，出栈。 接下来继续重复之前的规律，如果字符串合法，那么stack中的元素都被弹出去了，如果栈中还有元素，那么就说明有的元素找不到它的两个儿子。 大概是这么个思路，不过还有些细节要处理。  看我写的代码： class Solution: def isValidSerialization(self, preorder: str) -&amp;gt; bool: if preorder == &#39;&#39;: return False if preorder == &#39;#&#39;: return True pol = preorder.</description>
    </item>
    
    <item>
      <title>移掉K位数字</title>
      <link>https://ripple-zjw.github.io/2019/%E7%A7%BB%E6%8E%89k%E4%BD%8D%E6%95%B0%E5%AD%97/</link>
      <pubDate>Mon, 19 Aug 2019 22:51:46 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%A7%BB%E6%8E%89k%E4%BD%8D%E6%95%B0%E5%AD%97/</guid>
      <description>题目：移掉K位数字 给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。
注意:  num 的长度小于 10002 且 ≥ k。 num 不会包含任何前导零。  示例 1 : 输入: num = &amp;quot;1432219&amp;quot;, k = 3 输出: &amp;quot;1219&amp;quot; 解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。  示例 2 : 输入: num = &amp;quot;10200&amp;quot;, k = 1 输出: &amp;quot;200&amp;quot; 解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。  示例 3 : 输入: num = &amp;quot;10&amp;quot;, k = 2 输出: &amp;quot;0&amp;quot; 解释: 从原数字移除所有的数字，剩余为空就是0。  来源：力扣（LeetCode）第402题  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>字符串解码</title>
      <link>https://ripple-zjw.github.io/2019/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</link>
      <pubDate>Sat, 17 Aug 2019 18:51:43 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</guid>
      <description>题目：字符串解码  给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。  示例: s = &amp;quot;3[a]2[bc]&amp;quot;, 返回 &amp;quot;aaabcbc&amp;quot;. s = &amp;quot;3[a2[c]]&amp;quot;, 返回 &amp;quot;accaccacc&amp;quot;. s = &amp;quot;2[abc]3[cd]ef&amp;quot;, 返回 &amp;quot;abcabccdcdcdef&amp;quot;.  来源：力扣（LeetCode）第394题  链接：https://leetcode-cn.com/problems/decode-string
 分析： 两种方法，辅助栈法和递归法，递归法相对思路清晰，比较好做。其实本质两种方法是一样的，因为函数的递归调用其实也是用栈来实现的。
思路：  递归法：  遍历整个字符串 同时要用到stack列表，tmp列表，还有一个表示下标的变量i 每次递归之后stack都是该函数的stack，与外面的stack不同 每次遍历字符时，tmp都要将里面的值清空 遇到字母，压入stack 遇到]字符,结束函数并将stack返回 遇到数字首先判断该数字后是否还有数字，有的话一起加入tmp，然后递归调用函数。  辅助栈法：  遍历整个字符串 res表示当前字符串，multi表示当前数字，stack储存答案 遇到字母，与res拼接起来 遇到数字，放入multi，注意由于两个数字放在一起要变成两位数，以此类推，所以res 写成res = res * 10 + 当前数字 遇到[，将res，multi同时入栈，用一个列表或元祖，并行的，不是先后入栈。 遇到右括号，栈顶元素出栈，并将栈顶元素的multi与当前字符相乘，然后再与栈顶的res相加   上代码：  递归法：</description>
    </item>
    
    <item>
      <title>下一个更大元素</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0ii/</link>
      <pubDate>Sat, 17 Aug 2019 18:50:56 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0ii/</guid>
      <description>题目：下一个更大元素 II 给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。
示例 1: 输入: [1,2,1] 输出: [2,-1,2] 解释: 第一个 1 的下一个更大的数是 2； 数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。  来源：力扣（LeetCode）第503题  链接：https://leetcode-cn.com/problems/next-greater-element-ii
 分析： 循环数组和循环队列的样子差不多，这道题主要是单调栈，同样涉及两种解法，暴力法和单调栈法。这题的难点不在于单调栈，而是循环数组什么时候停下来。
思路：  由于是循环数组，如果只遍历一遍无法完全找到答案，所以我们遍历两边数组，使得数组较后的元素能与前面的元素比对。 当下表(i)比数组的最后一个下表大时，i % len(数组) 初始化所有答案均为-1(如果找不到最大的是-1，所以先全部等于-1) 维护一个单调递减栈，入栈元素将比它小的栈内元素全部出栈，出栈元素的答案就是入栈元素。 如此循环两次，如果栈内元素在两次循环之后均未能出栈(找到比它大的元素),那么它们就是数组中最大的元素，又由于我们初始化答案全部为-1，所以不用改变它们。  上代码: class Solution(object): def nextGreaterElements(self, nums): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :rtype: List[int] &amp;quot;&amp;quot;&amp;quot; stack = [] n = len(nums) res = [-1 for _ in nums] for i in range(2 * n): while stack and nums[i % n] &amp;gt; nums[stack[-1]]: res[stack.</description>
    </item>
    
    <item>
      <title>扁平化嵌套列表迭代器</title>
      <link>https://ripple-zjw.github.io/2019/%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Sat, 17 Aug 2019 18:50:30 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>题目:扁平化嵌套列表迭代器  给定一个嵌套的整型列表。设计一个迭代器，使其能够遍历这个整型列表中的所有整数。 列表中的项或者为一个整数，或者是另一个列表。  示例 1: 输入: [[1,1],2,[1,1]] 输出: [1,1,2,1,1] 解释: 通过重复调用 next 直到 hasNext 返回false，next 返回的元素的顺序应该是: [1,1,2,1,1]。  示例 2: 输入: [1,[4,[6]]] 输出: [1,4,6] 解释: 通过重复调用 next 直到 hasNext 返回false，next 返回的元素的顺序应该是: [1,4,6]。  来源：力扣（LeetCode）第341题  链接：https://leetcode-cn.com/problems/flatten-nested-list-iterator
 分析： 递归调用，不是很难。唯一要注意的是要看清题目，list里面是NestedIterator，需要使用他给你的方法调用才能得到integer或者list。
思路：  从后往前遍历 判断是否是integer，是 入栈 不是 递归进去 返回栈，结束。  代码： # &amp;quot;&amp;quot;&amp;quot; # This is the interface that allows for creating nested lists. # You should not implement it, or speculate about its implementation # &amp;quot;&amp;quot;&amp;quot; #class NestedInteger(object): # def isInteger(self): # &amp;quot;&amp;quot;&amp;quot; # @return True if this NestedInteger holds a single integer, rather than a nested list.</description>
    </item>
    
    <item>
      <title>二叉树的锯齿形层次遍历</title>
      <link>https://ripple-zjw.github.io/2019/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sat, 17 Aug 2019 18:48:01 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</guid>
      <description>题目: 二叉树的锯齿形层次遍历 给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
例如： 给定二叉树 [3,9,20,null,null,15,7],
 3 / \ 9 20 / \ 15 7  返回锯齿形层次遍历如下：
[ [3], [20,9], [15,7] ]  来源：力扣（LeetCode）第103题  链接：https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal
 分析: 层次遍历比较简单，主要是锯齿形，就是单数层从左到右，双数层从右到左。网上有很多题解，看了他们的之后觉得没有自己的好，他们基本都是使用了反转列表的操作，理论上会很耗时间。所以，我讲的是自己写的思路。
思路:  运用双栈法，分别储存单数层和双数层两种情况。 ans为返回的总列表，res为每一层的答案，stack和helper是两个栈，方法和之前的前、中序遍历差不多。 写一个主循环while，再写两个循环放在主循环中，一个遍历单数层，一个遍历双数层。 两个循环里把双栈中的节点拿出来，同时也把节点的两个子节点(stack或者helper)以及他们的值(res)也存起来。 最后将res的值加到ans中。主循环结束，ans值也都进去了。  代码: # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def zigzagLevelOrder(self, root: TreeNode) -&amp;gt; List[List[int]]: if root is None: return [] stack = [] helper = [root] res = [] ans = [[root.</description>
    </item>
    
    <item>
      <title>二叉搜索树迭代器</title>
      <link>https://ripple-zjw.github.io/2019/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Thu, 15 Aug 2019 16:42:03 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>题目：二叉搜索树迭代器  实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。 调用 next() 将返回二叉搜索树中的下一个最小的数。  示例： BSTIterator iterator = new BSTIterator(root); iterator.next(); // 返回 3 iterator.next(); // 返回 7 iterator.hasNext(); // 返回 true iterator.next(); // 返回 9 iterator.hasNext(); // 返回 true iterator.next(); // 返回 15 iterator.hasNext(); // 返回 true iterator.next(); // 返回 20 iterator.hasNext(); // 返回 false  提示：  next() 和 hasNext() 操作的时间复杂度是 O(1)，并使用O(h)内存，其中 h 是树的高度。 你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 中至少存在一个下一个最小的数。  来源：力扣（LeetCode）第173题  链接：https://leetcode-cn.com/problems/binary-search-tree-iterator</description>
    </item>
    
    <item>
      <title>中序遍历二叉树</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Wed, 14 Aug 2019 13:22:20 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目：二叉树的中序遍历 给定一个二叉树，返回它的中序遍历。
示例: 输入: [1,null,2,3] 1 \ 2 / 3 输出: [1,3,2]   进阶: 递归算法很简单，你可以通过迭代算法完成吗？  来源：力扣（LeetCode）第94题  链接：https://leetcode-cn.com/problems/binary-tree-inorder-traversal
 分析: 两种方法，一种是最常用的递归遍历，非常简单。第二种是迭代遍历，需要用到栈。本文章分析第二种算法。
思路: 维护一个栈，每次经过一个节点，就入栈，当节点的左节点没有值时出栈，并继续从出栈的那个节点找它的右节点。
 维护一个栈stack和要储存答案的列表ans 写一个循环，不停地将左节点一层一层的入栈 当左节点为None时，不要入栈，并且将栈顶节点弹出 拿到栈顶节点的value，并且进入该节点的右节点（因为中序遍历是左，中，右） 继续拿这个节点的左节点，重复2-4步 当节点值为None 或者 stack为空时结束循环  代码： # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def inorderTraversal(self, root: TreeNode) -&amp;gt; List[int]: stack = [] ans = [] tail = root while tail is not None or stack: while tail is not None: stack.</description>
    </item>
    
    <item>
      <title>使括号有效的最少添加</title>
      <link>https://ripple-zjw.github.io/2019/%E4%BD%BF%E6%8B%AC%E5%8F%B7%E6%9C%89%E6%95%88%E7%9A%84%E6%9C%80%E5%B0%91%E6%B7%BB%E5%8A%A0/</link>
      <pubDate>Wed, 14 Aug 2019 13:22:20 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%BD%BF%E6%8B%AC%E5%8F%B7%E6%9C%89%E6%95%88%E7%9A%84%E6%9C%80%E5%B0%91%E6%B7%BB%E5%8A%A0/</guid>
      <description>题目： 给定一个由 &amp;rsquo;(&amp;lsquo; 和 &amp;rsquo;)&amp;lsquo; 括号组成的字符串 S，我们需要添加最少的括号（ &amp;lsquo;(&amp;lsquo; 或是 &amp;rsquo;)&amp;lsquo;，可以在任何位置），以使得到的括号字符串有效。
从形式上讲，只有满足下面几点之一，括号字符串才是有效的：
 它是一个空字符串，或者 它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者 它可以被写作 (A)，其中 A 是有效字符串。 给定一个括号字符串，返回为使结果字符串有效而必须添加的最少括号数。   示例 1：
输入：&amp;quot;())&amp;quot; 输出：1  示例 2：
输入：&amp;quot;(((&amp;quot; 输出：3  示例 3：
输入：&amp;quot;()&amp;quot; 输出：0  示例 4：
输入：&amp;quot;()))((&amp;quot; 输出：4   来源：力扣（LeetCode）第921题  链接：https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid
 题目解析： 这题不是很难，比较容易就能想到，只要使用栈就能做出。在这里不讨论栈的方法，而是官方给出的一种更加巧妙和特别的方法，平衡法。
解题思路： 维护两个变量ans(answer)和bal(balance)，ans是正常的结果，而bal则是题目可能发生的一种特殊情况。比如&amp;rdquo;)))(((&amp;ldquo;这种情况。这个答案应该是六，而不是0，因为右括号在前面，而左括号在后面，这就导致他们无法作为一对有效的括号。如果我们不用bal这个变量的话，应该是这样子的。
先遍历整个字符串，如果是左括号的话，ans加一，如果是右括号的话，ans减一。看似这样做没什么毛病，但是就像我刚才举得例子，当右括号在左括号的前面或者又括号比左括号多，都会出问题，那怎么办呢？这时，我们bal变量就能派上用场。（可能有人会说用个绝对值就行了，同样是上面那个例子，你会发现用绝对值还是不行！！！！）
还是刚才的思路，只是我们思考一下，如果右括号在前面或者右括号比左括号多的话，会导致ans的值为负数（出现了一次负数也是负数，不管它后面会不会变为正数）。一旦变成了负数（其实就是ans为-1，因为ans只有+1或-1的操作），那那个右括号一定是需要添加的括号，因为他一定是无效的括号。ans存的应该是需要添加的左括号和有效的两个括号，由于有效的两个括号一加一减没了，所以本质上就是存的无效左括号的次数，所以我们要把无效右括号的次数存在bal里面，同时为了不让右括号的-1导致左括号的次数不对，所以当ans值为-1时，bal要加一，同时ans也要加一，即相当于把ans的负数放在bal中。最后，我们只要将ans和bal相加即可得出答案。
简单理解： 维护ans和bal两个变量，ans存的是无效的左括号，同时当左括号的后面找到右括号后，左括号变为有效，那么ans就减一，如果右括号太多，左括号都是有效的，那么就有了无效的右括号，把他存在bal里面，同时将它离开ans，也就是ans+1（因为右括号是-1，+1相当于ans-（-1）），这样子一左一右即可以使两边平衡，最后的答案只要把ans和bal（无效左括号和无效右括号）加起来就行了。
Talk is cheap, show me the code.</description>
    </item>
    
    <item>
      <title>双指针</title>
      <link>https://ripple-zjw.github.io/2019/%E5%8F%8C%E6%8C%87%E9%92%88/</link>
      <pubDate>Wed, 14 Aug 2019 13:22:20 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%8F%8C%E6%8C%87%E9%92%88/</guid>
      <description>运用双指针解题 参考题目：LeetCode（26、27题）  https://leetcode-cn.com/problemset/all/
 使用场景： 需要遍历一个数组，在遍历过程中根据要求改变数组中元素的值、位置等一些关系。我们可以使用两个指针进行求解。
例如：删除数组中的重复项，移除摸一个元素
双指针使用思路： 一个数（i）作为已经过滤了的标记，另一个数（j）去寻找不符合条件的数，找到之后将两个元素进行交换。这样当j完全遍历一遍时，就可以把不符合要求的数都放到后面去，i之前的数都是符合规范的数。这种思路和插入排序很像，都是将一个指针作为排好序的部分，只不过插入排序还需要将排好序的部分再遍历一遍，把新的值插入进去。
使用双指针的好处： 首先使用双指针是原地排序，不会需要额外的储存空间，空间复杂度是O（1）。而且被过滤的数并没有被移除，只是与后面符合要求的数进行交换，这样虽然是删除了这个数，但是不需要进行数据的搬移操作，大大节省了时间。
c语言代码：（LeetCode 26题） int removeDuplicates(int* nums, int numsSize){ if(numsSize==0) return 0; int i, j; for(j = 1, i = 0; j &amp;lt; numsSize; j++){ if(nums[i] != nums[j]){ i++; nums[i] = nums[j]; } } return i + 1; }  python代码：（LeetCode 27题） class Solution: def removeElement(self, nums: List[int], val: int) -&amp;gt; int: i = 0 for j in range(len(nums)): if nums[j] !</description>
    </item>
    
    <item>
      <title>最小栈</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%80%E5%B0%8F%E6%A0%88/</link>
      <pubDate>Wed, 14 Aug 2019 13:22:20 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%80%E5%B0%8F%E6%A0%88/</guid>
      <description>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈：  push(x) &amp;ndash; 将元素 x 推入栈中。 pop() &amp;ndash; 删除栈顶的元素。 top() &amp;ndash; 获取栈顶元素。 getMin() &amp;ndash; 检索栈中的最小元素。  来源：力扣（LeetCode）第155题  链接：https://leetcode-cn.com/problems/min-stack
 题目解析： 这道题需要用到一个辅助栈来帮忙，较为暴力的方法是使用python的内置函数min直接算出最小值，或者遍历整个栈将最小值算出。但是题目要求getMin的时间复杂度是常数级的，也就是O（1）。因此上述的方法行不通，需要奇妙的运用到栈的特性来解题。
解题思路： 首先要有两个栈，一个是正常的数据栈（stack），另一个是只存最小值的辅助栈（minStack）。数据栈正常进，出数据，辅助栈在每次进栈和出栈时要判断。如果push的值比辅助栈的栈顶元素要小（或者相等），那么就把它压入辅助栈。同理，如果pop的值比辅助栈的栈顶元素要小（或者相等），那么就讲辅助栈的栈顶元素弹出。
为什么要这样做呢？
其实这很好理解。第一个入栈的元素进栈后，最小值肯定就是它，所以将它放入辅助栈，让它成为判断的目标。如果有比第一个入栈的元素大的元素进栈的话，那其实不用管它们，因为最小值不可能是它们，所以不用把它们放进辅助栈中。如果有栈的元素小于第一个入栈的元素的话，那么就只需要将小于的元素压入辅助栈中，使其成为栈顶元素。如此一来，我们就改变判断的目标，将后面push的元素与这个元素进行比较，直到辅助栈又有一个比它小的元素进栈。
出栈也是一个道理，只要出栈的元素比辅助栈的栈顶元素小或相等的话。就将辅助栈的栈顶元素弹出。
这么一来其实就很明朗了。辅助栈的栈顶元素永远都是最小的元素，而整个辅助栈的元素的值从上自下依次在逐渐变大，直到栈底元素，也就是数据栈中第一个入栈的元素。如果有元素比数据栈的栈底元素大的话，根本不用考虑，因为在出栈的过程中，它们永远都会比数据栈的栈底元素先出栈，所以它们直到数据栈中的数据弹光也不可能作为最小值。那么就不用放入栈中。
简单理解： 使用两个栈，一个用于正常存储数据（stack），另一个用于把可能作为最小值的数据从大到小依次压入栈（minStack），也就是把每次比minStack的栈顶元素小的数压入minStack。
然后pop操作的时候，只要关注一下当前栈的最小值有没有被弹出去，有的话minStack也要出栈。
getMin的值就是辅助栈的最小值
时间复杂度： 非常短，只要进行依次获取栈顶元素的操作即可。为O（1）
实现代码：（Python） class MinStack: def __init__(self): self.stack = [] self.minStack = [] def push(self, x: int) -&amp;gt; None: if len(self.minStack) == 0 or x &amp;lt;= self.minStack[-1]: self.minStack.append(x) self.stack.append(x) def pop(self) -&amp;gt; None: if self.</description>
    </item>
    
    <item>
      <title>栈实现队列</title>
      <link>https://ripple-zjw.github.io/2019/%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</link>
      <pubDate>Wed, 14 Aug 2019 13:22:20 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</guid>
      <description>使用栈实现队列的下列操作：  push(x) &amp;ndash; 将一个元素放入队列的尾部。 pop() &amp;ndash; 从队列首部移除元素。 peek() &amp;ndash; 返回队列首部的元素。 empty() &amp;ndash; 返回队列是否为空。  来源：力扣（LeetCode） 第232题  链接：https://leetcode-cn.com/problems/implement-queue-using-stacks
 题目解析： 这道题想要通过很容易，使用Python的话由于python的列表不仅就是一个现成的栈，而且Python的列表还支持栈所不支持的操作，比如队列的操作，但是时间复杂度可不低，所以Python还有一个双端列表，它可以支持从两端插入并且时间复杂度都是O（1）
可是如果这样做的话和题目本身的意思有点不相符。如果只能使用栈的操作，即只能在列表的最后进行插入和删除以及取值，就需要使用到双栈来模拟队列的操作。具体的操作方法有很多，在这里只记录LeetCode上最高效的方法。
解题思路： 我们声明两个栈，一个是In，另一个是Out。In代表每次push到栈内的元素，而Out代表pop和peek所取得的元素。
首先，将push的元素都依次存放在In栈中。直到进行了一次pop或peek操作后，将In栈中的所有元素依次出栈，再把它们依次放进Out栈中，这样Out栈的栈顶元素就是我们所要取的元素，也就是队首元素。
如果又有元素入队，那么In栈就继续进栈，如果又有元素出队，那么Out栈就继续弹出。
可是，当Out栈中的元素都取完后，就不能再从Out栈中弹出元素了，这个时候，就需要从In栈中继续刚才的步骤，把In栈中的元素取出来放到Out栈里去，然后再去取元素。因此，在进行pop和peek操作时，务必要记得判断当前的Out栈内是否还有剩余的元素，如果没有了，可不能再出栈了，以免报错。
简单理解： 就是拿出两个栈，一个用于进队（In），一个用于出队（Out），如果出队的栈没有元素了，就再从进队的栈中把元素搬过来。
时间复杂度： 使用这种方法，用摊还分析法来计算的话时间复杂度无论是进队还是出队都是O（1），非常的高效。因为最好情况下push就是简单的进栈操作，而pop也是出栈操作。最坏情况下，push不变，而pop则需要将In栈中的所有元素都搬进来，时间复杂度为O（n）。平均一下即O（1）
下面是代码演示（Python） class MyQueue: def __init__(self): self.stackIn = [] self.stackOut = [] def push(self, x: int) -&amp;gt; None: self.stackIn.append(x) def pop(self) -&amp;gt; int: if self.stackOut: return self.stackOut.pop() while self.stackIn: self.stackOut.append(self.stackIn.pop()) return self.stackOut.pop() def peek(self) -&amp;gt; int: if self.stackOut: return self.</description>
    </item>
    
    <item>
      <title>滑动窗口问题</title>
      <link>https://ripple-zjw.github.io/2019/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 14 Aug 2019 13:22:20 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98/</guid>
      <description>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: &amp;quot;abcabcbb&amp;quot; 输出: 3 解释: 因为无重复字符的最长子串是 &amp;quot;abc&amp;quot;，所以其长度为 3。  示例 2: 输入: &amp;quot;bbbbb&amp;quot; 输出: 1 解释: 因为无重复字符的最长子串是 &amp;quot;b&amp;quot;，所以其长度为 1。  示例 3: 输入: &amp;quot;pwwkew&amp;quot; 输出: 3 解释: 因为无重复字符的最长子串是 &amp;quot;wke&amp;quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&amp;quot;pwke&amp;quot; 是一个子序列，不是子串。  来源：力扣（LeetCode）第三题  链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters
 这是一个典型的滑动窗口问题。 解题思路：什么是滑动窗口？ 其实就是一个队列,比如例题中的 abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当再进入 a，队列变成了 abca，这时候不满足要求。所以，我们要移动这个队列！
如何移动？ 我们只要把队列的左边的元素移出就行了，直到满足题目要求！ 一直维持这样的队列，找出队列出现最长的长度时候，求出解！ 时间复杂度：O(n)
这样做的时间复杂度会大幅度降低！！！！
代码如下：（Python）
class Solution: def lengthOfLongestSubstring(self, s: str) -&amp;gt; int: Max_len = 0 string = set() if len(s) == 1: # 字符串只有一个，直接返回，不要在算下去了 return 1 i = 0 for char in s: while char in string: # 如果遍历到一个已经有了的字符，说明这一段字符串结束，将其全部出队，从下一个不重复的字符开始重新运算。 if Max_len &amp;lt; len(string): # 该段字符串的长度如果比之前的大，那么就代替要返回的值，否则全部扔掉。 Max_len = len(string) string.</description>
    </item>
    
    <item>
      <title>表现良好的最长时间段</title>
      <link>https://ripple-zjw.github.io/2019/%E8%A1%A8%E7%8E%B0%E8%89%AF%E5%A5%BD%E7%9A%84%E6%9C%80%E9%95%BF%E6%97%B6%E9%97%B4%E6%AE%B5/</link>
      <pubDate>Wed, 14 Aug 2019 13:22:20 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E8%A1%A8%E7%8E%B0%E8%89%AF%E5%A5%BD%E7%9A%84%E6%9C%80%E9%95%BF%E6%97%B6%E9%97%B4%E6%AE%B5/</guid>
      <description>题目：  给你一份工作时间表hours，上面记录着某一位员工每天的工作小时数。 我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「劳累的一天」。 所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 大于「不劳累的天数」。 请你返回「表现良好时间段」的最大长度。  来源：力扣（LeetCode）第1124题  链接：https://leetcode-cn.com/problems/longest-well-performing-interval
 题目解析： 这题可以使用暴力法O(n^2),二分法O(nlogn),以及借助单调栈来实现O(n),使用暴力法由于时间太长而无法通过，使用单调栈的思路可以借鉴LeetCode上浏览第一的思路（虽然并不是最优解决方案）。
题目的意思其实就是说从给定的数组中找一段数组，这段数组大于8的元素比小于等于8的元素多，而且是最长的一段。 &amp;gt; 传送门：https://leetcode-cn.com/problems/longest-well-performing-interval/solution/qian-zhui-he-dan-diao-zhan-python3-by-smoon1989/
解题思路： 根据题意，所谓最大表现良好的时间段其实就是包括两个重要的条件。再这之前，我们要把大于8的元素变为1，小于等于8的元素变为-1，使用for循环就能搞定。
两个条件： 1. 所求的这一段数组他们的总和大于0（不能等于0） 1. 所求的数组是在满足上一个条件的情况下长度最长的数组
首先先来解释一下这两个条件吧。第一个的意思是所求的数组里1的元素要比-1的多，这样他们的总和肯定是大于0的。符合题意。
第二个的意思是在这些数组中（数组内的元素是可以重复的）找出最长的那个数组，因为题目要求我们找出最长的那个时间段而不是所有表现良好的时间段。
先要找到最长的和大于0的数组，我们需要找到所有可能组成和大于0的数组，然后再比较他们的大小，得出答案。
怎么找呢？我们需要引入前缀和这一概念，顾名思义前缀和就是从第一个开始到某一个元素（可以是任意元素只要不是最后一个元素，因为最后一个元素也算上的话就相当于整个元素了）为止，这一段元素的和。
为什么要找前缀和呢？因为我们如果用整个元素减去这个数组中每一个前缀和（第一个，第一个加第二个，第一加第二加第三个，……）那么得到的就是这个数组中除去当前前缀后剩下的元素。然后计算他们的和，大于0（符合题意）就把它存起来，如果不大于0，那就把数组中最后一个去掉，再计算和，直到计算到前缀和的最后那个元素。这就表示当前前缀和的所有大于0的元素都计算完了。最长的那个也拿到了，再计算下一段前缀和中的元素是否有符合题意并且比我们从上一段前缀和中拿到的那个长度要长，如果有，就替换它。直到前缀和的长度比你储存的那个最大长度要小，那么剩下的无论怎样都不可能超过这段长度，就可以停止计算了。
但是这样会有一个问题，并不是所有的前缀和我们都要计算，很多的前缀和其实根本不可能有。比如一个前缀和要比数组的总长度和要大，那么你用小元素减去大元素那肯定是负的，再比如当前前缀和算完后，它的后面（距离它有一段距离）有一段比当前前缀和大1的元素，但是中间的前缀和都是比他们两大的，那么就没有必要考虑，因为随着前缀和的推移，总会遇到与他们的和一样的前缀和，这个时候去计算这些前缀和就行了，因为这些前缀和的长度要比之前看到的那些长度要长。
其实很明显了，我们只要再维护一个栈，这个栈中存储的是从0开始，顺序递减的前缀和的下标，比如前缀和会是0，-1，-2，-3，当然下标不一定是连着的，但前缀和的差值一定是连着的。我们修改前面的规则，每次检查的都是这个栈中的前缀和，从栈顶开始。
简单理解： 这题没法很快就理解，需要思考一段时间。
总的来说，首先要计算数组中每一个前缀和（别忘了第一个是从0开始的，也就是0个元素的前缀），然后维护一个栈，也是从0开始，遍历刚才的前缀和，让栈保持递减的原则，将符合的前缀和的下标依次入栈。（注意是下标，因为前缀和相等的有很多，你必须储存下标才能准确的知道你存的是哪个值），最后再用刚才的方法算出结果。
时间复杂度： O(n)
代码实现：（Python） class Solution: def longestWPI(self, hours: List[int]) -&amp;gt; int: n = len(hours) persum = [0] stack = [0] res = 0 for hour in hours: if hour &amp;gt; 8: res += 1 persum.</description>
    </item>
    
    <item>
      <title>逆向工作法</title>
      <link>https://ripple-zjw.github.io/2019/%E9%80%86%E5%90%91%E5%B7%A5%E4%BD%9C%E6%B3%95/</link>
      <pubDate>Wed, 14 Aug 2019 13:22:20 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E9%80%86%E5%90%91%E5%B7%A5%E4%BD%9C%E6%B3%95/</guid>
      <description>逆向工作法：  逆向工作法，就是逆向思维，通过将问题反向思考求解。 逆向工作法用到了栈的思想，但不需要栈也能实现。  例题： 给定一个编码字符串 S。为了找出解码字符串并将其写入磁带，从编码字符串中每次读取一个字符，并采取以下步骤：
 如果所读的字符是字母，则将该字母写在磁带上。 如果所读的字符是数字（例如 d），则整个当前磁带总共会被重复写 d-1 次。 现在，对于给定的编码字符串 S 和索引 K，查找并返回解码字符串中的第 K 个字母。  示例 1： 输入：S = &amp;quot;leet2code3&amp;quot;, K = 10 输出：&amp;quot;o&amp;quot; 解释： 解码后的字符串为 &amp;quot;leetleetcodeleetleetcodeleetleetcode&amp;quot;。 字符串中的第 10 个字母是 &amp;quot;o&amp;quot;。  示例 2： 输入：S = &amp;quot;ha22&amp;quot;, K = 5 输出：&amp;quot;h&amp;quot; 解释： 解码后的字符串为 &amp;quot;hahahaha&amp;quot;。第 5 个字母是 &amp;quot;h&amp;quot;。  示例 3： 输入：S = &amp;quot;a2345678999999999999999&amp;quot;, K = 1 输出：&amp;quot;a&amp;quot; 解释： 解码后的字符串为 &amp;quot;a&amp;quot; 重复 8301530446056247680 次。第 1 个字母是 &amp;quot;a&amp;quot;。  提示： 2 &amp;lt;= S.</description>
    </item>
    
  </channel>
</rss>