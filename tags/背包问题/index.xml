<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>背包问题 on LeaveIt</title>
    <link>https://ripple-zjw.github.io/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</link>
    <description>Recent content in 背包问题 on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 23 Oct 2019 19:58:28 +0800</lastBuildDate>
    
	<atom:link href="https://ripple-zjw.github.io/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>分割等和子集</title>
      <link>https://ripple-zjw.github.io/2019/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</link>
      <pubDate>Wed, 23 Oct 2019 19:58:28 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</guid>
      <description> 题目：分割等和子集  给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。  注意:  每个数组中的元素不会超过 100 数组的大小不会超过 200  示例 1: 输入: [1, 5, 11, 5] 输出: true 解释: 数组可以分割成 [1, 5, 5] 和 [11].  示例2: 输入: [1, 2, 3, 5] 输出: false 解释: 数组不能分割成两个元素和相等的子集.  来源：力扣（LeetCode）第416题  链接：https://leetcode-cn.com/problems/partition-equal-subset-sum
 分析：  动态规划题 0-1背包问题  代码： class Solution { public boolean canPartition(int[] nums) { int sum = 0; int len = nums.length; for (int num : nums) sum += num; if ((sum &amp;amp; 1) == 1) return false; // 如果是奇数，不可能分割 sum &amp;gt;&amp;gt;= 1; // 要找的答案是总和的一半。 boolean[][] dp = new boolean[len][sum+1]; // i表示nums中从0到i为止，j表示是否能找到和为j的数。 if (nums[0] &amp;lt;= sum) dp[0][nums[0]] = true; // 第一个数放在j上，其他都是false for (int i = 1; i &amp;lt; len; i++) { for (int j = 0; j &amp;lt;= sum; j++) { if (nums[i] &amp;lt;= j) // 两种选择，一种之前就找到了和为j的数，那么现在还是true。 // 如果之前没有找到和为j的数，那么我加上这次的数，要找前一次j-nums[i]的和能不能找到。 dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]]; else // 如果当前nums[i] 大于j的话，之前看它前一次是什么状态现在还是什么状态。 dp[i][j] = dp[i-1][j]; } } return dp[len-1][sum]; } }  </description>
    </item>
    
    <item>
      <title>一和零</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%80%E5%92%8C%E9%9B%B6/</link>
      <pubDate>Wed, 23 Oct 2019 19:21:28 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%80%E5%92%8C%E9%9B%B6/</guid>
      <description>题目： 一和零  在计算机界中，我们总是追求用有限的资源获取最大的收益。 现在，假设你分别支配着 m 个0和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。 你的任务是使用给定的m个0和n 个1，找到能拼出存在于数组中的字符串的最大数量。每个0和1至多被使用一次。  注意:  给定0和1的数量都不会超过100。 给定字符串数组的长度不会超过600。  示例 1: 输入: Array = {&amp;quot;10&amp;quot;, &amp;quot;0001&amp;quot;, &amp;quot;111001&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;},m = 5, n = 3 输出: 4 解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 &amp;quot;10&amp;quot;,&amp;quot;0001&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot; 。  示例 2: 输入: Array = {&amp;quot;10&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;}, m = 1, n = 1 输出: 2 解释: 你可以拼出 &amp;quot;10&amp;quot;，但之后就没有剩余数字了。更好的选择是拼出 &amp;quot;0&amp;quot; 和 &amp;quot;1&amp;quot; 。  来源：力扣（LeetCode）第474题  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>大礼包</title>
      <link>https://ripple-zjw.github.io/2019/%E5%A4%A7%E7%A4%BC%E5%8C%85/</link>
      <pubDate>Tue, 01 Oct 2019 21:49:17 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%A4%A7%E7%A4%BC%E5%8C%85/</guid>
      <description>题目：大礼包  在LeetCode商店中， 有许多在售的物品。 然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。 现给定每个物品的价格，每个大礼包包含物品的清单，以及待购物品清单。请输出确切完成待购清单的最低花费。 每个大礼包的由一个数组中的一组数据描述，最后一个数字代表大礼包的价格，其他数字分别表示内含的其他种类物品的数量。 任意大礼包可无限次购买。  示例 1: 输入: [2,5], [[3,0,5],[1,2,10]], [3,2] 输出: 14 解释: 有A和B两种物品，价格分别为¥2和¥5。 大礼包1，你可以以¥5的价格购买3A和0B。 大礼包2， 你可以以¥10的价格购买1A和2B。 你需要购买3个A和2个B， 所以你付了¥10购买了1A和2B（大礼包2），以及¥4购买2A。  示例 2: 输入: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1] 输出: 11 解释: A，B，C的价格分别为¥2，¥3，¥4. 你可以用¥4购买1A和1B，也可以用¥9购买2A，2B和1C。 你需要买1A，2B和1C，所以你付了¥4买了1A和1B（大礼包1），以及¥3购买1B， ¥4购买1C。 你不可以购买超出待购清单的物品，尽管购买大礼包2更加便宜。  说明:  最多6种物品， 100种大礼包。 每种物品，你最多只需要购买6个。 你不可以购买超出待购清单的物品，即使更便宜。  来源：力扣（LeetCode）第638题  链接：https://leetcode-cn.com/problems/shopping-offers
 分析：  动态规划解法，常规解法需要使用六维数组，实在太麻烦，而且每次的维度还不一样。 使用状压dp的思想，把六维数组归为1维。 因为每一维的长度是0-6，所以我们把这7个数变为一个七进制的数字，但是把它变为10进制存在一个一维数组中。 比如111就是57，它表示a,b,c各有1个。如果是4个1，那就是a,b,c,d各有1个，然后它也有对应的十进制数。 因此，我们把needs中的数看成是一个七进制数，然后把它以十进制表示出来。 比如need如果是121，那么结果是64。那么我们就开辟一个65个的数组。最后把dp[64]返回就是最终答案了。  代码： class Solution { public int shoppingOffers(List&amp;lt;Integer&amp;gt; price, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; special, List&amp;lt;Integer&amp;gt; needs) { int[] Decinal = {1, 7, 49, 343, 2401, 16807, 117649}; // 7的一次方，7的二次方.</description>
    </item>
    
  </channel>
</rss>