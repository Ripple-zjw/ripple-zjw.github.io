<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bfs on LeaveIt</title>
    <link>https://ripple-zjw.github.io/tags/bfs/</link>
    <description>Recent content in bfs on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 09 Nov 2019 21:38:09 +0800</lastBuildDate>
    
	<atom:link href="https://ripple-zjw.github.io/tags/bfs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>树的直径</title>
      <link>https://ripple-zjw.github.io/2019/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</link>
      <pubDate>Sat, 09 Nov 2019 21:38:09 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</guid>
      <description>题目：树的直径  给你这棵「无向树」，请你测算并返回它的「直径」：这棵树上最长简单路径的 边数。 我们用一个由所有「边」组成的数组edges来表示一棵无向树，其中edges[i] = [u, v]表示节点u和v之间的双向边。 树上的节点都已经用{0, 1, ..., edges.length}中的数做了标记，每个节点上的标记都是独一无二的。  示例 1： 输入：edges = [[0,1],[0,2]] 输出：2 解释： 这棵树上最长的路径是 1 - 0 - 2，边数为 2。  示例 2： 输入：edges = [[0,1],[1,2],[2,3],[1,4],[4,5]] 输出：4 解释： 这棵树上最长的路径是 3 - 2 - 1 - 4 - 5，边数为 4。  提示：  0 &amp;lt;=edges.length&amp;lt;10^4 edges[i][0] != edges[i][1] 0 &amp;lt;= edges[i][j] &amp;lt;= edges.length edges会形成一棵无向树  来源：力扣（LeetCode）第5098题  链接：https://leetcode-cn.com/problems/tree-diameter
 分析：  使用两遍bfs 第一遍找到树中最深的节点。 第二遍从这个节点开始，找到它的简单路径有多长。  代码： class Pair { // 存两个值。 int key; // 代表最远的点 int value;// 代表这个点的距离。 } class Solution { int len; public int treeDiameter(int[][] edges) { len = edges.</description>
    </item>
    
    <item>
      <title>穿过迷宫的最少移动次数</title>
      <link>https://ripple-zjw.github.io/2019/%E7%A9%BF%E8%BF%87%E8%BF%B7%E5%AE%AB%E7%9A%84%E6%9C%80%E5%B0%91%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0/</link>
      <pubDate>Tue, 01 Oct 2019 21:43:48 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%A9%BF%E8%BF%87%E8%BF%B7%E5%AE%AB%E7%9A%84%E6%9C%80%E5%B0%91%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0/</guid>
      <description>题目：穿过迷宫的最少移动次数  你还记得那条风靡全球的贪吃蛇吗？ 我们在一个n*n的网格上构建了新的迷宫地图，蛇的长度为 2，也就是说它会占去两个单元格。蛇会从左上角(0, 0)和(0, 1)开始移动。我们用 0 表示空单元格，用 1 表示障碍物。蛇需要移动到迷宫的右下角(n-1, n-2)和(n-1, n-1)。 每次移动，蛇可以这样走：  如果没有障碍，则向右移动一个单元格。并仍然保持身体的水平／竖直状态。 如果没有障碍，则向下移动一个单元格。并仍然保持身体的水平／竖直状态。 如果它处于水平状态并且其下面的两个单元都是空的，就顺时针旋转 90 度。蛇从（(r, c)、(r, c+1)）移动到 （(r, c)、(r+1, c)）。  如果它处于竖直状态并且其右面的两个单元都是空的，就逆时针旋转 90 度。蛇从（(r, c)、(r+1, c)）移动到（(r, c)、(r, c+1)）。   返回蛇抵达目的地所需的最少移动次数。 如果无法到达目的地，请返回-1。  示例 1： 输入：grid = [[0,0,0,0,0,1], [1,1,0,0,1,0], [0,0,0,0,1,1], [0,0,1,0,1,0], [0,1,1,0,0,0], [0,1,1,0,0,0]] 输出：11 解释： 一种可能的解决方案是 [右, 右, 顺时针旋转, 右, 下, 下, 下, 下, 逆时针旋转, 右, 下]。  示例 2： 输入：grid = [[0,0,1,1,1,1], [0,0,0,0,1,1], [1,1,0,0,0,1], [1,1,1,0,0,1], [1,1,1,0,0,1], [1,1,1,0,0,0]] 输出：9  提示：  2 &amp;lt;= n &amp;lt;= 100 0 &amp;lt;= grid[i][j] &amp;lt;= 1 蛇保证从空单元格开始出发。  来源：力扣（LeetCode）第5208题(临时)  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>机器人大冒险</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%A4%A7%E5%86%92%E9%99%A9/</link>
      <pubDate>Tue, 01 Oct 2019 21:40:38 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%A4%A7%E5%86%92%E9%99%A9/</guid>
      <description>题目：机器人大冒险  力扣团队买了一个可编程机器人，机器人初始位置在原点(0, 0)。小伙伴事先给机器人输入一串指令command，机器人就会无限循环这条指令的步骤进行移动。指令有两种：   U: 向y轴正方向移动一格 R: 向x轴正方向移动一格。   不幸的是，在xy平面上还有一些障碍物，他们的坐标用obstacles表示。机器人一旦碰到障碍物就会被损毁。 给定终点坐标(x,y)，返回机器人能否完好地到达终点。如果能，返回true；否则返回false。  示例 1： 输入：command = &amp;quot;URR&amp;quot;, obstacles = [], x = 3, y = 2 输出：true 解释：U(0, 1) -&amp;gt; R(1, 1) -&amp;gt; R(2, 1) -&amp;gt; U(2, 2) -&amp;gt; R(3, 2)。  示例 2： 输入：command = &amp;quot;URR&amp;quot;, obstacles = [[2, 2]], x = 3, y = 2 输出：false 解释：机器人在到达终点前会碰到(2, 2)的障碍物。  示例 3： 输入：command = &amp;quot;URR&amp;quot;, obstacles = [[4, 2]], x = 3, y = 2 输出：true 解释：到达终点后，再碰到障碍物也不影响返回结果。  限制：  2 &amp;lt;= command的长度&amp;lt;= 1000 command由U，R构成，且至少有一个U，至少有一个R 0 &amp;lt;= x &amp;lt;= 1e9,0 &amp;lt;= y &amp;lt;= 1e9 0 &amp;lt;= obstacles的长度&amp;lt;= 1000 obstacles[i]不为原点或者终点  来源：力扣（LeetCode）LCP.</description>
    </item>
    
  </channel>
</rss>