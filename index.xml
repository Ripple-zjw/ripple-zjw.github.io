<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeaveIt on LeaveIt</title>
    <link>https://ripple-zjw.github.io/</link>
    <description>Recent content in LeaveIt on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 10 Sep 2019 22:59:46 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>为运算表达式设计优先级</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7/</link>
      <pubDate>Tue, 10 Sep 2019 22:59:46 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7/</guid>
      <description>

&lt;h1 id=&#34;题目-为运算表达式设计优先级&#34;&gt;题目：为运算表达式设计优先级&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含&lt;code&gt;+&lt;/code&gt;,&lt;code&gt;-&lt;/code&gt;以及&lt;code&gt;*&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;2-1-1&amp;quot;
输出: [0, 2]
解释: 
((2-1)-1) = 0 
(2-(1-1)) = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;2*3-4*5&amp;quot;
输出: [-34, -14, -10, -10, 10]
解释: 
(2*(3-(4*5))) = -34 
((2*3)-(4*5)) = -14 
((2*(3-4))*5) = -10 
(2*((3-4)*5)) = -10 
(((2*3)-4)*5) = 10
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第241题&#34;&gt;来源：力扣（LeetCode）第241题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/different-ways-to-add-parentheses&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/different-ways-to-add-parentheses&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;## 分析：
 - 动态规划+分治算法。
 - 当只有一个运算符时，只有一种情况，当有两个运算符时有两种情况，以此类推。
 - 当有三个运算符时，假设第一个运算符优先级最高，然后剩下三个数有两种情况，将两种情况与其相加，得到答案。接着判断第二个运算符优先级最低时，依次类推。&lt;/p&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from functools import lru_cache  # lru缓存淘汰算法。
class Solution:
    @lru_cache(None)
    def diffWaysToCompute(self, input: str) -&amp;gt; List[int]:
        if input.isdigit():  # 基线条件
            return [int(input)]
        opt = {&#39;-&#39;, &#39;+&#39;, &#39;*&#39;}  # 运算符集合
        ans = []  # 储存答案
        for i, char in enumerate(input):  # 判断每个运算符优先级最低的时候。
            if char in opt:  # 如果是运算符才执行
                left = self.diffWaysToCompute(input[:i])  # 拿到运算符的左边，递归
                right = self.diffWaysToCompute(input[i+1:])  # 拿到运算符的右边，递归
                ans.extend([self.operator(l, r, char) for l in left for r in right])  # 将运算符的左右两边的值按照运算符做运算。left和right拿到的是列表，就像前面说的，如果左边有不止一个运算符时答案也不止一个，右边同理。
        return ans
    def operator(self, l, r, char):  # 根据运算符做运算符操作，char就是运算符。
        if char == &#39;-&#39;:
            return l - r
        elif char == &#39;+&#39;:
            return l + r
        else:
            return l * r
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n!)n为运算符的个数，个人认为&lt;/li&gt;
&lt;li&gt;空间复杂度：实在算不出来了。。。。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>搜索插入位置</title>
      <link>https://ripple-zjw.github.io/2019/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Tue, 10 Sep 2019 22:48:08 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</guid>
      <description>

&lt;h1 id=&#34;搜索插入位置&#34;&gt;搜索插入位置&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;/li&gt;
&lt;li&gt;你可以假设数组中无重复元素。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,3,5,6], 5
输出: 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,3,5,6], 2
输出: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-3&#34;&gt;示例 3:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,3,5,6], 7
输出: 4
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-4&#34;&gt;示例 4:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,3,5,6], 0
输出: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第35题&#34;&gt;来源：力扣（LeetCode）第35题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/search-insert-position&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/search-insert-position&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;两种二分查找模版&#34;&gt;两种二分查找模版：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;target = 要查找的值
left = 0, right = arr.length
while left &amp;lt; right:
    mid = (left + right) &amp;gt;&amp;gt; 1
    // 为了防止数组溢出，也可以写成left + (right - left) &amp;gt;&amp;gt; 1
    if arr[mid] == target:
        return arr[mid]
    elif arr[mid] &amp;gt; target:
        right = mid
    else:
        left = mid + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;target = 要查找的值
left = 0, right = arr.length - 1
while left &amp;lt;= right:
    mid = (left + right) &amp;gt;&amp;gt; 1
    // 为了防止数组溢出，也可以写成left + (right - left) &amp;gt;&amp;gt; 1
    if arr[mid] == target:
        return arr[mid]
    elif arr[mid] &amp;gt; target:
        right = mid - 1
    else:
        left = mid + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def searchInsert(self, nums: List[int], target: int) -&amp;gt; int:
        left = 0
        right = len(nums)
        while left &amp;lt; right:
            mid = (left + right) &amp;gt;&amp;gt; 1
            if nums[mid] == target:
                return mid
            elif nums[mid] &amp;gt; target:
                right = mid
            else:
                left = mid + 1
        return left  # 基本和模版一样，就是如果没有找到的话，就返回left，可以自己推测出来
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left &amp;lt;= right) {
            int mid = left + ((right - left) &amp;gt;&amp;gt; 1);
            if (nums[mid] == target) return mid;
            else if (nums[mid] &amp;lt; target) left = mid + 1;
            else right = mid - 1;
        }
        return left;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(logn) 二分查找&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>使用异或运算判断奇偶性</title>
      <link>https://ripple-zjw.github.io/2019/%E4%BD%BF%E7%94%A8%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E5%88%A4%E6%96%AD%E5%A5%87%E5%81%B6%E6%80%A7/</link>
      <pubDate>Tue, 10 Sep 2019 22:46:51 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%BD%BF%E7%94%A8%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E5%88%A4%E6%96%AD%E5%A5%87%E5%81%B6%E6%80%A7/</guid>
      <description>

&lt;h1 id=&#34;使用异或运算判断奇偶性&#34;&gt;使用异或运算判断奇偶性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;原理是通过异或运算中的一个数与自己本身异或得到0，与0异或得到自己。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;解释&#34;&gt;解释：&lt;/h2&gt;

&lt;p&gt;比如说有一组数组&lt;code&gt;[1, 1, 1, 1]&lt;/code&gt;
我们使用异或判断&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;ans = [1, 1, 1, 1]
parity = ans[0]  # 拿出第一个数
for i in ans[1:]:  # 从数组的第二个数开始循环
    parity ^= i
parity == 1  # 如果等于1说明1有奇数个，如果等于0说明1有偶数个。例如1^1=0 0^1=1
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>使用最小花费爬楼梯</title>
      <link>https://ripple-zjw.github.io/2019/%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</link>
      <pubDate>Tue, 10 Sep 2019 22:45:45 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</guid>
      <description>

&lt;h1 id=&#34;题目-使用最小花费爬楼梯&#34;&gt;题目：使用最小花费爬楼梯&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值&lt;code&gt;cost[i]&lt;/code&gt;(索引从0开始)。&lt;/li&gt;
&lt;li&gt;每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。&lt;/li&gt;
&lt;li&gt;您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: cost = [10, 15, 20]
输出: 15
解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出: 6
解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;注意&#34;&gt;注意：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cost&lt;/code&gt;的长度将会在&lt;code&gt;[2, 1000]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;每一个&lt;code&gt;cost[i]&lt;/code&gt; 将会是一个Integer类型，范围为&lt;code&gt;[0, 999]&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第746题&#34;&gt;来源：力扣（LeetCode）第746题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/min-cost-climbing-stairs&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/min-cost-climbing-stairs&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;可以使用递归或者动态规划来解这道题。&lt;/li&gt;
&lt;li&gt;思路是如果要跳到第&lt;code&gt;i&lt;/code&gt;个位置，那么就要先跳到&lt;code&gt;i-1&lt;/code&gt;或者是&lt;code&gt;i-2&lt;/code&gt;个位置。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;动态规划：&lt;/li&gt;

&lt;li&gt;&lt;p&gt;python&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def minCostClimbingStairs(self, cost: List[int]) -&amp;gt; int:
    for i in range(2, len(cost)):
        cost[i] = min(cost[i-1], cost[i-2]) + cost[i]  # 你想要跳到第i个位置，就要跳先跳到i-1或i-2个位置。
    return min(cost[-1], cost[-2])  # 决定最后是从倒数第一个位置跳上去，还是倒数第二个位置跳上去。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;java&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
public int minCostClimbingStairs(int[] cost) {
    int n = cost.length;
    for (int i = 2; i &amp;lt; n; i++) {
        cost[i] = Math.min(cost[i-1], cost[i-2]) + cost[i];
    }
    return Math.min(cost[n-1], cost[n-2]);
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;递归：(超时！！！)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Python&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def minCostClimbingStairs(self, cost: List[int]) -&amp;gt; int:
    cost.append(0)
    def recursion(i):
        if i &amp;lt;= 1:
            return cost[i]
        return min(recursion(i - 1), recursion(i - 2)) + cost[i]
    return recursion(len(cost) - 1)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为数组长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1) 几乎用不到额外空间&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>合并两个有序数组</title>
      <link>https://ripple-zjw.github.io/2019/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Tue, 10 Sep 2019 22:44:21 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
      <description>

&lt;h1 id=&#34;题目-合并两个有序数组&#34;&gt;题目：合并两个有序数组&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定两个有序整数数组&lt;code&gt;nums1&lt;/code&gt;和&lt;code&gt;nums2&lt;/code&gt;，将&lt;code&gt;nums2&lt;/code&gt; 合并到&lt;code&gt;nums1&lt;/code&gt;中，使得&lt;code&gt;num1&lt;/code&gt;成为一个有序数组。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;说明&#34;&gt;说明:&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;初始化&lt;code&gt;nums1&lt;/code&gt;和&lt;code&gt;nums2&lt;/code&gt;的元素数量分别为&lt;code&gt;m&lt;/code&gt;和&lt;code&gt;n&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;你可以假设&lt;code&gt;nums1&lt;/code&gt;有足够的空间（空间大小大于或等于&lt;code&gt;m + n&lt;/code&gt;）来保存 &lt;code&gt;nums2&lt;/code&gt; 中的元素。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第88题&#34;&gt;来源：力扣（LeetCode）第88题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/merge-sorted-array&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/merge-sorted-array&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;从后往前放元素，就能解开了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Python&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&amp;gt; None:
    p1 = m - 1  # num1的指针
    p2 = n - 1  # num2的指针
    p = m + n - 1  # num1存放答案的指针
    while p1 &amp;gt;= 0 and p2 &amp;gt;= 0:  # 将两者大的值放进去。
        if nums1[p1] &amp;gt; nums2[p2]:
            nums1[p] = nums1[p1]
            p1 -= 1
        else:
            nums1[p] = nums2[p2]
            p2 -= 1
        p -= 1
    nums1[:p2+1] = nums2[:p2+1]  # 最后将nums2中还没放完的元素放进去。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
public void merge(int[] nums1, int m, int[] nums2, int n) {
    int p1 = m - 1;
    int p2 = n - 1;
    int p = m + n - 1;
    while (p1 &amp;gt;= 0 &amp;amp;&amp;amp; p2 &amp;gt;= 0) {
        if (nums1[p1] &amp;gt; nums2[p2]) {
            nums1[p--] = nums1[p1--];
        } else {
            nums1[p--] = nums2[p2--];
        }
    }
    while (p2 &amp;gt;= 0) nums1[p--] = nums2[p2--];
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;时间复杂度：O(n+m)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;空间复杂度：O(1)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>单调数列</title>
      <link>https://ripple-zjw.github.io/2019/%E5%8D%95%E8%B0%83%E6%95%B0%E5%88%97/</link>
      <pubDate>Tue, 10 Sep 2019 22:42:16 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%8D%95%E8%B0%83%E6%95%B0%E5%88%97/</guid>
      <description>

&lt;h1 id=&#34;题目-单调数列&#34;&gt;题目：单调数列&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;如果数组是单调递增或单调递减的，那么它是单调的。&lt;/li&gt;
&lt;li&gt;如果对于所有&lt;code&gt;i &amp;lt;= j&lt;/code&gt;，&lt;code&gt;A[i] &amp;lt;= A[j]&lt;/code&gt;，那么数组 A 是单调递增的。 如果对于所有&lt;code&gt;i &amp;lt;= j&lt;/code&gt;，&lt;code&gt;A[i]&amp;gt; = A[j]&lt;/code&gt;，那么数组 A 是单调递减的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当给定的数组 A 是单调数组时返回&lt;code&gt;true&lt;/code&gt;，否则返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：[1,2,2,3]
输出：true
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：[6,5,4,4]
输出：true
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-3&#34;&gt;示例 3：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：[1,3,2]
输出：false
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-4&#34;&gt;示例 4：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：[1,2,4,5]
输出：true
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-5&#34;&gt;示例 5：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：[1,1,1]
输出：true
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;提示&#34;&gt;提示：&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;1 &amp;lt;= A.length &amp;lt;= 50000&lt;/li&gt;
&lt;li&gt;-100000 &amp;lt;= A[i] &amp;lt;= 100000&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第896题&#34;&gt;来源：力扣（LeetCode）第896题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/monotonic-array&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/monotonic-array&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;通过大于为1，等于为0，小于为-1判断列表是否单调。&lt;/li&gt;
&lt;li&gt;如果一个数中既出现了1，也出现了-1，那么它不是单调数组。&lt;/li&gt;
&lt;li&gt;有一点要注意，Python2中自带cmp的函数，可以直接判断，而Python3中将cmp函数移除了，所以Python3中需要自己写一个cmp函数，而Python2中不用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Python&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def isMonotonic(self, A: List[int]) -&amp;gt; bool:
    compare = set()
    def cmp(i, j):  # 用于判断的集合
        if i &amp;gt; j:
            return 1
        elif i &amp;lt; j:
            return -1
        else:
            return 0
    for i in range(len(A) - 1):
        compare.add(cmp(A[i], A[i+1]))
        if 1 in compare and -1 in compare:
            return False
    return True
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
public boolean isMonotonic(int[] A) {
    Set&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;Integer&amp;gt;();
    for (int i = 0; i &amp;lt; A.length - 1; i++) {
        int num = Integer.compare(A[i], A[i+1]);
        set.add(num);
        if (set.contains(1) &amp;amp;&amp;amp; set.contains(-1)) {
            return false;
        }
    }
    return true;
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为数组的长度。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>数组的度</title>
      <link>https://ripple-zjw.github.io/2019/%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%A6/</link>
      <pubDate>Fri, 06 Sep 2019 20:27:15 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%A6/</guid>
      <description>

&lt;h1 id=&#34;题目-数组的度&#34;&gt;题目：数组的度&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个非空且只包含非负数的整数数组&lt;code&gt;nums&lt;/code&gt;, 数组的度的定义是指数组里任一元素出现频数的最大值。&lt;/li&gt;
&lt;li&gt;你的任务是找到与&lt;code&gt;nums&lt;/code&gt;拥有相同大小的度的最短连续子数组，返回其长度。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1, 2, 2, 3, 1]
输出: 2
解释: 
输入数组的度是2，因为元素1和2的出现频数最大，均为2.
连续子数组里面拥有相同度的有如下所示:
[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
最短连续子数组[2, 2]的长度为2，所以返回2.
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,2,2,3,1,4,2]
输出: 6
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;注意&#34;&gt;注意:&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nums.length&lt;/code&gt;在1到50,000区间范围内。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nums[i]&lt;/code&gt;是一个在0到49,999范围内的整数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第697题&#34;&gt;来源：力扣（LeetCode）第697题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/degree-of-an-array&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/degree-of-an-array&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;找到每一个元素的第一个下标和最后一个下标。&lt;/li&gt;
&lt;li&gt;然后找出出现频率最高的元素。&lt;/li&gt;
&lt;li&gt;答案就是频率最高的元素的最后一个下标减去第一个下标。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findShortestSubArray(self, nums: List[int]) -&amp;gt; int:
        left, right, count = {}, {}, {}
        for i in range(len(nums)):
            if nums[i] not in left:  # 将第一个下标保存
                left[nums[i]] = i
            right[nums[i]] = i  # 将最后一个下标保存
            count[nums[i]] = count.get(nums[i], 0) + 1  # 累加每个元素出现的频率
        maxCnt = max(count.values())  # 找出最大值
        ans = len(nums)
        for x in count:
            if count[x] == maxCnt:  # 找到最大值的第一个下标和最后一个下标，由于可能出现最高的次数一样的情况，所以要比较所有出现次数最大的元素的长度，再看哪个最小。
                ans = min(ans, right[x] - left[x] + 1)
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为nums的长度。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n) n取决于nums中有多少不重复的数。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>图片平滑器</title>
      <link>https://ripple-zjw.github.io/2019/%E5%9B%BE%E7%89%87%E5%B9%B3%E6%BB%91%E5%99%A8/</link>
      <pubDate>Fri, 06 Sep 2019 20:26:04 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%9B%BE%E7%89%87%E5%B9%B3%E6%BB%91%E5%99%A8/</guid>
      <description>

&lt;h1 id=&#34;题目-图片平滑器&#34;&gt;题目：图片平滑器&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;包含整数的二维矩阵M表示一个图片的灰度。&lt;/li&gt;
&lt;li&gt;你需要设计一个平滑器来让每一个单元的灰度成为平均灰度(向下舍入) ，平均灰度的计算是周围的8个单元和它本身的值求平均，如果周围的单元格不足八个，则尽可能多的利用它们。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入:
[[1,1,1],
 [1,0,1],
 [1,1,1]]
输出:
[[0, 0, 0],
 [0, 0, 0],
 [0, 0, 0]]
解释:
对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0
对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0
对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;注意&#34;&gt;注意:&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;给定矩阵中的整数范围为 [0, 255]。&lt;/li&gt;
&lt;li&gt;矩阵的长和宽的范围均为 [1, 150]。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第661题&#34;&gt;来源：力扣（LeetCode）第661题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/image-smoother&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/image-smoother&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;可以一个一个判断，但是不好，另一种方法，先把八个方向放在一个列表中，然后每次遍历这八个方向。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def imageSmoother(self, M: List[List[int]]) -&amp;gt; List[List[int]]:
        ans = []
        directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]  # 生成八个方向的列表。
        height = len(M)
        width = len(M[0])
        for i in range(height):
            tmp = []
            for j in range(width):
                res = M[i][j]
                cnt = 1
                for direction in directions:
                    y = direction[0] + i
                    x = direction[1] + j
                    if y &amp;lt; height and x &amp;lt; width and x &amp;gt;= 0 and y &amp;gt;= 0:  # 每次都要判断方向是否合法，防止数组越界。
                        res += M[y][x]
                        cnt += 1
                tmp.append(res // cnt)
            ans.append(tmp)
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为M的长度和宽度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>两数之和II 输入有序数组</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8Cii-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Fri, 06 Sep 2019 20:24:19 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8Cii-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
      <description>

&lt;h1 id=&#34;题目-两数之和-ii-输入有序数组&#34;&gt;题目：两数之和 II - 输入有序数组&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个已按照升序排列的有序数组，找到两个数使得它们相加之和等于目标数。&lt;/li&gt;
&lt;li&gt;函数应该返回这两个下标值 index1 和 index2，其中&lt;code&gt;index1&lt;/code&gt;必须小于&lt;code&gt;index2&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;说明&#34;&gt;说明:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;返回的下标值（index1 和 index2）不是从零开始的。
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第167题&#34;&gt;来源：力扣（LeetCode）第167题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;方法有：hash表，二分查找，双指针。&lt;/p&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;hash表:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def twoSum(self, numbers: List[int], target: int) -&amp;gt; List[int]:
    hashTable = {}
    for i in range(len(numbers)):
        if hashTable.get(target - numbers[i]) is not None:
            return hashTable[target - numbers[i]] + 1, i + 1
        hashTable[numbers[i]] = i
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;二分查找:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def twoSum(self, numbers: List[int], target: int) -&amp;gt; List[int]:
    for i in range(len(numbers)):
        ans = target - numbers[i]
        k = len(numbers) - 1
        j = i + 1
        while j &amp;lt;= k:
            mid = (j + k) // 2
            if numbers[mid] == ans:
                return i + 1, mid + 1
            elif numbers[mid] &amp;lt; ans:
                j = mid + 1
            else:
                k = mid - 1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;双指针:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def twoSum(self, numbers: List[int], target: int) -&amp;gt; List[int]:
    i = 0
    j = len(numbers) - 1
    while i &amp;lt; j:
        _sum = numbers[i] + numbers[j]
        if target == _sum:
            return i + 1, j + 1
        elif target &amp;lt; _sum:
            j -= 1
        else:
            i += 1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;hash表：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为数组长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;二分查找：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(nlogn)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;双指针：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为数组长度的一半&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>缺失数字</title>
      <link>https://ripple-zjw.github.io/2019/%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97/</link>
      <pubDate>Fri, 06 Sep 2019 20:21:39 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97/</guid>
      <description>

&lt;h1 id=&#34;题目-缺失数字&#34;&gt;题目：缺失数字&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个包含&lt;code&gt;0, 1, 2, ..., n&lt;/code&gt;中&lt;em&gt;n&lt;/em&gt; 个数的序列，找出 &lt;em&gt;0 .. n&lt;/em&gt; 中没有出现在序列中的那个数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [3,0,1]
输出: 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [9,6,4,2,3,5,7,0,1]
输出: 8
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;说明&#34;&gt;说明:&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第268题&#34;&gt;来源：力扣（LeetCode）第268题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/missing-number&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/missing-number&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;使用排序和哈希可以很容易做出来，但是不符合题意O(1)的空间复杂度。还有两种方法，一种是位运算，另一种是通过数学定理来解题。&lt;/p&gt;

&lt;h2 id=&#34;位运算解题&#34;&gt;位运算解题：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;异或运算的性质：

&lt;ul&gt;
&lt;li&gt;异或运算（XOR）满足结合律，并且对一个数进行两次完全相同的异或运算会得到原来的数。&lt;/li&gt;
&lt;li&gt;比如：&lt;code&gt;a ^ b ^ b == a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;任意一个数对0进行异或运算，等于它原来的数。&lt;/li&gt;
&lt;li&gt;比如：&lt;code&gt;a ^ 0 == a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;任意一个数对它本身进行异或运算，等于0.&lt;/li&gt;
&lt;li&gt;比如：&lt;code&gt;a ^ a  == 0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;因此，在&lt;code&gt;0-n&lt;/code&gt;个数的数组中必定缺少一个数。我们把数组的下标和数组中的数进行异或运算，所有的数都会找到下标相等的数，只有缺失的那个数字找不到，最后算出来的结果就是那个缺失的数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def missingNumber(self, nums: List[int]) -&amp;gt; int:
        ans = len(nums)  # 由于数组没有长度为nums长度的下标，因为从0开始索引的，所以我们要先加上去。
        for i in range(len(nums)):
            ans ^= i ^ nums[i]
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;数学定理解题&#34;&gt;数学定理解题：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;等差数列求和公式：

&lt;ul&gt;
&lt;li&gt;n * (n+1) / 2&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;我们把从0到数组最后的下标累加，再加上数组的长度。&lt;/li&gt;
&lt;li&gt;再把数组中的所有元素累加。&lt;/li&gt;
&lt;li&gt;然后两个相减，最后得到的就是缺失的数字。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码-1&#34;&gt;代码：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def missingNumber(self, nums: List[int]) -&amp;gt; int:
        n = len(nums)
        return n * (n + 1) // 2 - sum(nums)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;两种方法复杂度一样：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>找到所有数组中消失的数字</title>
      <link>https://ripple-zjw.github.io/2019/%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Fri, 06 Sep 2019 20:19:35 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>

&lt;h1 id=&#34;题目-找到所有数组中消失的数字&#34;&gt;题目：找到所有数组中消失的数字&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个范围在&lt;code&gt;1 ≤ a[i] ≤ n&lt;/code&gt; (&lt;code&gt;n&lt;/code&gt; = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。&lt;/li&gt;
&lt;li&gt;找到所有在 [1, n] 范围之间没有出现在数组中的数字。&lt;/li&gt;
&lt;li&gt;您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入:
[4,3,2,7,8,2,3,1]

输出:
[5,6]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第448题&#34;&gt;来源：力扣（LeetCode）第448题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;有多种方法，第一种是用抽屉原理和异或运算的方式交换值。第二种是一种更为巧妙的方式。&lt;/p&gt;

&lt;h3 id=&#34;使用异或运算交换两个值的方法&#34;&gt;使用异或运算交换两个值的方法：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;a = a ^ b
b = a ^ b
a = a ^ b
这样就可以在不使用第三个变量的前提下交换两个变量的值。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;抽屉原理&#34;&gt;抽屉原理：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;如果每个抽屉代表一个集合，每一个苹果就可以代表一个元素，假如有 n + 1 个元素放到 n 个集合中去，其中必定有一个集合里至少有两个元素。” 抽屉原理有时也被称为鸽巢原理。它是组合数学中一个重要的原理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;思路&#34;&gt;思路：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;第一种：

&lt;ul&gt;
&lt;li&gt;遍历整个数组，从第一个开始&lt;code&gt;i&lt;/code&gt;，不停地把这个位置上的元素&lt;code&gt;i&lt;/code&gt;与它的值所对应的下标位置上的元素进行交换。&lt;/li&gt;
&lt;li&gt;一旦当前遍历的这个位置上的元素&lt;code&gt;i&lt;/code&gt;与它值所对应的下标位置上的元素相等，那么就遍历数组的下一个元素&lt;code&gt;i&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;这样的目的是，要么当前位置上&lt;code&gt;i&lt;/code&gt;存的是正确的位置，比如&lt;code&gt;i = 0&lt;/code&gt;的位置上存的是&lt;code&gt;1&lt;/code&gt;，因为数组中的元素是从&lt;code&gt;1&lt;/code&gt;开始的；要么当前位置&lt;code&gt;i&lt;/code&gt;上存的是出现了两次的元素。&lt;/li&gt;
&lt;li&gt;这样最后判断每个元素的值是否是其下标+1。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第二种：

&lt;ul&gt;
&lt;li&gt;遍历整个数组，将该元素的值所对应的下标位置的值变为负数。&lt;/li&gt;
&lt;li&gt;遍历完后，如果数组中还有位置上的值是正数，那么说明没有值等于该位置的下标，即数组中没有遍历到这个值。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;两种方法的代码&#34;&gt;两种方法的代码：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一种：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def findDisappearedNumbers(self, nums: List[int]) -&amp;gt; List[int]:
    for i in range(len(nums)):
        while nums[i] != nums[nums[i] - 1]:  # 一直交换，直到值正确或者这个值出现了两次。
            tmp = nums[i] - 1  # 临时储存，如果用函数可以不写这个。
            if i == tmp:  # 如果两个值相等不能用异或交换，否则一个值会为0
                break
            nums[i] = nums[i] ^ nums[tmp]  # 异或交换
            nums[tmp] = nums[i] ^ nums[tmp]
            nums[i] = nums[i] ^ nums[tmp]
    return [i+1 for i in range(len(nums)) if i+1 != nums[i]]  # 返回正确位置的值
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第二种：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def findDisappearedNumbers(self, nums: List[int]) -&amp;gt; List[int]:
    for i in range(len(nums)):
        nums[abs(nums[i]) - 1] = -abs(nums[abs(nums[i]) - 1])  # 把当前值所对应的下标上的值变为负数，需要注意的是可能这个值已经是负数了，比如有的值出现了两次，所以要加绝对值。
    return [i + 1 for i in range(len(nums)) if nums[i] &amp;gt; 0]  # 把大于0的数返回
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>组合总和</title>
      <link>https://ripple-zjw.github.io/2019/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</link>
      <pubDate>Fri, 06 Sep 2019 20:18:05 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</guid>
      <description>

&lt;h1 id=&#34;题目-组合总和&#34;&gt;题目：组合总和&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个无重复元素的数组&lt;code&gt;candidates&lt;/code&gt;和一个目标数&lt;code&gt;target&lt;/code&gt;，找出&lt;code&gt;candidates&lt;/code&gt;中所有可以使数字和为&lt;code&gt;target&lt;/code&gt;的组合。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;candidates&lt;/code&gt;中的数字可以无限制重复被选取。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;说明&#34;&gt;说明：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;所有数字（包括 target）都是正整数。
解集不能包含重复的组合。 
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: candidates = [2,3,6,7], target = 7,
所求解集为:
[
  [7],
  [2,2,3]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: candidates = [2,3,5], target = 8,
所求解集为:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode&#34;&gt;来源：力扣（LeetCode）&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/combination-sum&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/combination-sum&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;回溯算法+栈，这是我的做法，看到很多算法高手的思路和方法都很棒，有用回溯的，有用dp的。&lt;/p&gt;

&lt;h3 id=&#34;我放上两个比较好的题解&#34;&gt;我放上两个比较好的题解:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;回溯算法：
&amp;gt; &lt;a href=&#34;https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;动态规划：
&amp;gt; &lt;a href=&#34;https://leetcode-cn.com/problems/combination-sum/solution/chao-qiang-gifzhu-ni-shi-yong-dong-tai-gui-hua-qiu/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/combination-sum/solution/chao-qiang-gifzhu-ni-shi-yong-dong-tai-gui-hua-qiu/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;思路&#34;&gt;思路：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;回溯算法一般都用递归来完成。最好的方法是画递归树。&lt;/li&gt;
&lt;li&gt;通过对每一层的递归，将所有等于target的答案全部都得到。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def combinationSum(self, candidates: List[int], target: int) -&amp;gt; List[List[int]]:
        ans = []
        def recursion(cand, i):
            for j in range(i, len(candidates)):
                stack.append(candidates[j])
                res = candidates[j] + cand
                if res &amp;gt;= target:
                    if res == target:
                        ans.append(stack[:])
                    stack.pop()
                    continue
                else:
                    recursion(res, j)
                    stack.pop()
        for i in range(len(candidates)):
            stack = [candidates[i]]
            if candidates[i] &amp;lt; target:
                recursion(candidates[i], i)
            elif candidates[i] == target:
                ans.append(stack)
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n!) 个人认为&lt;/li&gt;
&lt;li&gt;空间复杂度：O(target) 个人认为&lt;code&gt;target&lt;/code&gt;是主要影响答案数量的，当&lt;code&gt;target&lt;/code&gt;变大时，最终返回的数量会非常多。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>复写零</title>
      <link>https://ripple-zjw.github.io/2019/%E5%A4%8D%E5%86%99%E9%9B%B6/</link>
      <pubDate>Fri, 06 Sep 2019 20:16:32 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%A4%8D%E5%86%99%E9%9B%B6/</guid>
      <description>

&lt;h1 id=&#34;题目-复写零&#34;&gt;题目：复写零&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给你一个长度固定的整数数组&lt;code&gt;arr&lt;/code&gt;，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。&lt;/li&gt;
&lt;li&gt;注意：请不要在超过该数组长度的位置写入元素。&lt;/li&gt;
&lt;li&gt;要求：请对输入的数组就地进行上述修改，不要从函数返回任何东西。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：[1,0,2,3,0,4,5,0]
输出：null
解释：调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：[1,2,3]
输出：null
解释：调用函数后，输入的数组将被修改为：[1,2,3]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;提示&#34;&gt;提示：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= arr.length &amp;lt;= 10000&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= arr[i] &amp;lt;= 9&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第1089题&#34;&gt;来源：力扣（LeetCode）第1089题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/duplicate-zeros&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/duplicate-zeros&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;这道题的难点在于要在原数组上操作，不可以申请新的数组。因此，快慢双指针就派上用场了。&lt;/p&gt;

&lt;h2 id=&#34;思路&#34;&gt;思路：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;声明两个指针&lt;code&gt;i&lt;/code&gt;,&lt;code&gt;j&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一个指针正常遍历&lt;code&gt;i&lt;/code&gt;，另一个&lt;code&gt;j&lt;/code&gt;遇到&lt;code&gt;0&lt;/code&gt;就往前再+1&lt;/li&gt;
&lt;li&gt;遍历完之后&lt;code&gt;i&lt;/code&gt;之后的数都是被移出去的，&lt;code&gt;j&lt;/code&gt;指针在最后一位&lt;/li&gt;
&lt;li&gt;依次将&lt;code&gt;i&lt;/code&gt;指针的元素赋在&lt;code&gt;j&lt;/code&gt;的位置，遇到0，&lt;code&gt;j&lt;/code&gt;不仅要将&lt;code&gt;i&lt;/code&gt;的值赋上，还要往前一位再赋上0。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;双指针法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def duplicateZeros(self, arr: List[int]) -&amp;gt; None:
    i = j = 0
    n = len(arr)
    while j &amp;lt; n:
        if arr[i] == 0:
            j += 1
        i += 1
        j += 1
    i -= 1
    j -= 1
    while i &amp;gt;= 0:
        if j &amp;lt; n:
            arr[j] = arr[i]
        if arr[i] == 0:
            j -= 1
            arr[j] = 0
        j -= 1
        i -= 1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;非原地解法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def duplicateZeros(self, arr: List[int]) -&amp;gt; None:
    i = 0
    while i &amp;lt; len(arr):
        if arr[i] == 0:
            arr.insert(i, 0)
            arr.pop()
            i += 1
        i += 1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为数组的长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>数组的相对排序</title>
      <link>https://ripple-zjw.github.io/2019/%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Fri, 30 Aug 2019 19:27:49 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/</guid>
      <description>

&lt;h1 id=&#34;题目-数组的相对排序&#34;&gt;题目：数组的相对排序&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给你两个数组，&lt;code&gt;arr1&lt;/code&gt; 和&lt;code&gt;arr2&lt;/code&gt;，

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;arr2&lt;/code&gt;中的元素各不相同&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arr2&lt;/code&gt; 中的每个元素都出现在&lt;code&gt;arr1&lt;/code&gt;中&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对&lt;code&gt;arr1&lt;/code&gt;中的元素进行排序，使arr1中项的相对顺序和&lt;code&gt;arr2&lt;/code&gt;中的相对顺序相同。&lt;/li&gt;
&lt;li&gt;未在&lt;code&gt;arr2&lt;/code&gt;中出现过的元素需要按照升序放在&lt;code&gt;arr1&lt;/code&gt;的末尾。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
输出：[2,2,2,1,4,3,3,9,6,7,19]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;提示&#34;&gt;提示：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;arr1.length, arr2.length&lt;/code&gt; &amp;lt;= 1000&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= &lt;code&gt;arr1[i], arr2[i]&lt;/code&gt; &amp;lt;= 1000&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arr2&lt;/code&gt;中的元素&lt;code&gt;arr2[i]&lt;/code&gt;各不相同&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arr2&lt;/code&gt; 中的每个元素&lt;code&gt;arr2[i]&lt;/code&gt;都出现在&lt;code&gt;arr1&lt;/code&gt;中&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第1122题&#34;&gt;来源：力扣（LeetCode）第1122题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/relative-sort-array&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/relative-sort-array&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;最近一直在做数组的题目，这种题一眼就想到了计数排序，唯一的不同就是在排序的时候要按arr2的顺序排。&lt;/li&gt;
&lt;li&gt;我的代码是遍历了两边，第一遍是遍历arr2，第二遍遍历整个排序，如果你有更好的计数排序方法，欢迎你告诉我。&lt;/li&gt;
&lt;li&gt;不知道你们有没有遇到过计数排序，我尽可能的把注释写的详细一点，好给没接触过的人参考一下。（反正多遇到几次就写的很熟了）&lt;/li&gt;
&lt;li&gt;其实就是用到了hash表。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -&amp;gt; List[int]:
        arr = [0 for _ in range(1001)]  # 由于题目说arr1的范围在0-1000，所以生成一个1001大小的数组用来存放每个数出现的次数。
        ans = []  # 储存答案的数组。
        for i in range(len(arr1)):  # 遍历arr1，把整个arr1的数的出现次数储存在arr上，arr的下标对应arr1的值，arr的值对应arr1中值出现的次数。
            arr[arr1[i]] += 1  # 如果遇到了这个数，就把和它值一样的下标位置上+1，表示这个数在这个下标i上出现了1次。
        for i in range(len(arr2)):  # 遍历arr2，现在开始要输出答案了。
            while arr[arr2[i]] &amp;gt; 0:  # 如果arr2的值在arr所对应的下标位置出现次数大于0，那么就说明arr中的这个位置存在值。
                ans.append(arr2[i])  # 如果存在值，那就把它加到ans中，因为要按arr2的顺序排序。
                arr[arr2[i]] -= 1  # 加进去了次数 -1 ，不然就死循环了。
        for i in range(len(arr)):  # 如果arr1的值不在arr2中，那么不能就这么结束了，因为题目说了如果不在，剩下的值按照升序排序。
            while arr[i] &amp;gt; 0:  # 同样也是找到大于0的下标，然后一直加到ans中，直到次数为0。
                ans.append(i)
                arr[i] -= 1
        return ans  # 返回最终答案。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n+m) n 为arr2的长度，m为arr1的长度。arr的长度固定是1001，所以就算arr中只有1个有次数,也要遍历1001遍。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n) n 为arr1的长度。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>杨辉三角</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</link>
      <pubDate>Fri, 30 Aug 2019 19:22:10 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</guid>
      <description>

&lt;h1 id=&#34;题目-杨辉三角&#34;&gt;题目：杨辉三角&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。&lt;/li&gt;
&lt;li&gt;在杨辉三角中，每个数是它左上方和右上方的数的和。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://ripple-zjw.github.io/images/杨辉三角/PascalTriangleAnimated2.gif&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第118题&#34;&gt;来源：力扣（LeetCode）第118题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/pascals-triangle&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/pascals-triangle&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;这题可以使用动态规划，是一道非常简单的题目。我们可以把所要求的值看成是前一行的两个值的相加，而且这两个值的位置是有规律的。&lt;/p&gt;

&lt;h2 id=&#34;思路&#34;&gt;思路：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;两个循环，第一遍遍历所有的层。&lt;/li&gt;
&lt;li&gt;第二遍遍历每一层中的值。&lt;/li&gt;
&lt;li&gt;每一层中的值只有第一个和最后一个是1，其他的值都是前一行的前一个位置和现在的位置的和。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def generate(self, numRows: int) -&amp;gt; List[List[int]]:
        ans = []
        for i in range(numRows):
            numRow = [1 for _ in range(i + 1)]
            for j in range(1, i):
                numRow[j] = ans[i-1][j-1] + ans[i-1][j]
            ans.append(numRow)
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n^2^) n 为numRows&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n^2^)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>