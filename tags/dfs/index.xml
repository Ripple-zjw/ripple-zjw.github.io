<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>dfs on LeaveIt</title>
    <link>https://ripple-zjw.github.io/tags/dfs/</link>
    <description>Recent content in dfs on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 09 Nov 2019 21:46:25 +0800</lastBuildDate>
    
	<atom:link href="https://ripple-zjw.github.io/tags/dfs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>最后一块石头的重量II</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8Fii/</link>
      <pubDate>Sat, 09 Nov 2019 21:46:25 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8Fii/</guid>
      <description>题目：最后一块石头的重量 II  有一堆石头，每块石头的重量都是正整数。 每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为x和y，且x&amp;lt;= y。那么粉碎的可能结果如下：  如果x == y，那么两块石头都会被完全粉碎； 如果x != y，那么重量为x的石头将会完全粉碎，而重量为y的石头新重量为y-x。  最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。  示例： 输入：[2,7,4,1,8,1] 输出：1 解释： 组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]， 组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]， 组合 2 和 1，得到 1，所以数组转化为 [1,1,1]， 组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。  提示：  1 &amp;lt;= stones.length &amp;lt;= 30 1 &amp;lt;= stones[i] &amp;lt;= 1000  来源：力扣（LeetCode）第1049题  链接：https://leetcode-cn.com/problems/last-stone-weight-ii
 分析：  这道题一开始看好像没有什么思路，我们不妨把问题抽象出来。 题目要求最后把两块石头撞完后，剩下的重量要最小。那我们怎么才能让重量最小呢？这是关键点。 我们发现，只要每次相撞的两块石头，他们的大小都差不多，那么他们相撞之后得到的重量肯定是最小的。 因此，我们不妨把整个石子分成两块，只要我们把这两堆石子分的重量越接近，那么撞出来的重量一定会最小。 有人可能会想如果两边石子的数量不一样怎么办？不管两边数量有多不平衡，你都可以用一堆去撞另一堆，一定会把其中一堆装完的。 至此，我们把目的改一改，我们现在要找出两堆石子，他们的重量最接近。 如何找呢？ 我们把所有石子的重量和算一下，然后除以一半，最好的情况下正好分成了两堆重量一样的石子，直接撞完就等于0了。 如果不行呢？ 我们把石子的总重量叫sum,把一半的重量叫half。 我们一定能找到其中一堆小于half的(不管这一堆长度是多少，一定能找到),那么另一堆的重量肯定是大于half的。 所以我们只要找到一堆越接近half就行了，如果等于half最好。 参考LeetCode第416题，分割等和子集。 我们这次不是要分割等和子集，而是要找到越接近half的子集。 设置两个状态，见第一个代码。第一个是当前的位置，第二个是求得的和。 每次判断当前的和是否达到，有两种选择，使用这个位置，或者不使用这个位置。 进阶：我们可以使用dfs改写这段dp，从half开始，依次往0判断能否组成这个和，如果能那么这个和就是最大和。dfs更加快，因为只要找到最大和就直接返回答案就行了，不用再算下去。 进阶2：我们把dp变为一维dp，去掉当前位置的状态，只保留求得的和，问题转化为一个经典的0-1背包问题。  代码：  常规二维dp：</description>
    </item>
    
    <item>
      <title>串联字符串的最大长度</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%B2%E8%81%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Sat, 09 Nov 2019 21:35:43 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%B2%E8%81%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6/</guid>
      <description>题目：串联字符串的最大长度  给定一个字符串数组arr，字符串s是将arr 某一子序列字符串连接所得的字符串，如果s 中的每一个字符都只出现过一次，那么它就是一个可行解。 请返回所有可行解s中最长长度。  示例 1： 输入：arr = [&amp;quot;un&amp;quot;,&amp;quot;iq&amp;quot;,&amp;quot;ue&amp;quot;] 输出：4 解释：所有可能的串联组合是 &amp;quot;&amp;quot;,&amp;quot;un&amp;quot;,&amp;quot;iq&amp;quot;,&amp;quot;ue&amp;quot;,&amp;quot;uniq&amp;quot; 和 &amp;quot;ique&amp;quot;，最大长度为 4。  示例 2： 输入：arr = [&amp;quot;cha&amp;quot;,&amp;quot;r&amp;quot;,&amp;quot;act&amp;quot;,&amp;quot;ers&amp;quot;] 输出：6 解释：可能的解答有 &amp;quot;chaers&amp;quot; 和 &amp;quot;acters&amp;quot;。  示例 3： 输入：arr = [&amp;quot;abcdefghijklmnopqrstuvwxyz&amp;quot;] 输出：26  提示：  1 &amp;lt;= arr.length &amp;lt;= 16 1 &amp;lt;= arr[i].length &amp;lt;= 26 arr[i]中只含有小写英文字母  来源：力扣（LeetCode）第1239题  链接：https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters
 分析：  使用位压缩和回溯就可以完成这道题。 每一个字符串我们有两种选择，一种是用这个字符串，另一个是不用这个字符串。 我们用一个int类型的整数代表字符串每一个字符的使用情况。int总共有32位，而小写字母总共有26个，因此我可以把26个字母都存在每一个位上，1代表已经使用了，0代表未使用。 如果用这个字符串，我们就要把当前的字符串长度加上，然后再去往下找下一个字符串。 如果不用这个字符串，我们不用加上当前字符串的长度，只需要找下一个字符串就行了。 然后比较一下两者哪个大。 需要注意的是，如果这个字符不能使用，就是用了会有重复的字符，那么这种情况只有一个选择，就是不用这个字符串。 其实这道题和dp很像，但是由于有一个状态的范围不确定，所以用dp稍有难度。  代码： class Solution { int len; public int maxLength(List&amp;lt;String&amp;gt; arr) { len = arr.</description>
    </item>
    
    <item>
      <title>划分为k个相等的子集</title>
      <link>https://ripple-zjw.github.io/2019/%E5%88%92%E5%88%86%E4%B8%BAk%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AD%90%E9%9B%86/</link>
      <pubDate>Sat, 09 Nov 2019 21:31:18 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%88%92%E5%88%86%E4%B8%BAk%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AD%90%E9%9B%86/</guid>
      <description>题目：划分为k个相等的子集  给定一个整数数组nums和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。  示例 1： 输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4 输出： True 说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。  注意:  1 &amp;lt;= k &amp;lt;= len(nums) &amp;lt;= 16 0 &amp;lt; nums[i] &amp;lt; 10000  来源：力扣（LeetCode）第698题  链接：https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets
 分析：  这道题LeetCode官方给出的标签为dp和递归。 但是好像没有一个人用dp写出来，基本用的都是回溯算法。 由于数据范围不大，就可以穷举所有的可能，如果不对，再回来计算下一种可能。  代码： class Solution { int[] bucket; public boolean canPartitionKSubsets(int[] nums, int k) { if (k == 1) return true; //如果k是1，直接返回true。 int len = nums.</description>
    </item>
    
    <item>
      <title>分汤</title>
      <link>https://ripple-zjw.github.io/2019/%E5%88%86%E6%B1%A4/</link>
      <pubDate>Sat, 09 Nov 2019 21:30:11 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%88%86%E6%B1%A4/</guid>
      <description>题目：分汤  有A和B两种类型的汤。一开始每种类型的汤有N毫升。有四种分配操作： 提供 100ml 的汤A 和 0ml 的汤B。 提供 75ml 的汤A 和 25ml 的汤B。 提供 50ml 的汤A 和 50ml 的汤B。 提供 25ml 的汤A 和 75ml 的汤B。 当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为0.25的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。 注意不存在先分配100 ml汤B的操作。 需要返回的值：汤A先分配完的概率 + 汤A和汤B同时分配完的概率 / 2。  示例: 输入: N = 50 输出: 0.625 解释: 如果我们选择前两个操作，A将首先变为空。 对于第三个操作，A和B会同时变为空。 对于第四个操作，B将首先变为空。 所以A变为空的总概率加上A和B同时变为空的概率的一半是 0.25 *(1 + 1 + 0.5 + 0)= 0.625。  注释:  0 &amp;lt;= N &amp;lt;= 10^9。 返回值在10^-6的范围将被认为是正确的。  来源：力扣（LeetCode）第808题  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>多边形三角剖分的最低得分</title>
      <link>https://ripple-zjw.github.io/2019/%E5%A4%9A%E8%BE%B9%E5%BD%A2%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86%E7%9A%84%E6%9C%80%E4%BD%8E%E5%BE%97%E5%88%86/</link>
      <pubDate>Sat, 09 Nov 2019 21:25:31 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%A4%9A%E8%BE%B9%E5%BD%A2%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86%E7%9A%84%E6%9C%80%E4%BD%8E%E5%BE%97%E5%88%86/</guid>
      <description>题目：多边形三角剖分的最低得分  给定N，想象一个凸N边多边形，其顶点按顺时针顺序依次标记为A[0], A[i], ..., A[N-1]。 假设您将多边形剖分为N-2个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有N-2个三角形的值之和。 返回多边形进行三角剖分后可以得到的最低分。  示例 1： 输入：[1,2,3] 输出：6 解释：多边形已经三角化，唯一三角形的分数为 6。  示例 2： 输入：[3,7,4,5] 输出：144 解释：有两种三角剖分，可能得分分别为：3*7*5 + 4*5*7 = 245，或 3*4*5 + 3*4*7 = 144。最低分数为 144。  示例 3： 输入：[1,3,1,4,1,5] 输出：13 解释：最低分数三角剖分的得分情况为 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13。  提示：  3 &amp;lt;= A.length &amp;lt;= 50 1 &amp;lt;= A[i] &amp;lt;= 100  来源：力扣（LeetCode）第1039题  链接：https://leetcode-cn.com/problems/minimum-score-triangulation-of-polygon
 分析：  可以使用dp或者dfs两种方法(好像很多题我都会这么讲。。。) 这两种方式的思路完全一致，唯一的不同就是一个是递归一个是dp。 我们声明两个状态i，j为从第i个位置开始，到第j个位置为止。 我们发现如果i==j-1的话，是不可能会有答案的，因为中间还要有第三个位置。 至少要i+2==j才行，这样中间才能有一个位置放第三个点。 也就是说如果中间有两个位置，那么第三个点就有两种可能，以此类推。 如果中间有多个位置，我们随便选择其中的一个，一个三角形的三个点就是i,j,k(中间的那个点)，那么另外n-3个三角形的顶点的值要怎么算呢？我们发现除去i,j,k这个三角形外，其他的三角形的值我们在小一维的dp里已经算过了(就是长度比当前长度小1的那些值)。 比如现在我们要找其他的三角形那么其他的三角形的值就是dp[i][k]和dp[k][j]里面，而这两个值肯定已经算过了，因为这两个值所代表的状态肯定比当前状态的长度要小。  代码：  dp</description>
    </item>
    
    <item>
      <title>组合总和</title>
      <link>https://ripple-zjw.github.io/2019/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C4/</link>
      <pubDate>Sat, 09 Nov 2019 21:23:14 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C4/</guid>
      <description>题目：组合总和 Ⅳ  给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。  示例: nums = [1, 2, 3] target = 4 所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) 请注意，顺序不同的序列被视作不同的组合。 因此输出为 7。  进阶：  如果给定的数组中含有负数会怎么样？ 问题会产生什么变化？ 我们需要在题目中添加什么限制来允许负数的出现？  来源：力扣（LeetCode）第377题  链接：https://leetcode-cn.com/problems/combination-sum-iv
 分析：  dp和dfs两种方法。  代码：  dp
class Solution { public int combinationSum4(int[] nums, int target) { int len = nums.length; int[] dp = new int[target+1]; dp[0] = 1; for (int i = 1; i &amp;lt;= target; i++) { for (int num : nums) if (i &amp;gt;= num) dp[i] += dp[i-num]; } return dp[target]; } }  dfs + 记忆化</description>
    </item>
    
    <item>
      <title>目标和</title>
      <link>https://ripple-zjw.github.io/2019/%E7%9B%AE%E6%A0%87%E5%92%8C/</link>
      <pubDate>Sat, 09 Nov 2019 21:14:39 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%9B%AE%E6%A0%87%E5%92%8C/</guid>
      <description>题目：目标和  给定一个非负整数数组，a1, a2, &amp;hellip;, an, 和一个目标数，S。现在你有两个符号+和-。对于数组中的任意一个整数，你都可以从+或-中选择一个符号添加在前面。 返回可以使最终数组和为目标数 S 的所有添加符号的方法数。  示例 1: 输入: nums: [1, 1, 1, 1, 1], S: 3 输出: 5 解释: -1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3 一共有5种方法让最终目标和为3。  注意:  数组非空，且长度不会超过20。 初始的数组的和不会超过1000。 保证返回的最终结果能被32位整数存下。  来源：力扣（LeetCode）第494题  链接：https://leetcode-cn.com/problems/target-sum
 分析：  这是一道动态规划题，也可以使用dfs完成。 此外，还有一种使用数学方法来简化的dp。 常规dp很简单，第一个状态是当前为第几个，第二个状态为当前的和是多少。 我们有两种选择，第一种是当前为+号，那么用当前的和减去当前的值去找上一次的和。 如果当前是-号，就用当前的和加上当前的值去找上一次的和。 然后来看看数学方法简化dp。 设x为其中一个解的正数和，y为其中一个解的负数和的绝对值。 因此我们可以得到两个公式 x + y = sum(sum是整个数组的和) x - y = S(S是目标值) 上下一相加，得x = (sum + S) / 2 因此我们只要知道x有多少种可能就行了 所以问题转化为01背包问题，找到当长度为数组长度时，x有多少种可能。状态直接转为一维。 x也就是符号为正的情况。  代码：  先放上常规dp</description>
    </item>
    
    <item>
      <title>“马”在棋盘上的概率</title>
      <link>https://ripple-zjw.github.io/2019/%E9%A9%AC%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/</link>
      <pubDate>Wed, 23 Oct 2019 20:17:40 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E9%A9%AC%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/</guid>
      <description>题目：“马”在棋盘上的概率  已知一个NxN的国际象棋棋盘，棋盘的行号和列号都是从 0 开始。即最左上角的格子记为(0, 0)，最右下角的记为(N-1, N-1)。 现有一个 “马”（也译作 “骑士”）位于(r, c)，并打算进行K 次移动。 如下图所示，国际象棋的 “马” 每一步先沿水平或垂直方向移动 2 个格子，然后向与之相垂直的方向再移动 1 个格子，共有 8 个可选的位置。  现在 “马” 每一步都从可选的位置（包括棋盘外部的）中独立随机地选择一个进行移动，直到移动了K次或跳到了棋盘外面。 求移动结束后，“马” 仍留在棋盘上的概率。  示例： 输入: 3, 2, 0, 0 输出: 0.0625 解释: 输入的数据依次为 N, K, r, c 第 1 步时，有且只有 2 种走法令 “马” 可以留在棋盘上（跳到（1,2）或（2,1））。对于以上的两种情况，各自在第2步均有且只有2种走法令 “马” 仍然留在棋盘上。 所以 “马” 在结束后仍在棋盘上的概率为 0.0625。  注意：  N 的取值范围为 [1, 25] K 的取值范围为 [0, 100] 开始时，“马” 总是位于棋盘上  来源：力扣（LeetCode）第688题  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>石子游戏II</title>
      <link>https://ripple-zjw.github.io/2019/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8Fii/</link>
      <pubDate>Wed, 23 Oct 2019 19:06:38 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8Fii/</guid>
      <description>题目：石子游戏 II  亚历克斯和李继续他们的石子游戏。许多堆石子排成一行，每堆都有正整数颗石子piles[i]。游戏以谁手中的石子最多来决出胜负。 亚历克斯和李轮流进行，亚历克斯先开始。最初，M = 1。 在每个玩家的回合中，该玩家可以拿走剩下的前X堆的所有石子，其中1 &amp;lt;= X &amp;lt;= 2M。然后，令M = max(M, X)。 游戏一直持续到所有石子都被拿走。 假设亚历克斯和李都发挥出最佳水平，返回亚历克斯可以得到的最大数量的石头。  示例： 输入：piles = [2,7,9,4,4] 输出：10 解释： 如果亚历克斯在开始时拿走一堆石子，李拿走两堆，接着亚历克斯也拿走两堆。在这种情况下，亚历克斯可以拿到 2 + 4 + 4 = 10 颗石子。 如果亚历克斯在开始时拿走两堆石子，那么李就可以拿走剩下全部三堆石子。在这种情况下，亚历克斯可以拿到 2 + 7 = 9 颗石子。 所以我们返回更大的 10。  提示：  1 &amp;lt;= piles.length &amp;lt;= 100 1 &amp;lt;= piles[i] &amp;lt;= 10 ^ 4  来源：力扣（LeetCode）第1140题  链接：https://leetcode-cn.com/problems/stone-game-ii
 分析：  这道题可以采用递归加记忆化搜索的方式进行。 我们需要穷举出所有的状态。 由于重复计算的地方太多，所以使用记忆化搜索，也可以说使用了动态规划。  代码： class Solution { int len; int[] sum;int[][] dp; public int stoneGameII(int[] piles) { dp = new int[150][150]; // dp数组用来存放算过的值。 len = piles.</description>
    </item>
    
    <item>
      <title>黄金矿工</title>
      <link>https://ripple-zjw.github.io/2019/%E9%BB%84%E9%87%91%E7%9F%BF%E5%B7%A5/</link>
      <pubDate>Wed, 23 Oct 2019 18:55:10 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E9%BB%84%E9%87%91%E7%9F%BF%E5%B7%A5/</guid>
      <description>题目：黄金矿工  你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为m*n的网格grid进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。 为了使收益最大化，矿工需要按以下规则来开采黄金： 每当矿工进入一个单元，就会收集该单元格中的所有黄金。 矿工每次可以从当前位置向上下左右四个方向走。 每个单元格只能被开采（进入）一次。 不得开采（进入）黄金数目为 0 的单元格。 矿工可以从网格中任意一个有黄金的单元格出发或者是停止。  示例 1： 输入：grid = [[0,6,0],[5,8,7],[0,9,0]] 输出：24 解释： [[0,6,0], [5,8,7], [0,9,0]] 一种收集最多黄金的路线是：9 -&amp;gt; 8 -&amp;gt; 7。  示例 2： 输入：grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]] 输出：28 解释： [[1,0,7], [2,0,6], [3,4,5], [0,3,0], [9,0,20]] 一种收集最多黄金的路线是：1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 5 -&amp;gt; 6 -&amp;gt; 7。  提示：  1 &amp;lt;= grid.length,grid[i].length &amp;lt;= 15 0 &amp;lt;= grid[i][j] &amp;lt;= 100 最多25个单元格中有黄金。  来源：力扣（LeetCode）第5215题(临时)  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>大礼包</title>
      <link>https://ripple-zjw.github.io/2019/%E5%A4%A7%E7%A4%BC%E5%8C%85/</link>
      <pubDate>Tue, 01 Oct 2019 21:49:17 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%A4%A7%E7%A4%BC%E5%8C%85/</guid>
      <description>题目：大礼包  在LeetCode商店中， 有许多在售的物品。 然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。 现给定每个物品的价格，每个大礼包包含物品的清单，以及待购物品清单。请输出确切完成待购清单的最低花费。 每个大礼包的由一个数组中的一组数据描述，最后一个数字代表大礼包的价格，其他数字分别表示内含的其他种类物品的数量。 任意大礼包可无限次购买。  示例 1: 输入: [2,5], [[3,0,5],[1,2,10]], [3,2] 输出: 14 解释: 有A和B两种物品，价格分别为¥2和¥5。 大礼包1，你可以以¥5的价格购买3A和0B。 大礼包2， 你可以以¥10的价格购买1A和2B。 你需要购买3个A和2个B， 所以你付了¥10购买了1A和2B（大礼包2），以及¥4购买2A。  示例 2: 输入: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1] 输出: 11 解释: A，B，C的价格分别为¥2，¥3，¥4. 你可以用¥4购买1A和1B，也可以用¥9购买2A，2B和1C。 你需要买1A，2B和1C，所以你付了¥4买了1A和1B（大礼包1），以及¥3购买1B， ¥4购买1C。 你不可以购买超出待购清单的物品，尽管购买大礼包2更加便宜。  说明:  最多6种物品， 100种大礼包。 每种物品，你最多只需要购买6个。 你不可以购买超出待购清单的物品，即使更便宜。  来源：力扣（LeetCode）第638题  链接：https://leetcode-cn.com/problems/shopping-offers
 分析：  动态规划解法，常规解法需要使用六维数组，实在太麻烦，而且每次的维度还不一样。 使用状压dp的思想，把六维数组归为1维。 因为每一维的长度是0-6，所以我们把这7个数变为一个七进制的数字，但是把它变为10进制存在一个一维数组中。 比如111就是57，它表示a,b,c各有1个。如果是4个1，那就是a,b,c,d各有1个，然后它也有对应的十进制数。 因此，我们把needs中的数看成是一个七进制数，然后把它以十进制表示出来。 比如need如果是121，那么结果是64。那么我们就开辟一个65个的数组。最后把dp[64]返回就是最终答案了。  代码： class Solution { public int shoppingOffers(List&amp;lt;Integer&amp;gt; price, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; special, List&amp;lt;Integer&amp;gt; needs) { int[] Decinal = {1, 7, 49, 343, 2401, 16807, 117649}; // 7的一次方，7的二次方.</description>
    </item>
    
  </channel>
</rss>