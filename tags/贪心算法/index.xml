<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>贪心算法 on LeaveIt</title>
    <link>https://ripple-zjw.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 贪心算法 on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 09 Nov 2019 21:28:46 +0800</lastBuildDate>
    
	<atom:link href="https://ripple-zjw.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>摆动序列</title>
      <link>https://ripple-zjw.github.io/2019/%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/</link>
      <pubDate>Sat, 09 Nov 2019 21:28:46 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/</guid>
      <description>题目：摆动序列  如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。 例如，[1,7,4,9,2,5]是一个摆动序列，因为差值(6,-3,5,-7,3)是正负交替出现的。相反, [1,4,7,2,5]和[1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。 给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。  示例 1: 输入: [1,7,4,9,2,5] 输出: 6 解释: 整个序列均为摆动序列。  示例 2: 输入: [1,17,5,10,13,15,10,5,16,8] 输出: 7 解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。  示例 3: 输入: [1,2,3,4,5,6,7,8,9] 输出: 2  进阶:  你能否用O(n)时间复杂度完成此题?  来源：力扣（LeetCode）第376题  链接：https://leetcode-cn.com/problems/wiggle-subsequence
 分析：  首先这道题的方法实在是太多了。 我首先使用了二维dp做出了O(n^2)的方法。 一个状态是以数组i为结尾的最优情况，第二个状态是当前是处于递增还是递减状态。 如果是递增状态，那么就是前几次里的递减状态 + 1。 如果是递减状态，那么就是前几次里的递增状态 + 1。 再来说说进阶。 我们发现如果数组把它分为一段递增，一段递减，那么这一段内的所有数的答案都是一样的，因为，都是递减，前一段的最后那个数都比他们大，选哪个都可以，可是一旦选择了一个，这一段里都不能再选择第二个，下一个一定在下一段里。而这一段递增那么下一段就是递减。(所谓一段，就是一段数组内连续的数) 那这每一段内我要选择什么才合适呢？我们发现，如果是递减，我们就选择最小的那个，如果是递增就选择最大的那个。因为如果你选择最小的那个，那么下一个数要比它大，你选择的越小下一个找到比它大的数的可能性就越高，递增同理。 于是乎我们每一段都要贪心的去取最小或最大的数，也就是这一段单调的最后一个数。  代码：  dp
class Solution { public int wiggleMaxLength(int[] nums) { int len = nums.</description>
    </item>
    
    <item>
      <title>分享巧克力</title>
      <link>https://ripple-zjw.github.io/2019/%E5%88%86%E4%BA%AB%E5%B7%A7%E5%85%8B%E5%8A%9B/</link>
      <pubDate>Wed, 23 Oct 2019 19:48:36 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%88%86%E4%BA%AB%E5%B7%A7%E5%85%8B%E5%8A%9B/</guid>
      <description>题目：分享巧克力  你有一大块巧克力，它由一些甜度不完全相同的小块组成。我们用数组sweetness来表示每一小块的甜度。 你打算和K名朋友一起分享这块巧克力，所以你需要将切割K次才能得到K+1块，每一块都由一些 连续的小块组成。 为了表现出你的慷慨，你将会吃掉总甜度最小 的一块，并将其余几块分给你的朋友们。 请找出一个最佳的切割策略，使得你所分得的巧克力总甜度最大，并返回这个 最大总甜度。  示例 1： 输入：sweetness = [1,2,3,4,5,6,7,8,9], K = 5 输出：6 解释：你可以把巧克力分成 [1,2,3], [4,5], [6], [7], [8], [9]。  示例 2： 输入：sweetness = [5,6,7,8,9,1,2,3,4], K = 8 输出：1 解释：只有一种办法可以把巧克力分成 9 块。  示例 3： 输入：sweetness = [1,2,2,1,2,2,1,2,2], K = 2 输出：5 解释：你可以把巧克力分成 [1,2,2], [1,2,2], [1,2,2]。  提示：  0 &amp;lt;= K &amp;lt;sweetness.length&amp;lt;= 10^4 1 &amp;lt;= sweetness[i] &amp;lt;= 10^5  来源：力扣（LeetCode）第5111题(临时)  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>任务调度器</title>
      <link>https://ripple-zjw.github.io/2019/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/</link>
      <pubDate>Fri, 23 Aug 2019 12:52:54 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/</guid>
      <description> 题目：任务调度器  给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。 任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。 CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。 然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。 你需要计算完成所有任务所需要的最短时间。  示例 1： 输入: tasks = [&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;,&amp;quot;B&amp;quot;,&amp;quot;B&amp;quot;,&amp;quot;B&amp;quot;], n = 2 输出: 8 执行顺序: A -&amp;gt; B -&amp;gt; (待命) -&amp;gt; A -&amp;gt; B -&amp;gt; (待命) -&amp;gt; A -&amp;gt; B.  注：  任务的总个数为 [1, 10000]。 n 的取值范围为 [0, 100]。  来源：力扣（LeetCode）第621题  链接：https://leetcode-cn.com/problems/task-scheduler
 分析： 写在队列的标签里，本质上用的却是贪心算法，不知道为什么，同时还用到了一点hashmap的知识。
思路：  要知道最短时间首先要找到出现次数最多的那个值，如果出现次数一样多，选哪个都无所谓。 然后看A-Z中总共有几个数字出现了，假设最多次数的值是A，那么第一个A到第二个A之间总共还能再放n个不一样的值。 A -&amp;gt; (单位时间) -&amp;gt; (单位时间) -&amp;gt; A -&amp;gt; (单位时间) -&amp;gt; (单位时间) -&amp;gt; A 如果填不满那就为等待时间。 如果填满了，那就说明不需要等待时间就能得到最短时间，所以最短时间就是数组的长度。 如果没填满，那么我们可以计算(出现的次数最多的元素 - 1) * (n + 1) + 出现次数一样多的元素的个数 我们依靠出现的次数最多的元素A把整个答案划分为a份(a为A的次数)，每一份就是n+1，由于最后一份不一定是n+1，所以是(a-1)*(n+1)，最后在把不相等的最后一份加进去就得到了答案。  代码： class Solution: def leastInterval(self, tasks: List[str], n: int) -&amp;gt; int: count = [0] * 26 for task in tasks: count[ord(task) - 65] += 1 # 这里是我自己写的简单hash函数，也可以用字典，我这里觉得简单就没用字典。 maxNum = max(count) maxCount = 0 for c in count: if c == maxNum: maxCount += 1 return max((maxNum - 1) * (n + 1) + maxCount, len(tasks))  复杂度分析：  时间复杂度：O(n) n为tasks的长度 空间复杂度：O(1)  总结：  第一次写贪心算法题，标签写错了，本来有想到贪心算法的，可是标签是队列我就一直在想队列，想了半天没有思路。 贪心算法得到的有可能是近似解，在使用贪心算法时要想清楚特殊的情况。  </description>
    </item>
    
  </channel>
</rss>