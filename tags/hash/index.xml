<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>hash on LeaveIt</title>
    <link>https://ripple-zjw.github.io/tags/hash/</link>
    <description>Recent content in hash on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 30 Aug 2019 19:27:49 +0800</lastBuildDate>
    
	<atom:link href="https://ripple-zjw.github.io/tags/hash/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>数组的相对排序</title>
      <link>https://ripple-zjw.github.io/2019/%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Fri, 30 Aug 2019 19:27:49 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/</guid>
      <description>题目：数组的相对排序  给你两个数组，arr1 和arr2，  arr2中的元素各不相同 arr2 中的每个元素都出现在arr1中  对arr1中的元素进行排序，使arr1中项的相对顺序和arr2中的相对顺序相同。 未在arr2中出现过的元素需要按照升序放在arr1的末尾。  示例： 输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6] 输出：[2,2,2,1,4,3,3,9,6,7,19]  提示：  arr1.length, arr2.length &amp;lt;= 1000 0 &amp;lt;= arr1[i], arr2[i] &amp;lt;= 1000 arr2中的元素arr2[i]各不相同 arr2 中的每个元素arr2[i]都出现在arr1中  来源：力扣（LeetCode）第1122题  链接：https://leetcode-cn.com/problems/relative-sort-array
 分析：  最近一直在做数组的题目，这种题一眼就想到了计数排序，唯一的不同就是在排序的时候要按arr2的顺序排。 我的代码是遍历了两边，第一遍是遍历arr2，第二遍遍历整个排序，如果你有更好的计数排序方法，欢迎你告诉我。 不知道你们有没有遇到过计数排序，我尽可能的把注释写的详细一点，好给没接触过的人参考一下。（反正多遇到几次就写的很熟了） 其实就是用到了hash表。  代码： class Solution: def relativeSortArray(self, arr1: List[int], arr2: List[int]) -&amp;gt; List[int]: arr = [0 for _ in range(1001)] # 由于题目说arr1的范围在0-1000，所以生成一个1001大小的数组用来存放每个数出现的次数。 ans = [] # 储存答案的数组。 for i in range(len(arr1)): # 遍历arr1，把整个arr1的数的出现次数储存在arr上，arr的下标对应arr1的值，arr的值对应arr1中值出现的次数。 arr[arr1[i]] += 1 # 如果遇到了这个数，就把和它值一样的下标位置上+1，表示这个数在这个下标i上出现了1次。 for i in range(len(arr2)): # 遍历arr2，现在开始要输出答案了。 while arr[arr2[i]] &amp;gt; 0: # 如果arr2的值在arr所对应的下标位置出现次数大于0，那么就说明arr中的这个位置存在值。 ans.</description>
    </item>
    
    <item>
      <title>任务调度器</title>
      <link>https://ripple-zjw.github.io/2019/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/</link>
      <pubDate>Fri, 23 Aug 2019 12:52:54 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/</guid>
      <description> 题目：任务调度器  给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。 任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。 CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。 然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。 你需要计算完成所有任务所需要的最短时间。  示例 1： 输入: tasks = [&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;,&amp;quot;B&amp;quot;,&amp;quot;B&amp;quot;,&amp;quot;B&amp;quot;], n = 2 输出: 8 执行顺序: A -&amp;gt; B -&amp;gt; (待命) -&amp;gt; A -&amp;gt; B -&amp;gt; (待命) -&amp;gt; A -&amp;gt; B.  注：  任务的总个数为 [1, 10000]。 n 的取值范围为 [0, 100]。  来源：力扣（LeetCode）第621题  链接：https://leetcode-cn.com/problems/task-scheduler
 分析： 写在队列的标签里，本质上用的却是贪心算法，不知道为什么，同时还用到了一点hashmap的知识。
思路：  要知道最短时间首先要找到出现次数最多的那个值，如果出现次数一样多，选哪个都无所谓。 然后看A-Z中总共有几个数字出现了，假设最多次数的值是A，那么第一个A到第二个A之间总共还能再放n个不一样的值。 A -&amp;gt; (单位时间) -&amp;gt; (单位时间) -&amp;gt; A -&amp;gt; (单位时间) -&amp;gt; (单位时间) -&amp;gt; A 如果填不满那就为等待时间。 如果填满了，那就说明不需要等待时间就能得到最短时间，所以最短时间就是数组的长度。 如果没填满，那么我们可以计算(出现的次数最多的元素 - 1) * (n + 1) + 出现次数一样多的元素的个数 我们依靠出现的次数最多的元素A把整个答案划分为a份(a为A的次数)，每一份就是n+1，由于最后一份不一定是n+1，所以是(a-1)*(n+1)，最后在把不相等的最后一份加进去就得到了答案。  代码： class Solution: def leastInterval(self, tasks: List[str], n: int) -&amp;gt; int: count = [0] * 26 for task in tasks: count[ord(task) - 65] += 1 # 这里是我自己写的简单hash函数，也可以用字典，我这里觉得简单就没用字典。 maxNum = max(count) maxCount = 0 for c in count: if c == maxNum: maxCount += 1 return max((maxNum - 1) * (n + 1) + maxCount, len(tasks))  复杂度分析：  时间复杂度：O(n) n为tasks的长度 空间复杂度：O(1)  总结：  第一次写贪心算法题，标签写错了，本来有想到贪心算法的，可是标签是队列我就一直在想队列，想了半天没有思路。 贪心算法得到的有可能是近似解，在使用贪心算法时要想清楚特殊的情况。  </description>
    </item>
    
  </channel>
</rss>