<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>递归 on LeaveIt</title>
    <link>https://ripple-zjw.github.io/tags/%E9%80%92%E5%BD%92/</link>
    <description>Recent content in 递归 on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 01 Oct 2019 21:34:34 +0800</lastBuildDate>
    
	<atom:link href="https://ripple-zjw.github.io/tags/%E9%80%92%E5%BD%92/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>不同的二叉搜索树II</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91ii/</link>
      <pubDate>Tue, 01 Oct 2019 21:34:34 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91ii/</guid>
      <description>题目：不同的二叉搜索树 II  给定一个整数n，生成所有由1...n为节点所组成的二叉搜索树。  示例: 输入: 3 输出: [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ] 解释: 以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3  来源：力扣（LeetCode）第95题  链接：https://leetcode-cn.com/problems/unique-binary-search-trees-ii
 分析：  可以使用递归，但我怕超时就没写。 但是几乎所有的递归都可以转换为动态规划，所以这题用dp求解。 思路和前面找个数一样，状态都是第n个数的内容，选择是谁为根节点。 不一样的是状态转移方程稍稍有点复杂，我在代码中说明。  代码： /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public List&amp;lt;TreeNode&amp;gt; generateTrees(int n) { List&amp;lt;TreeNode&amp;gt;[] dp = new ArrayList[n+1]; dp[0] = new ArrayList(); // 如果left或right为0，就会出现空指针异常。 if (n == 0) return dp[0]; dp[0].</description>
    </item>
    
    <item>
      <title>有序链表转换二叉搜索树</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Sat, 21 Sep 2019 15:50:29 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>题目：有序链表转换二叉搜索树  给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。  示例: 给定的有序链表： [-10, -3, 0, 5, 9], 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5  来源：力扣（LeetCode）第109题  链接：https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree
 分析：  递归 + 快慢双指针  使用快慢指针找出链表的中点。 然后将中点生成树的根。 递归进入左右子树。  模拟遍历中序二叉树  算出链表的长度 把链表一分为二 递归进入链表的左边和右边 同时，在左边递归完后生成父节点 再把递归得到的左右子节点放在父节点的left和right   代码：  递归 + 快慢双指针
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>使用最小花费爬楼梯</title>
      <link>https://ripple-zjw.github.io/2019/%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</link>
      <pubDate>Tue, 10 Sep 2019 22:45:45 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</guid>
      <description>题目：使用最小花费爬楼梯  数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值cost[i](索引从0开始)。 每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。 您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。  示例 1: 输入: cost = [10, 15, 20] 输出: 15 解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。  示例 2: 输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 输出: 6 解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。  注意：  cost的长度将会在[2, 1000]。 每一个cost[i] 将会是一个Integer类型，范围为[0, 999]。  来源：力扣（LeetCode）第746题  链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs
 分析：  可以使用递归或者动态规划来解这道题。 思路是如果要跳到第i个位置，那么就要先跳到i-1或者是i-2个位置。  代码：  动态规划： python
class Solution: def minCostClimbingStairs(self, cost: List[int]) -&amp;gt; int: for i in range(2, len(cost)): cost[i] = min(cost[i-1], cost[i-2]) + cost[i] # 你想要跳到第i个位置，就要跳先跳到i-1或i-2个位置。 return min(cost[-1], cost[-2]) # 决定最后是从倒数第一个位置跳上去，还是倒数第二个位置跳上去。  java</description>
    </item>
    
    <item>
      <title>组合总和</title>
      <link>https://ripple-zjw.github.io/2019/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</link>
      <pubDate>Fri, 06 Sep 2019 20:18:05 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</guid>
      <description>题目：组合总和  给定一个无重复元素的数组candidates和一个目标数target，找出candidates中所有可以使数字和为target的组合。 candidates中的数字可以无限制重复被选取。  说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。  示例 1: 输入: candidates = [2,3,6,7], target = 7, 所求解集为: [ [7], [2,2,3] ]  示例 2: 输入: candidates = [2,3,5], target = 8, 所求解集为: [ [2,2,2,2], [2,3,3], [3,5] ]  来源：力扣（LeetCode）  链接：https://leetcode-cn.com/problems/combination-sum
 分析： 回溯算法+栈，这是我的做法，看到很多算法高手的思路和方法都很棒，有用回溯的，有用dp的。
我放上两个比较好的题解:  回溯算法： &amp;gt; https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/ 动态规划： &amp;gt; https://leetcode-cn.com/problems/combination-sum/solution/chao-qiang-gifzhu-ni-shi-yong-dong-tai-gui-hua-qiu/  思路：  回溯算法一般都用递归来完成。最好的方法是画递归树。 通过对每一层的递归，将所有等于target的答案全部都得到。  代码： class Solution: def combinationSum(self, candidates: List[int], target: int) -&amp;gt; List[List[int]]: ans = [] def recursion(cand, i): for j in range(i, len(candidates)): stack.</description>
    </item>
    
    <item>
      <title>求最大子数组</title>
      <link>https://ripple-zjw.github.io/2019/%E6%B1%82%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</link>
      <pubDate>Fri, 23 Aug 2019 12:57:06 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%B1%82%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</guid>
      <description>题目：求最大子数组  在一个数组中找到和最大的子数组。 数组中有正有负，但都是integer类型。  题目来源：算法导论第38页 4.1 最大子数组问题 分析： 根据书中的问题，采用分治思想来解题。具体可参考算法导论。
思路：  将整个数组一分为二，每次分完之后做四件事件：  查看是否是最小数组即长度是1，因为数组长度是1那么总和就是这一个数的值。 如果不是1，那就分别递归进左边的数组和右边的数组继续分，直到分到1再返回。 每次递归除了左边的最大子数组和右边的最大子数组外，还有交叉在中间的最大子数组。所以要把中间的最大子数组也算出来。 算出三者的各自的和将和最大的那个子数组并返回，同时返回它的两端下标。  每次递归都会返回左边，右边，中间的最大的那个子数组。 最后一次递归返回最大的子数组，答案就出来了。  代码： class FindMaxNum: def _find_crossing(self, A, low, mid, high): # 寻找穿过中间值的最大子数组 leftSum = float(&#39;-inf&#39;) ans = 0 maxLeft = mid maxRight = mid + 1 for i in range(mid, low - 1, -1): # 找到左边的最大子数组 ans += A[i] if ans &amp;gt; leftSum: leftSum = ans maxLeft = i rightSum = float(&#39;-inf&#39;) ans = 0 for j in range(mid + 1, high + 1): # 找到右边的最大子数组 ans += A[j] if ans &amp;gt; rightSum: rightSum = ans maxRight = j return maxLeft, maxRight, leftSum + rightSum # 返回最大的子数组以及它的两端下标 def find_max_num(self, A, low, high): if low == high: # 如果分到了1，那么就返回 return low, high, A[low] else: mid = (low + high) // 2 # 将数组一分为二 left_low, left_high, left_sum = self.</description>
    </item>
    
    <item>
      <title>字符串解码</title>
      <link>https://ripple-zjw.github.io/2019/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</link>
      <pubDate>Sat, 17 Aug 2019 18:51:43 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</guid>
      <description>题目：字符串解码  给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。  示例: s = &amp;quot;3[a]2[bc]&amp;quot;, 返回 &amp;quot;aaabcbc&amp;quot;. s = &amp;quot;3[a2[c]]&amp;quot;, 返回 &amp;quot;accaccacc&amp;quot;. s = &amp;quot;2[abc]3[cd]ef&amp;quot;, 返回 &amp;quot;abcabccdcdcdef&amp;quot;.  来源：力扣（LeetCode）第394题  链接：https://leetcode-cn.com/problems/decode-string
 分析： 两种方法，辅助栈法和递归法，递归法相对思路清晰，比较好做。其实本质两种方法是一样的，因为函数的递归调用其实也是用栈来实现的。
思路：  递归法：  遍历整个字符串 同时要用到stack列表，tmp列表，还有一个表示下标的变量i 每次递归之后stack都是该函数的stack，与外面的stack不同 每次遍历字符时，tmp都要将里面的值清空 遇到字母，压入stack 遇到]字符,结束函数并将stack返回 遇到数字首先判断该数字后是否还有数字，有的话一起加入tmp，然后递归调用函数。  辅助栈法：  遍历整个字符串 res表示当前字符串，multi表示当前数字，stack储存答案 遇到字母，与res拼接起来 遇到数字，放入multi，注意由于两个数字放在一起要变成两位数，以此类推，所以res 写成res = res * 10 + 当前数字 遇到[，将res，multi同时入栈，用一个列表或元祖，并行的，不是先后入栈。 遇到右括号，栈顶元素出栈，并将栈顶元素的multi与当前字符相乘，然后再与栈顶的res相加   上代码：  递归法：</description>
    </item>
    
    <item>
      <title>扁平化嵌套列表迭代器</title>
      <link>https://ripple-zjw.github.io/2019/%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Sat, 17 Aug 2019 18:50:30 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>题目:扁平化嵌套列表迭代器  给定一个嵌套的整型列表。设计一个迭代器，使其能够遍历这个整型列表中的所有整数。 列表中的项或者为一个整数，或者是另一个列表。  示例 1: 输入: [[1,1],2,[1,1]] 输出: [1,1,2,1,1] 解释: 通过重复调用 next 直到 hasNext 返回false，next 返回的元素的顺序应该是: [1,1,2,1,1]。  示例 2: 输入: [1,[4,[6]]] 输出: [1,4,6] 解释: 通过重复调用 next 直到 hasNext 返回false，next 返回的元素的顺序应该是: [1,4,6]。  来源：力扣（LeetCode）第341题  链接：https://leetcode-cn.com/problems/flatten-nested-list-iterator
 分析： 递归调用，不是很难。唯一要注意的是要看清题目，list里面是NestedIterator，需要使用他给你的方法调用才能得到integer或者list。
思路：  从后往前遍历 判断是否是integer，是 入栈 不是 递归进去 返回栈，结束。  代码： # &amp;quot;&amp;quot;&amp;quot; # This is the interface that allows for creating nested lists. # You should not implement it, or speculate about its implementation # &amp;quot;&amp;quot;&amp;quot; #class NestedInteger(object): # def isInteger(self): # &amp;quot;&amp;quot;&amp;quot; # @return True if this NestedInteger holds a single integer, rather than a nested list.</description>
    </item>
    
  </channel>
</rss>