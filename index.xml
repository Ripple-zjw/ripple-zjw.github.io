<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeaveIt on LeaveIt</title>
    <link>https://ripple-zjw.github.io/</link>
    <description>Recent content in LeaveIt on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 06 Sep 2019 20:27:15 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>数组的度</title>
      <link>https://ripple-zjw.github.io/2019/%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%A6/</link>
      <pubDate>Fri, 06 Sep 2019 20:27:15 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%A6/</guid>
      <description>

&lt;h1 id=&#34;题目-数组的度&#34;&gt;题目：数组的度&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个非空且只包含非负数的整数数组&lt;code&gt;nums&lt;/code&gt;, 数组的度的定义是指数组里任一元素出现频数的最大值。&lt;/li&gt;
&lt;li&gt;你的任务是找到与&lt;code&gt;nums&lt;/code&gt;拥有相同大小的度的最短连续子数组，返回其长度。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1, 2, 2, 3, 1]
输出: 2
解释: 
输入数组的度是2，因为元素1和2的出现频数最大，均为2.
连续子数组里面拥有相同度的有如下所示:
[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
最短连续子数组[2, 2]的长度为2，所以返回2.
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,2,2,3,1,4,2]
输出: 6
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;注意&#34;&gt;注意:&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nums.length&lt;/code&gt;在1到50,000区间范围内。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nums[i]&lt;/code&gt;是一个在0到49,999范围内的整数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第697题&#34;&gt;来源：力扣（LeetCode）第697题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/degree-of-an-array&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/degree-of-an-array&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;找到每一个元素的第一个下标和最后一个下标。&lt;/li&gt;
&lt;li&gt;然后找出出现频率最高的元素。&lt;/li&gt;
&lt;li&gt;答案就是频率最高的元素的最后一个下标减去第一个下标。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findShortestSubArray(self, nums: List[int]) -&amp;gt; int:
        left, right, count = {}, {}, {}
        for i in range(len(nums)):
            if nums[i] not in left:  # 将第一个下标保存
                left[nums[i]] = i
            right[nums[i]] = i  # 将最后一个下标保存
            count[nums[i]] = count.get(nums[i], 0) + 1  # 累加每个元素出现的频率
        maxCnt = max(count.values())  # 找出最大值
        ans = len(nums)
        for x in count:
            if count[x] == maxCnt:  # 找到最大值的第一个下标和最后一个下标，由于可能出现最高的次数一样的情况，所以要比较所有出现次数最大的元素的长度，再看哪个最小。
                ans = min(ans, right[x] - left[x] + 1)
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为nums的长度。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n) n取决于nums中有多少不重复的数。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>图片平滑器</title>
      <link>https://ripple-zjw.github.io/2019/%E5%9B%BE%E7%89%87%E5%B9%B3%E6%BB%91%E5%99%A8/</link>
      <pubDate>Fri, 06 Sep 2019 20:26:04 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%9B%BE%E7%89%87%E5%B9%B3%E6%BB%91%E5%99%A8/</guid>
      <description>

&lt;h1 id=&#34;题目-图片平滑器&#34;&gt;题目：图片平滑器&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;包含整数的二维矩阵M表示一个图片的灰度。&lt;/li&gt;
&lt;li&gt;你需要设计一个平滑器来让每一个单元的灰度成为平均灰度(向下舍入) ，平均灰度的计算是周围的8个单元和它本身的值求平均，如果周围的单元格不足八个，则尽可能多的利用它们。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入:
[[1,1,1],
 [1,0,1],
 [1,1,1]]
输出:
[[0, 0, 0],
 [0, 0, 0],
 [0, 0, 0]]
解释:
对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0
对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0
对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;注意&#34;&gt;注意:&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;给定矩阵中的整数范围为 [0, 255]。&lt;/li&gt;
&lt;li&gt;矩阵的长和宽的范围均为 [1, 150]。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第661题&#34;&gt;来源：力扣（LeetCode）第661题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/image-smoother&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/image-smoother&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;可以一个一个判断，但是不好，另一种方法，先把八个方向放在一个列表中，然后每次遍历这八个方向。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def imageSmoother(self, M: List[List[int]]) -&amp;gt; List[List[int]]:
        ans = []
        directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]  # 生成八个方向的列表。
        height = len(M)
        width = len(M[0])
        for i in range(height):
            tmp = []
            for j in range(width):
                res = M[i][j]
                cnt = 1
                for direction in directions:
                    y = direction[0] + i
                    x = direction[1] + j
                    if y &amp;lt; height and x &amp;lt; width and x &amp;gt;= 0 and y &amp;gt;= 0:  # 每次都要判断方向是否合法，防止数组越界。
                        res += M[y][x]
                        cnt += 1
                tmp.append(res // cnt)
            ans.append(tmp)
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为M的长度和宽度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>两数之和II 输入有序数组</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8Cii-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Fri, 06 Sep 2019 20:24:19 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8Cii-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
      <description>

&lt;h1 id=&#34;题目-两数之和-ii-输入有序数组&#34;&gt;题目：两数之和 II - 输入有序数组&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个已按照升序排列的有序数组，找到两个数使得它们相加之和等于目标数。&lt;/li&gt;
&lt;li&gt;函数应该返回这两个下标值 index1 和 index2，其中&lt;code&gt;index1&lt;/code&gt;必须小于&lt;code&gt;index2&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;说明&#34;&gt;说明:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;返回的下标值（index1 和 index2）不是从零开始的。
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第167题&#34;&gt;来源：力扣（LeetCode）第167题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;方法有：hash表，二分查找，双指针。&lt;/p&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;hash表:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def twoSum(self, numbers: List[int], target: int) -&amp;gt; List[int]:
    hashTable = {}
    for i in range(len(numbers)):
        if hashTable.get(target - numbers[i]) is not None:
            return hashTable[target - numbers[i]] + 1, i + 1
        hashTable[numbers[i]] = i
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;二分查找:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def twoSum(self, numbers: List[int], target: int) -&amp;gt; List[int]:
    for i in range(len(numbers)):
        ans = target - numbers[i]
        k = len(numbers) - 1
        j = i + 1
        while j &amp;lt;= k:
            mid = (j + k) // 2
            if numbers[mid] == ans:
                return i + 1, mid + 1
            elif numbers[mid] &amp;lt; ans:
                j = mid + 1
            else:
                k = mid - 1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;双指针:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def twoSum(self, numbers: List[int], target: int) -&amp;gt; List[int]:
    i = 0
    j = len(numbers) - 1
    while i &amp;lt; j:
        _sum = numbers[i] + numbers[j]
        if target == _sum:
            return i + 1, j + 1
        elif target &amp;lt; _sum:
            j -= 1
        else:
            i += 1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;hash表：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为数组长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;二分查找：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(nlogn)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;双指针：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为数组长度的一半&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>缺失数字</title>
      <link>https://ripple-zjw.github.io/2019/%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97/</link>
      <pubDate>Fri, 06 Sep 2019 20:21:39 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97/</guid>
      <description>

&lt;h1 id=&#34;题目-缺失数字&#34;&gt;题目：缺失数字&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个包含&lt;code&gt;0, 1, 2, ..., n&lt;/code&gt;中&lt;em&gt;n&lt;/em&gt; 个数的序列，找出 &lt;em&gt;0 .. n&lt;/em&gt; 中没有出现在序列中的那个数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [3,0,1]
输出: 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [9,6,4,2,3,5,7,0,1]
输出: 8
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;说明&#34;&gt;说明:&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第268题&#34;&gt;来源：力扣（LeetCode）第268题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/missing-number&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/missing-number&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;使用排序和哈希可以很容易做出来，但是不符合题意O(1)的空间复杂度。还有两种方法，一种是位运算，另一种是通过数学定理来解题。&lt;/p&gt;

&lt;h2 id=&#34;位运算解题&#34;&gt;位运算解题：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;异或运算的性质：

&lt;ul&gt;
&lt;li&gt;异或运算（XOR）满足结合律，并且对一个数进行两次完全相同的异或运算会得到原来的数。&lt;/li&gt;
&lt;li&gt;比如：&lt;code&gt;a ^ b ^ b == a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;任意一个数对0进行异或运算，等于它原来的数。&lt;/li&gt;
&lt;li&gt;比如：&lt;code&gt;a ^ 0 == a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;任意一个数对它本身进行异或运算，等于0.&lt;/li&gt;
&lt;li&gt;比如：&lt;code&gt;a ^ a  == 0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;因此，在&lt;code&gt;0-n&lt;/code&gt;个数的数组中必定缺少一个数。我们把数组的下标和数组中的数进行异或运算，所有的数都会找到下标相等的数，只有缺失的那个数字找不到，最后算出来的结果就是那个缺失的数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def missingNumber(self, nums: List[int]) -&amp;gt; int:
        ans = len(nums)  # 由于数组没有长度为nums长度的下标，因为从0开始索引的，所以我们要先加上去。
        for i in range(len(nums)):
            ans ^= i ^ nums[i]
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;数学定理解题&#34;&gt;数学定理解题：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;等差数列求和公式：

&lt;ul&gt;
&lt;li&gt;n * (n+1) / 2&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;我们把从0到数组最后的下标累加，再加上数组的长度。&lt;/li&gt;
&lt;li&gt;再把数组中的所有元素累加。&lt;/li&gt;
&lt;li&gt;然后两个相减，最后得到的就是缺失的数字。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码-1&#34;&gt;代码：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def missingNumber(self, nums: List[int]) -&amp;gt; int:
        n = len(nums)
        return n * (n + 1) // 2 - sum(nums)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;两种方法复杂度一样：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>找到所有数组中消失的数字</title>
      <link>https://ripple-zjw.github.io/2019/%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Fri, 06 Sep 2019 20:19:35 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>

&lt;h1 id=&#34;题目-找到所有数组中消失的数字&#34;&gt;题目：找到所有数组中消失的数字&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个范围在&lt;code&gt;1 ≤ a[i] ≤ n&lt;/code&gt; (&lt;code&gt;n&lt;/code&gt; = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。&lt;/li&gt;
&lt;li&gt;找到所有在 [1, n] 范围之间没有出现在数组中的数字。&lt;/li&gt;
&lt;li&gt;您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入:
[4,3,2,7,8,2,3,1]

输出:
[5,6]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第448题&#34;&gt;来源：力扣（LeetCode）第448题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;有多种方法，第一种是用抽屉原理和异或运算的方式交换值。第二种是一种更为巧妙的方式。&lt;/p&gt;

&lt;h3 id=&#34;使用异或运算交换两个值的方法&#34;&gt;使用异或运算交换两个值的方法：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;a = a ^ b
b = a ^ b
a = a ^ b
这样就可以在不使用第三个变量的前提下交换两个变量的值。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;抽屉原理&#34;&gt;抽屉原理：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;如果每个抽屉代表一个集合，每一个苹果就可以代表一个元素，假如有 n + 1 个元素放到 n 个集合中去，其中必定有一个集合里至少有两个元素。” 抽屉原理有时也被称为鸽巢原理。它是组合数学中一个重要的原理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;思路&#34;&gt;思路：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;第一种：

&lt;ul&gt;
&lt;li&gt;遍历整个数组，从第一个开始&lt;code&gt;i&lt;/code&gt;，不停地把这个位置上的元素&lt;code&gt;i&lt;/code&gt;与它的值所对应的下标位置上的元素进行交换。&lt;/li&gt;
&lt;li&gt;一旦当前遍历的这个位置上的元素&lt;code&gt;i&lt;/code&gt;与它值所对应的下标位置上的元素相等，那么就遍历数组的下一个元素&lt;code&gt;i&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;这样的目的是，要么当前位置上&lt;code&gt;i&lt;/code&gt;存的是正确的位置，比如&lt;code&gt;i = 0&lt;/code&gt;的位置上存的是&lt;code&gt;1&lt;/code&gt;，因为数组中的元素是从&lt;code&gt;1&lt;/code&gt;开始的；要么当前位置&lt;code&gt;i&lt;/code&gt;上存的是出现了两次的元素。&lt;/li&gt;
&lt;li&gt;这样最后判断每个元素的值是否是其下标+1。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第二种：

&lt;ul&gt;
&lt;li&gt;遍历整个数组，将该元素的值所对应的下标位置的值变为负数。&lt;/li&gt;
&lt;li&gt;遍历完后，如果数组中还有位置上的值是正数，那么说明没有值等于该位置的下标，即数组中没有遍历到这个值。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;两种方法的代码&#34;&gt;两种方法的代码：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一种：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def findDisappearedNumbers(self, nums: List[int]) -&amp;gt; List[int]:
    for i in range(len(nums)):
        while nums[i] != nums[nums[i] - 1]:  # 一直交换，直到值正确或者这个值出现了两次。
            tmp = nums[i] - 1  # 临时储存，如果用函数可以不写这个。
            if i == tmp:  # 如果两个值相等不能用异或交换，否则一个值会为0
                break
            nums[i] = nums[i] ^ nums[tmp]  # 异或交换
            nums[tmp] = nums[i] ^ nums[tmp]
            nums[i] = nums[i] ^ nums[tmp]
    return [i+1 for i in range(len(nums)) if i+1 != nums[i]]  # 返回正确位置的值
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第二种：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def findDisappearedNumbers(self, nums: List[int]) -&amp;gt; List[int]:
    for i in range(len(nums)):
        nums[abs(nums[i]) - 1] = -abs(nums[abs(nums[i]) - 1])  # 把当前值所对应的下标上的值变为负数，需要注意的是可能这个值已经是负数了，比如有的值出现了两次，所以要加绝对值。
    return [i + 1 for i in range(len(nums)) if nums[i] &amp;gt; 0]  # 把大于0的数返回
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>组合总和</title>
      <link>https://ripple-zjw.github.io/2019/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</link>
      <pubDate>Fri, 06 Sep 2019 20:18:05 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</guid>
      <description>

&lt;h1 id=&#34;题目-组合总和&#34;&gt;题目：组合总和&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个无重复元素的数组&lt;code&gt;candidates&lt;/code&gt;和一个目标数&lt;code&gt;target&lt;/code&gt;，找出&lt;code&gt;candidates&lt;/code&gt;中所有可以使数字和为&lt;code&gt;target&lt;/code&gt;的组合。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;candidates&lt;/code&gt;中的数字可以无限制重复被选取。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;说明&#34;&gt;说明：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;所有数字（包括 target）都是正整数。
解集不能包含重复的组合。 
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: candidates = [2,3,6,7], target = 7,
所求解集为:
[
  [7],
  [2,2,3]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: candidates = [2,3,5], target = 8,
所求解集为:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode&#34;&gt;来源：力扣（LeetCode）&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/combination-sum&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/combination-sum&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;回溯算法+栈，这是我的做法，看到很多算法高手的思路和方法都很棒，有用回溯的，有用dp的。&lt;/p&gt;

&lt;h3 id=&#34;我放上两个比较好的题解&#34;&gt;我放上两个比较好的题解:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;回溯算法：
&amp;gt; &lt;a href=&#34;https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;动态规划：
&amp;gt; &lt;a href=&#34;https://leetcode-cn.com/problems/combination-sum/solution/chao-qiang-gifzhu-ni-shi-yong-dong-tai-gui-hua-qiu/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/combination-sum/solution/chao-qiang-gifzhu-ni-shi-yong-dong-tai-gui-hua-qiu/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;思路&#34;&gt;思路：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;回溯算法一般都用递归来完成。最好的方法是画递归树。&lt;/li&gt;
&lt;li&gt;通过对每一层的递归，将所有等于target的答案全部都得到。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def combinationSum(self, candidates: List[int], target: int) -&amp;gt; List[List[int]]:
        ans = []
        def recursion(cand, i):
            for j in range(i, len(candidates)):
                stack.append(candidates[j])
                res = candidates[j] + cand
                if res &amp;gt;= target:
                    if res == target:
                        ans.append(stack[:])
                    stack.pop()
                    continue
                else:
                    recursion(res, j)
                    stack.pop()
        for i in range(len(candidates)):
            stack = [candidates[i]]
            if candidates[i] &amp;lt; target:
                recursion(candidates[i], i)
            elif candidates[i] == target:
                ans.append(stack)
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n!) 个人认为&lt;/li&gt;
&lt;li&gt;空间复杂度：O(target) 个人认为&lt;code&gt;target&lt;/code&gt;是主要影响答案数量的，当&lt;code&gt;target&lt;/code&gt;变大时，最终返回的数量会非常多。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>复写零</title>
      <link>https://ripple-zjw.github.io/2019/%E5%A4%8D%E5%86%99%E9%9B%B6/</link>
      <pubDate>Fri, 06 Sep 2019 20:16:32 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%A4%8D%E5%86%99%E9%9B%B6/</guid>
      <description>

&lt;h1 id=&#34;题目-复写零&#34;&gt;题目：复写零&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给你一个长度固定的整数数组&lt;code&gt;arr&lt;/code&gt;，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。&lt;/li&gt;
&lt;li&gt;注意：请不要在超过该数组长度的位置写入元素。&lt;/li&gt;
&lt;li&gt;要求：请对输入的数组就地进行上述修改，不要从函数返回任何东西。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：[1,0,2,3,0,4,5,0]
输出：null
解释：调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：[1,2,3]
输出：null
解释：调用函数后，输入的数组将被修改为：[1,2,3]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;提示&#34;&gt;提示：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= arr.length &amp;lt;= 10000&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= arr[i] &amp;lt;= 9&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第1089题&#34;&gt;来源：力扣（LeetCode）第1089题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/duplicate-zeros&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/duplicate-zeros&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;这道题的难点在于要在原数组上操作，不可以申请新的数组。因此，快慢双指针就派上用场了。&lt;/p&gt;

&lt;h2 id=&#34;思路&#34;&gt;思路：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;声明两个指针&lt;code&gt;i&lt;/code&gt;,&lt;code&gt;j&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一个指针正常遍历&lt;code&gt;i&lt;/code&gt;，另一个&lt;code&gt;j&lt;/code&gt;遇到&lt;code&gt;0&lt;/code&gt;就往前再+1&lt;/li&gt;
&lt;li&gt;遍历完之后&lt;code&gt;i&lt;/code&gt;之后的数都是被移出去的，&lt;code&gt;j&lt;/code&gt;指针在最后一位&lt;/li&gt;
&lt;li&gt;依次将&lt;code&gt;i&lt;/code&gt;指针的元素赋在&lt;code&gt;j&lt;/code&gt;的位置，遇到0，&lt;code&gt;j&lt;/code&gt;不仅要将&lt;code&gt;i&lt;/code&gt;的值赋上，还要往前一位再赋上0。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;双指针法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def duplicateZeros(self, arr: List[int]) -&amp;gt; None:
    i = j = 0
    n = len(arr)
    while j &amp;lt; n:
        if arr[i] == 0:
            j += 1
        i += 1
        j += 1
    i -= 1
    j -= 1
    while i &amp;gt;= 0:
        if j &amp;lt; n:
            arr[j] = arr[i]
        if arr[i] == 0:
            j -= 1
            arr[j] = 0
        j -= 1
        i -= 1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;非原地解法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def duplicateZeros(self, arr: List[int]) -&amp;gt; None:
    i = 0
    while i &amp;lt; len(arr):
        if arr[i] == 0:
            arr.insert(i, 0)
            arr.pop()
            i += 1
        i += 1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为数组的长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>数组的相对排序</title>
      <link>https://ripple-zjw.github.io/2019/%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Fri, 30 Aug 2019 19:27:49 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/</guid>
      <description>

&lt;h1 id=&#34;题目-数组的相对排序&#34;&gt;题目：数组的相对排序&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给你两个数组，&lt;code&gt;arr1&lt;/code&gt; 和&lt;code&gt;arr2&lt;/code&gt;，

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;arr2&lt;/code&gt;中的元素各不相同&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arr2&lt;/code&gt; 中的每个元素都出现在&lt;code&gt;arr1&lt;/code&gt;中&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对&lt;code&gt;arr1&lt;/code&gt;中的元素进行排序，使arr1中项的相对顺序和&lt;code&gt;arr2&lt;/code&gt;中的相对顺序相同。&lt;/li&gt;
&lt;li&gt;未在&lt;code&gt;arr2&lt;/code&gt;中出现过的元素需要按照升序放在&lt;code&gt;arr1&lt;/code&gt;的末尾。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
输出：[2,2,2,1,4,3,3,9,6,7,19]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;提示&#34;&gt;提示：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;arr1.length, arr2.length&lt;/code&gt; &amp;lt;= 1000&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= &lt;code&gt;arr1[i], arr2[i]&lt;/code&gt; &amp;lt;= 1000&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arr2&lt;/code&gt;中的元素&lt;code&gt;arr2[i]&lt;/code&gt;各不相同&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arr2&lt;/code&gt; 中的每个元素&lt;code&gt;arr2[i]&lt;/code&gt;都出现在&lt;code&gt;arr1&lt;/code&gt;中&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第1122题&#34;&gt;来源：力扣（LeetCode）第1122题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/relative-sort-array&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/relative-sort-array&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;最近一直在做数组的题目，这种题一眼就想到了计数排序，唯一的不同就是在排序的时候要按arr2的顺序排。&lt;/li&gt;
&lt;li&gt;我的代码是遍历了两边，第一遍是遍历arr2，第二遍遍历整个排序，如果你有更好的计数排序方法，欢迎你告诉我。&lt;/li&gt;
&lt;li&gt;不知道你们有没有遇到过计数排序，我尽可能的把注释写的详细一点，好给没接触过的人参考一下。（反正多遇到几次就写的很熟了）&lt;/li&gt;
&lt;li&gt;其实就是用到了hash表。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -&amp;gt; List[int]:
        arr = [0 for _ in range(1001)]  # 由于题目说arr1的范围在0-1000，所以生成一个1001大小的数组用来存放每个数出现的次数。
        ans = []  # 储存答案的数组。
        for i in range(len(arr1)):  # 遍历arr1，把整个arr1的数的出现次数储存在arr上，arr的下标对应arr1的值，arr的值对应arr1中值出现的次数。
            arr[arr1[i]] += 1  # 如果遇到了这个数，就把和它值一样的下标位置上+1，表示这个数在这个下标i上出现了1次。
        for i in range(len(arr2)):  # 遍历arr2，现在开始要输出答案了。
            while arr[arr2[i]] &amp;gt; 0:  # 如果arr2的值在arr所对应的下标位置出现次数大于0，那么就说明arr中的这个位置存在值。
                ans.append(arr2[i])  # 如果存在值，那就把它加到ans中，因为要按arr2的顺序排序。
                arr[arr2[i]] -= 1  # 加进去了次数 -1 ，不然就死循环了。
        for i in range(len(arr)):  # 如果arr1的值不在arr2中，那么不能就这么结束了，因为题目说了如果不在，剩下的值按照升序排序。
            while arr[i] &amp;gt; 0:  # 同样也是找到大于0的下标，然后一直加到ans中，直到次数为0。
                ans.append(i)
                arr[i] -= 1
        return ans  # 返回最终答案。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n+m) n 为arr2的长度，m为arr1的长度。arr的长度固定是1001，所以就算arr中只有1个有次数,也要遍历1001遍。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n) n 为arr1的长度。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>杨辉三角</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</link>
      <pubDate>Fri, 30 Aug 2019 19:22:10 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</guid>
      <description>

&lt;h1 id=&#34;题目-杨辉三角&#34;&gt;题目：杨辉三角&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。&lt;/li&gt;
&lt;li&gt;在杨辉三角中，每个数是它左上方和右上方的数的和。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://ripple-zjw.github.io/images/杨辉三角/PascalTriangleAnimated2.gif&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第118题&#34;&gt;来源：力扣（LeetCode）第118题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/pascals-triangle&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/pascals-triangle&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;这题可以使用动态规划，是一道非常简单的题目。我们可以把所要求的值看成是前一行的两个值的相加，而且这两个值的位置是有规律的。&lt;/p&gt;

&lt;h2 id=&#34;思路&#34;&gt;思路：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;两个循环，第一遍遍历所有的层。&lt;/li&gt;
&lt;li&gt;第二遍遍历每一层中的值。&lt;/li&gt;
&lt;li&gt;每一层中的值只有第一个和最后一个是1，其他的值都是前一行的前一个位置和现在的位置的和。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def generate(self, numRows: int) -&amp;gt; List[List[int]]:
        ans = []
        for i in range(numRows):
            numRow = [1 for _ in range(i + 1)]
            for j in range(1, i):
                numRow[j] = ans[i-1][j-1] + ans[i-1][j]
            ans.append(numRow)
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n^2^) n 为numRows&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n^2^)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>按奇偶排序数组</title>
      <link>https://ripple-zjw.github.io/2019/%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%842/</link>
      <pubDate>Fri, 30 Aug 2019 19:20:28 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%842/</guid>
      <description>

&lt;h1 id=&#34;题目-按奇偶排序数组-ii&#34;&gt;题目：按奇偶排序数组 II&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个非负整数数组&lt;code&gt;A&lt;/code&gt;，&lt;code&gt;A&lt;/code&gt;中一半整数是奇数，一半整数是偶数。&lt;/li&gt;
&lt;li&gt;对数组进行排序，以便当&lt;code&gt;A[i]&lt;/code&gt; 为奇数时，&lt;code&gt;i&lt;/code&gt;也是奇数；当&lt;code&gt;A[i]&lt;/code&gt;为偶数时，&lt;code&gt;i&lt;/code&gt; 也是偶数。&lt;/li&gt;
&lt;li&gt;你可以返回任何满足上述条件的数组作为答案。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：[4,2,5,7]
输出：[4,5,2,7]
解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;提示&#34;&gt;提示：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;2 &amp;lt;= A.length &amp;lt;= 20000&lt;/li&gt;
&lt;li&gt;A.length % 2 == 0&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= A[i] &amp;lt;= 1000&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第922题&#34;&gt;来源：力扣（LeetCode）第922题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/sort-array-by-parity-ii&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/sort-array-by-parity-ii&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;一遍遍历数组即可求解。但是为了追求极致，采用双指针法可以实现原地交换。&lt;/p&gt;

&lt;h2 id=&#34;思路&#34;&gt;思路：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;使用两个指针&lt;code&gt;i&lt;/code&gt;,&lt;code&gt;j&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;一个遍历偶数下标，一个遍历奇数下标。&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;i&lt;/code&gt;在偶数的下标中找到了一个奇数，那么就从&lt;code&gt;j&lt;/code&gt;奇数下标中找一个偶数。&lt;/li&gt;
&lt;li&gt;将两者交换位置。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;双指针法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def sortArrayByParityII(self, A: List[int]) -&amp;gt; List[int]:
    j = 1
    for i in range(0, len(A), 2):
        if A[i] % 2 == 1:
            while A[j] % 2 == 1:
                j += 2
            A[i], A[j] = A[j], A[i]
    return A
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;正常一次遍历：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def sortArrayByParityII(self, A: List[int]) -&amp;gt; List[int]:
    ans = [0 for _ in range(len(A))]
    single = 1
    double = 0
    for i in range(len(A)):
        if A[i] % 2 == 0:
            ans[double] = A[i]
            double += 2
        else:
            ans[single] = A[i]
            single += 2
    return ans
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;双指针法：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n 为数组长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;正常遍历：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n 为数组长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;双指针法可以降低空间的使用，用过原地交换实现不需要额外的空间去储存答案。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>求众数</title>
      <link>https://ripple-zjw.github.io/2019/%E6%B1%82%E4%BC%97%E6%95%B0/</link>
      <pubDate>Fri, 30 Aug 2019 19:17:44 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%B1%82%E4%BC%97%E6%95%B0/</guid>
      <description>

&lt;h1 id=&#34;题目-求众数&#34;&gt;题目：求众数&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于&lt;code&gt;⌊ n/2 ⌋&lt;/code&gt;的元素。&lt;/li&gt;
&lt;li&gt;你可以假设数组是非空的，并且给定的数组总是存在众数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [3,2,3]
输出: 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [2,2,1,1,1,2,2]
输出: 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第169题&#34;&gt;来源：力扣（LeetCode）第169题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/majority-element&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/majority-element&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;这道题很经典，方法有很多，暴力法，分治法，哈希法，排序法，随机法，投票法。我自己用了哈希法做出来的，但是官方的投票法真的是太秀了，这里着重讲投票法。&lt;/p&gt;

&lt;h2 id=&#34;思路&#34;&gt;思路：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;先让第一个人作为&lt;code&gt;candidate&lt;/code&gt;，&lt;/li&gt;
&lt;li&gt;然后和它一样的元素给他加票，不一样的元素给它减票，&lt;/li&gt;
&lt;li&gt;当票数为0时，就换掉&lt;code&gt;candidate&lt;/code&gt;，让新的元素担任。&lt;/li&gt;
&lt;li&gt;最后成为&lt;code&gt;candidate&lt;/code&gt;的元素就是众数。&lt;/li&gt;
&lt;li&gt;当然，前提是题目给出地假设一定存在众数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;投票法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def majorityElement(self, nums: List[int]) -&amp;gt; int:
    candidate = 0
    count = 0
    for num in nums:
        if count == 0:
            candidate = num
        count += 1 if num == candidate else -1
    return candidate
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;哈希法：(自己做的)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def majorityElement(self, nums: List[int]) -&amp;gt; int:
    cnt = len(nums) / 2
    dic = {}
    for num in nums:
        if num in dic:
            dic[num] += 1
        else:
            dic[num] = 1
        if dic[num] &amp;gt;= cnt:
            return num
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;投票法：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>有序数组的平方</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</link>
      <pubDate>Fri, 23 Aug 2019 13:01:17 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</guid>
      <description>

&lt;h1 id=&#34;题目-有序数组的平方&#34;&gt;题目：有序数组的平方&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：[-4,-1,0,3,10]
输出：[0,1,9,16,100]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：[-7,-3,2,3,11]
输出：[4,9,9,49,121]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;提示&#34;&gt;提示：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= &lt;code&gt;A.length&lt;/code&gt; &amp;lt;= 10000&lt;/li&gt;
&lt;li&gt;10000 &amp;lt;= &lt;code&gt;A[i]&lt;/code&gt; &amp;lt;= 10000&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A&lt;/code&gt;已按非递减顺序排序。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第977题&#34;&gt;来源：力扣（LeetCode）第977题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/squares-of-a-sorted-array&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/squares-of-a-sorted-array&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;这道题的方法有两种，一种最简单，先计算，再排序。第二种用双指针做到一遍遍历解答。&lt;/p&gt;

&lt;h2 id=&#34;思路&#34;&gt;思路：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;由于数组是按照递增的顺序增长的，因此所有的正数都是递增的，所有的负数加上绝对值都是递减的。&lt;/li&gt;
&lt;li&gt;我们用两个指针&lt;code&gt;i&lt;/code&gt;和&lt;code&gt;j&lt;/code&gt;，&lt;code&gt;i&lt;/code&gt;从前往后遍历，&lt;code&gt;j&lt;/code&gt;从后往前遍历。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt;遇到正数就停下来，&lt;code&gt;j&lt;/code&gt;遇到负数就停下来，然后比较他们两谁小，小的那个放到ans答案中。&lt;/li&gt;
&lt;li&gt;然后就把放入答案中的那个指针往后前移。&lt;/li&gt;
&lt;li&gt;最后退出循环，但是可能有一个指针并没有移到终点，因此要在循环结束后去判断两个指针的情况，把指针后面的值都加到ans中去。&lt;/li&gt;
&lt;li&gt;最后得到答案。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def sortedSquares(self, A: List[int]) -&amp;gt; List[int]:
        i = 0
        j = len(A) - 1
        ans = []
        while i &amp;lt; len(A) and j &amp;gt;= 0:  # 主循环
            while i &amp;lt; len(A) and A[i] &amp;lt; 0:  # 遍历到第一个正数
                i += 1
            while j &amp;gt;= 0 and A[j] &amp;gt;= 0:  # 遍历到第一个负数
                j -= 1
            if i &amp;lt; len(A) and j &amp;gt;= 0:  # 谁小就把谁加进来
                if A[i] ** 2 &amp;gt; A[j] ** 2:
                    ans.append(A[j] ** 2)
                    j -= 1
                else:
                    ans.append(A[i] ** 2)
                    i += 1
        while i &amp;lt; len(A):  # 如果i没有到遍历完吧i加进去
            ans.append(A[i] ** 2)
            i += 1
        while j &amp;gt;=0:  # j没有到头把j加进去
            ans.append(A[j] ** 2)
            j -= 1
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;简单暴力法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def sortedSquares(self, A: List[int]) -&amp;gt; List[int]:
    return sorted(x * x for x in A)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;双指针法：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n 为数组长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;暴力法：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(nlogn) n为数组长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;双指针法在解数组这一块的问题时是一个不错的方法。&lt;/li&gt;
&lt;li&gt;一段递增的数，如果有负数那么负数的绝对值是递减的。反向遍历就能使其递增。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>高度检查器</title>
      <link>https://ripple-zjw.github.io/2019/%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/</link>
      <pubDate>Fri, 23 Aug 2019 12:59:06 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/</guid>
      <description>

&lt;h1 id=&#34;题目-高度检查器&#34;&gt;题目：高度检查器&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。&lt;/li&gt;
&lt;li&gt;请你返回至少有多少个学生没有站在正确位置数量。该人数指的是：能让所有学生以 非递减 高度排列的必要移动人数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：[1,1,4,2,1,3]
输出：3
解释：
高度为 4、3 和最后一个 1 的学生，没有站在正确的位置。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;提示&#34;&gt;提示：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= heights.length &amp;lt;= 100&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= heights[i] &amp;lt;= 100&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第1051题&#34;&gt;来源：力扣（LeetCode）第1051题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/height-checker&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/height-checker&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;有两种方法。都是先排序，然后比较两者之间的差异。不同处，第一种是比较排序，第二种是计数排序。计数排序的时间复杂度相对较低，本文讲解计数排序。&lt;/p&gt;

&lt;h2 id=&#34;思路&#34;&gt;思路：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;因为&lt;code&gt;heights[i]&lt;/code&gt;不会超过100，所以采用hash的思想，将所给数组每个值出现的次数作为值，将所给数组的值作为下标，这样相同值出现的次数就会被归在一起，而且值小的元素会在前面，因为下标就是值。&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;1&lt;/code&gt;出现了3次，那么这3次一定是在最前面的，所以我们顺序遍历原数组，如果前3次不是1，就说明这个数要移动，以此类推。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def heightChecker(self, heights: List[int]) -&amp;gt; int:
        ans = 0
        arr = [0] * 101  # heights[i]最多不超过100个
        for height in heights:  # 将heights散列到arr中
            arr[height] += 1
        j = 0
        for i in range(1, len(arr)):  # 根据arr中的计数排序比较原数组
            while arr[i] &amp;gt; 0:
                if heights[j] != i:  # 如果值不同，那么ans就+1
                    ans += 1
                j += 1
                arr[i] -= 1  # 比较完一次计数就-1，减到0说明这个数没有了。
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;然后再放上比较排序的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def heightChecker(self, heights: List[int]) -&amp;gt; int:
    sorted_list = sorted(heights)
    ans = 0
    for i in range(len(heights)):
        if heights[i] != sorted_list[i]:
            ans += 1
    return ans
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;计数排序：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) &lt;code&gt;n = n + n&lt;/code&gt; n为数组&lt;code&gt;heights&lt;/code&gt;的长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1) 1 为arr的长度101&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;比较排序：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(nlogn) n 为&lt;code&gt;heights&lt;/code&gt;的长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;计数排序的效率比快速排序还要快，但是只适用于特殊场景。&lt;/li&gt;
&lt;li&gt;例如在该题中，如果&lt;code&gt;heights[i]&lt;/code&gt;的大小非常大，那么需要的内存空间会非常多。如果大小不确定，那么就无法知道该声明多长的数组，一旦内存溢出，程序就崩溃了。又比如次数非常少，基本没有重复的数，那么排序的时间也不会快到哪里去。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>求最大子数组</title>
      <link>https://ripple-zjw.github.io/2019/%E6%B1%82%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</link>
      <pubDate>Fri, 23 Aug 2019 12:57:06 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%B1%82%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</guid>
      <description>

&lt;h1 id=&#34;题目-求最大子数组&#34;&gt;题目：求最大子数组&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;在一个数组中找到和最大的子数组。&lt;/li&gt;
&lt;li&gt;数组中有正有负，但都是&lt;code&gt;integer&lt;/code&gt;类型。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;题目来源-算法导论第38页-4-1-最大子数组问题&#34;&gt;题目来源：算法导论第38页 4.1 最大子数组问题&lt;/h4&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;根据书中的问题，采用分治思想来解题。具体可参考算法导论。&lt;/p&gt;

&lt;h2 id=&#34;思路&#34;&gt;思路：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;将整个数组一分为二，每次分完之后做四件事件：

&lt;ul&gt;
&lt;li&gt;查看是否是最小数组即长度是1，因为数组长度是1那么总和就是这一个数的值。&lt;/li&gt;
&lt;li&gt;如果不是1，那就分别递归进左边的数组和右边的数组继续分，直到分到1再返回。&lt;/li&gt;
&lt;li&gt;每次递归除了左边的最大子数组和右边的最大子数组外，还有交叉在中间的最大子数组。所以要把中间的最大子数组也算出来。&lt;/li&gt;
&lt;li&gt;算出三者的各自的和将和最大的那个子数组并返回，同时返回它的两端下标。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;每次递归都会返回左边，右边，中间的最大的那个子数组。&lt;/li&gt;
&lt;li&gt;最后一次递归返回最大的子数组，答案就出来了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class FindMaxNum:
	def _find_crossing(self, A, low, mid, high):  # 寻找穿过中间值的最大子数组
		leftSum = float(&#39;-inf&#39;)
		ans = 0
		maxLeft = mid
		maxRight = mid + 1
		for i in range(mid, low - 1, -1):  # 找到左边的最大子数组
			ans += A[i]
			if ans &amp;gt; leftSum:
				leftSum = ans
				maxLeft = i
		rightSum = float(&#39;-inf&#39;)
		ans = 0
		for j in range(mid + 1, high + 1):  # 找到右边的最大子数组
			ans += A[j]
			if ans &amp;gt; rightSum:
				rightSum = ans
				maxRight = j
		return maxLeft, maxRight, leftSum + rightSum  # 返回最大的子数组以及它的两端下标


	def find_max_num(self, A, low, high):
		if low == high:  # 如果分到了1，那么就返回
			return low, high, A[low]
		else:
			mid = (low + high) // 2  # 将数组一分为二
			left_low, left_high, left_sum = self.find_max_num(A, low, mid)  # 递归进左子数组
			right_low, right_high, right_sum = self.find_max_num(A, mid + 1, high)  # 递归进右子数组
			cro_low, cro_high, cro_sum = self._find_crossing(A, low, mid, high)  # 寻找中间子数组
			if left_sum &amp;gt;= right_sum and left_sum &amp;gt;= cro_sum:  # 左边最大返回左边
				return left_low, left_high, left_sum
			elif right_sum &amp;gt;= left_sum and right_sum &amp;gt;= cro_sum:  # 右边最大返回右边
				return right_low, right_high, right_sum
			else:  # 否则中间最大返回中间
				return cro_low, cro_high, cro_sum

if __name__ == &#39;__main__&#39;:  # 测试通过
	test = [13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7]
	fn = FindMaxNum()
	i, j, res = fn.find_max_num(test, 0, len(test) - 1)
	print(test[i:j+1])
	print(i,j)
	print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(nlogn) n 为数组的长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1) 完全没有开辟新的数组空间，仅仅是在原数组上分治。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;分治算法可以大幅度提高运行效率，相比于暴力法，速度提升很多。&lt;/li&gt;
&lt;li&gt;算法导论上的这个分治法应该是我看到的最好的分治法了，很多地方的算法解这道题时总是会开辟新的数组，这就导致了内存空间的浪费，如果数据量多的话，很容易空间不够。&lt;/li&gt;
&lt;li&gt;分治的主要思想就是找到递归条件和线性条件。然后用分而治之的方法从线性条件不停地向前合并，最终找到答案。主要的原理和递归很像。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>接雨水</title>
      <link>https://ripple-zjw.github.io/2019/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</link>
      <pubDate>Fri, 23 Aug 2019 12:55:03 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</guid>
      <description>

&lt;h1 id=&#34;题目-接雨水&#34;&gt;题目：接雨水&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定&lt;code&gt;n&lt;/code&gt;个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://ripple-zjw.github.io/images/接雨水/rainwatertrap.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;上面是由数组 &lt;code&gt;[0,1,0,2,1,0,1,3,2,1,2,1]&lt;/code&gt; 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。感谢 &lt;code&gt;Marcos&lt;/code&gt; 贡献此图。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第42题&#34;&gt;来源：力扣（LeetCode）第42题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/trapping-rain-water&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/trapping-rain-water&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;方法太多了，一道极难题，从暴力法，到动态规划，再到单调栈，再到双指针。方法非常多，也很难理解，暴力法最好理解，dp和双指针稍难，我这里讲单调栈的方法。&lt;/p&gt;

&lt;h2 id=&#34;思路&#34;&gt;思路：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;维护一个单调递减栈。&lt;/li&gt;
&lt;li&gt;当有值比栈顶元素大的时候做这么几件事情：

&lt;ul&gt;
&lt;li&gt;先出栈一个元素并保存到top中。&lt;/li&gt;
&lt;li&gt;然后判断stack是否是空，如果是空的话，说明出栈的左边没有东西，所以无法装雨水。(一定要两边都要有东西并且两边的墙比出栈的墙要长，这样才能装雨水)&lt;/li&gt;
&lt;li&gt;算出当前元素与栈顶元素中间的距离&lt;code&gt;dis&lt;/code&gt;(注意现在是出栈之后的栈顶元素)&lt;/li&gt;
&lt;li&gt;算出当前元素与栈顶元素中哪个值最小，并将小的那个值与出栈的那个元素相减，得到&lt;code&gt;floor_cnt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;为什么要叫&lt;code&gt;floor_cnt&lt;/code&gt;呢，因为将&lt;code&gt;floor_cnt&lt;/code&gt;与&lt;code&gt;dis&lt;/code&gt;(也就是两栋大墙之间的距离)相乘，你就能得到在这两栋墙之间一层的雨水数量。&lt;/li&gt;
&lt;li&gt;将它们加到ans答案中。例如：如果两栋墙最小的那栋是&lt;code&gt;3&lt;/code&gt;，那么就会有3层，每一层的雨水数量可能是不一样的，所以要算3遍。&lt;/li&gt;
&lt;li&gt;最后返回ans得到答案。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果值比栈顶元素小的话就入栈就行了，这样就能维护单调递减栈。(注意栈中存的是数组下标，为了算起来方便。)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;talk-is-cheap-show-me-the-code&#34;&gt;Talk is cheap,show me the code.&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution(object):
    def trap(self, height):
        stack = []
        ans = 0
        cur = 0
        while cur &amp;lt; len(height):
            while stack and height[stack[-1]] &amp;lt; height[cur]:
                top = stack.pop()
                if not stack:
                    break
                dis = cur - stack[-1] - 1
                floor_cnt = min(height[stack[-1]], height[cur]) - height[top]
                ans += dis * floor_cnt
            stack.append(cur)
            cur += 1
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;顺便写上双指针法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def trap(self, height: List[int]) -&amp;gt; int:
        lMax = 0
        rMax = 0
        res = 0
        i = 0
        j = len(height) - 1
        while i &amp;lt; j:
            if height[i] &amp;lt; height[j]:
                if height[i] &amp;gt;= lMax:
                    lMax = height[i]
                else:
                    res += (lMax - height[i])
                i += 1
            else:
                if height[j] &amp;gt;= rMax:
                    rMax = height[j]
                else:
                    res += (rMax - height[j])
                j -= 1
        return res
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n 为height长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n) n为stack长度。最坏情况下完全是单调递减栈，n变为height的长度。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;这是一道hard题。难度挺大的，其实我自己第一次想的时侯方法已经很接近了，但就是那个突破口没有想到，导致做不出来。&lt;/li&gt;
&lt;li&gt;如果我能想到一层一层算的话这道题就能解决了。&lt;/li&gt;
&lt;li&gt;而且这道题非常经典，有非常多的解法，建议大家收藏。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>