<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>动态规划 on LeaveIt</title>
    <link>https://ripple-zjw.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
    <description>Recent content in 动态规划 on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 09 Nov 2019 21:51:32 +0800</lastBuildDate>
    
	<atom:link href="https://ripple-zjw.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>最长等差数列</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%80%E9%95%BF%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/</link>
      <pubDate>Sat, 09 Nov 2019 21:51:32 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%80%E9%95%BF%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/</guid>
      <description>题目：最长等差数列  给定一个整数数组A，返回 A中最长等差子序列的长度。 回想一下，A的子序列是列表A[i_1], A[i_2], ..., A[i_k] 其中0 &amp;lt;= i_1 &amp;lt; i_2 &amp;lt; ... &amp;lt; i_k &amp;lt;= A.length - 1。并且如果B[i+1] - B[i](0 &amp;lt;= i &amp;lt; B.length - 1) 的值都相同，那么序列B是等差的。  示例 1： 输入：[3,6,9,12] 输出：4 解释： 整个数组是公差为 3 的等差数列。  示例 2： 输入：[9,4,7,2,10] 输出：3 解释： 最长的等差子序列是 [4,7,10]。  示例 3： 输入：[20,1,15,3,10,5,8] 输出：4 解释： 最长的等差子序列是 [20,15,10,5]。  提示：  2 &amp;lt;= A.length &amp;lt;= 2000 0 &amp;lt;= A[i] &amp;lt;= 10000  来源：力扣（LeetCode）第1027题  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>环绕字符串中唯一的子字符串</title>
      <link>https://ripple-zjw.github.io/2019/%E7%8E%AF%E7%BB%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%94%AF%E4%B8%80%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Sat, 09 Nov 2019 21:47:30 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%8E%AF%E7%BB%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%94%AF%E4%B8%80%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>题目：环绕字符串中唯一的子字符串  把字符串s看作是“abcdefghijklmnopqrstuvwxyz”的无限环绕字符串，所以s 看起来是这样的：&amp;rdquo;&amp;hellip;zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd&amp;hellip;.&amp;ldquo;. 现在我们有了另一个字符串 p 。你需要的是找出 s 中有多少个唯一的 p 的非空子串，尤其是当你的输入是字符串 p ，你需要输出字符串s中p的不同的非空子串的数目。 注意:p仅由小写的英文字母组成，p 的大小可能超过 10000。  示例1: 输入: &amp;quot;a&amp;quot; 输出: 1 解释: 字符串 S 中只有一个&amp;quot;a&amp;quot;子字符。  示例 2: 输入: &amp;quot;cac&amp;quot; 输出: 2 解释: 字符串 S 中的字符串“cac”只有两个子串“a”、“c”。.  示例 3: 输入: &amp;quot;zab&amp;quot; 输出: 6 解释: 在字符串 S 中有六个子串“z”、“a”、“b”、“za”、“ab”、“zab”。.  来源：力扣（LeetCode）第467题  链接：https://leetcode-cn.com/problems/unique-substrings-in-wraparound-string
 分析：  动态规划问题 遇到这种子字符串问题，我们可以考虑状态为以第i个结尾时有多少种情况。 例如abcd,a结尾时只有1种情况，b结尾时只有2种情况，c结尾时有3种情况，d结尾时有4中情况。 我们把这些值存在一个长度为26的dp数组中，按顺序放进来。 如果例子为abcdbcde，其中bcd都是重复的，不应该重复计算。我们可以进行比较，把相同状态下(都是以i结尾)值较大的那个更新进去。 例如b，它在abcd中值是2，ab,b。而在bcd中只有b，所以我们只要选择较大的2，那么后者的情况也会包含在内。 再比如c在前者有3个，abc,bc,c。后者有2个，bc,c,前者依然包括后者。 dp数组算出后，我们将dp数组中赋过值的数相加求和，就是最终答案。  代码： class Solution { public int findSubstringInWraproundString(String p) { int len = p.</description>
    </item>
    
    <item>
      <title>最后一块石头的重量II</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8Fii/</link>
      <pubDate>Sat, 09 Nov 2019 21:46:25 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8Fii/</guid>
      <description>题目：最后一块石头的重量 II  有一堆石头，每块石头的重量都是正整数。 每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为x和y，且x&amp;lt;= y。那么粉碎的可能结果如下：  如果x == y，那么两块石头都会被完全粉碎； 如果x != y，那么重量为x的石头将会完全粉碎，而重量为y的石头新重量为y-x。  最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。  示例： 输入：[2,7,4,1,8,1] 输出：1 解释： 组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]， 组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]， 组合 2 和 1，得到 1，所以数组转化为 [1,1,1]， 组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。  提示：  1 &amp;lt;= stones.length &amp;lt;= 30 1 &amp;lt;= stones[i] &amp;lt;= 1000  来源：力扣（LeetCode）第1049题  链接：https://leetcode-cn.com/problems/last-stone-weight-ii
 分析：  这道题一开始看好像没有什么思路，我们不妨把问题抽象出来。 题目要求最后把两块石头撞完后，剩下的重量要最小。那我们怎么才能让重量最小呢？这是关键点。 我们发现，只要每次相撞的两块石头，他们的大小都差不多，那么他们相撞之后得到的重量肯定是最小的。 因此，我们不妨把整个石子分成两块，只要我们把这两堆石子分的重量越接近，那么撞出来的重量一定会最小。 有人可能会想如果两边石子的数量不一样怎么办？不管两边数量有多不平衡，你都可以用一堆去撞另一堆，一定会把其中一堆装完的。 至此，我们把目的改一改，我们现在要找出两堆石子，他们的重量最接近。 如何找呢？ 我们把所有石子的重量和算一下，然后除以一半，最好的情况下正好分成了两堆重量一样的石子，直接撞完就等于0了。 如果不行呢？ 我们把石子的总重量叫sum,把一半的重量叫half。 我们一定能找到其中一堆小于half的(不管这一堆长度是多少，一定能找到),那么另一堆的重量肯定是大于half的。 所以我们只要找到一堆越接近half就行了，如果等于half最好。 参考LeetCode第416题，分割等和子集。 我们这次不是要分割等和子集，而是要找到越接近half的子集。 设置两个状态，见第一个代码。第一个是当前的位置，第二个是求得的和。 每次判断当前的和是否达到，有两种选择，使用这个位置，或者不使用这个位置。 进阶：我们可以使用dfs改写这段dp，从half开始，依次往0判断能否组成这个和，如果能那么这个和就是最大和。dfs更加快，因为只要找到最大和就直接返回答案就行了，不用再算下去。 进阶2：我们把dp变为一维dp，去掉当前位置的状态，只保留求得的和，问题转化为一个经典的0-1背包问题。  代码：  常规二维dp：</description>
    </item>
    
    <item>
      <title>串联字符串的最大长度</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%B2%E8%81%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Sat, 09 Nov 2019 21:35:43 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%B2%E8%81%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6/</guid>
      <description>题目：串联字符串的最大长度  给定一个字符串数组arr，字符串s是将arr 某一子序列字符串连接所得的字符串，如果s 中的每一个字符都只出现过一次，那么它就是一个可行解。 请返回所有可行解s中最长长度。  示例 1： 输入：arr = [&amp;quot;un&amp;quot;,&amp;quot;iq&amp;quot;,&amp;quot;ue&amp;quot;] 输出：4 解释：所有可能的串联组合是 &amp;quot;&amp;quot;,&amp;quot;un&amp;quot;,&amp;quot;iq&amp;quot;,&amp;quot;ue&amp;quot;,&amp;quot;uniq&amp;quot; 和 &amp;quot;ique&amp;quot;，最大长度为 4。  示例 2： 输入：arr = [&amp;quot;cha&amp;quot;,&amp;quot;r&amp;quot;,&amp;quot;act&amp;quot;,&amp;quot;ers&amp;quot;] 输出：6 解释：可能的解答有 &amp;quot;chaers&amp;quot; 和 &amp;quot;acters&amp;quot;。  示例 3： 输入：arr = [&amp;quot;abcdefghijklmnopqrstuvwxyz&amp;quot;] 输出：26  提示：  1 &amp;lt;= arr.length &amp;lt;= 16 1 &amp;lt;= arr[i].length &amp;lt;= 26 arr[i]中只含有小写英文字母  来源：力扣（LeetCode）第1239题  链接：https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters
 分析：  使用位压缩和回溯就可以完成这道题。 每一个字符串我们有两种选择，一种是用这个字符串，另一个是不用这个字符串。 我们用一个int类型的整数代表字符串每一个字符的使用情况。int总共有32位，而小写字母总共有26个，因此我可以把26个字母都存在每一个位上，1代表已经使用了，0代表未使用。 如果用这个字符串，我们就要把当前的字符串长度加上，然后再去往下找下一个字符串。 如果不用这个字符串，我们不用加上当前字符串的长度，只需要找下一个字符串就行了。 然后比较一下两者哪个大。 需要注意的是，如果这个字符不能使用，就是用了会有重复的字符，那么这种情况只有一个选择，就是不用这个字符串。 其实这道题和dp很像，但是由于有一个状态的范围不确定，所以用dp稍有难度。  代码： class Solution { int len; public int maxLength(List&amp;lt;String&amp;gt; arr) { len = arr.</description>
    </item>
    
    <item>
      <title>最大的以</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%80%E5%A4%A7%E7%9A%84%E4%BB%A5-1-%E4%B8%BA%E8%BE%B9%E7%95%8C%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2/</link>
      <pubDate>Sat, 09 Nov 2019 21:34:34 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%80%E5%A4%A7%E7%9A%84%E4%BB%A5-1-%E4%B8%BA%E8%BE%B9%E7%95%8C%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2/</guid>
      <description>题目：最大的以 1 为边界的正方形  给你一个由若干0和1 组成的二维网格grid，请你找出边界全部由1组成的最大 正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回0。  示例 1： 输入：grid = [[1,1,1],[1,0,1],[1,1,1]] 输出：9  示例 2： 输入：grid = [[1,1,0,0]] 输出：1  提示：  1 &amp;lt;= grid.length &amp;lt;= 100 1 &amp;lt;= grid[0].length &amp;lt;= 100 grid[i][j] 为0或1  来源：力扣（LeetCode）第1139题  链接：https://leetcode-cn.com/problems/largest-1-bordered-square
 分析：  动态规划题 我们使用up和left两个状态来表示每一个格子上的情况。 up和left是当前格子向上的连续数量和向左的连续数量。 当我们算出一个格子的up和left之后分别向上和向左一个一个去找，直到up和left的最小长度为止，每找一次之后都要判断另外两条边是否大于等于当前长度。  代码： class Solution { public int largest1BorderedSquare(int[][] grid) { int m = grid.length, n = grid[0].length; int[][][] dp = new int[m+1][n+1][2]; // 0 up 1 left; int ans = 0; for (int i = 1; i &amp;lt;= m; i++) { for (int j = 1; j &amp;lt;= n; j++) { if (grid[i-1][j-1] == 0) continue; // 如果是0则不要继续了 dp[i][j][0] = dp[i-1][j][0] + 1; // 求出up情况下连续的个数 dp[i][j][1] = dp[i][j-1][1] + 1; // 求出left情况下连续的个数 int min = Math.</description>
    </item>
    
    <item>
      <title>最大正方形</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/</link>
      <pubDate>Sat, 09 Nov 2019 21:33:05 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/</guid>
      <description>题目：最大正方形  在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。  示例: 输入: 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 输出: 4  来源：力扣（LeetCode）第221题  链接：https://leetcode-cn.com/problems/maximal-square
 分析：  dp题 首先正方形的面积一定是根号后还为正数的。 首先面积为1,这很简单，只要出现了1那肯定有1。 然后是面积为4的，也就是边长为2的，如果边长为2，那么这个数组的左边，上边和左上肯定不能是0，以及自己也不能是0。 最后来看看面积是9的情况，边长为3。如果边长为3，那么同样也是左边，右边和左上，他们的值不仅要不等于0，而且每个值都至少得是2，因为他们的三个方向也依然不能是0。 所以我们每次都找这三个方向，算出他们的最小值。然后再加上1，这样就能得到这个点最大的面积了。  代码： class Solution { public int maximalSquare(char[][] matrix) { int m = matrix.length; if (m == 0) return 0; int n = matrix[0].</description>
    </item>
    
    <item>
      <title>划分为k个相等的子集</title>
      <link>https://ripple-zjw.github.io/2019/%E5%88%92%E5%88%86%E4%B8%BAk%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AD%90%E9%9B%86/</link>
      <pubDate>Sat, 09 Nov 2019 21:31:18 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%88%92%E5%88%86%E4%B8%BAk%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AD%90%E9%9B%86/</guid>
      <description>题目：划分为k个相等的子集  给定一个整数数组nums和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。  示例 1： 输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4 输出： True 说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。  注意:  1 &amp;lt;= k &amp;lt;= len(nums) &amp;lt;= 16 0 &amp;lt; nums[i] &amp;lt; 10000  来源：力扣（LeetCode）第698题  链接：https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets
 分析：  这道题LeetCode官方给出的标签为dp和递归。 但是好像没有一个人用dp写出来，基本用的都是回溯算法。 由于数据范围不大，就可以穷举所有的可能，如果不对，再回来计算下一种可能。  代码： class Solution { int[] bucket; public boolean canPartitionKSubsets(int[] nums, int k) { if (k == 1) return true; //如果k是1，直接返回true。 int len = nums.</description>
    </item>
    
    <item>
      <title>分汤</title>
      <link>https://ripple-zjw.github.io/2019/%E5%88%86%E6%B1%A4/</link>
      <pubDate>Sat, 09 Nov 2019 21:30:11 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%88%86%E6%B1%A4/</guid>
      <description>题目：分汤  有A和B两种类型的汤。一开始每种类型的汤有N毫升。有四种分配操作： 提供 100ml 的汤A 和 0ml 的汤B。 提供 75ml 的汤A 和 25ml 的汤B。 提供 50ml 的汤A 和 50ml 的汤B。 提供 25ml 的汤A 和 75ml 的汤B。 当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为0.25的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。 注意不存在先分配100 ml汤B的操作。 需要返回的值：汤A先分配完的概率 + 汤A和汤B同时分配完的概率 / 2。  示例: 输入: N = 50 输出: 0.625 解释: 如果我们选择前两个操作，A将首先变为空。 对于第三个操作，A和B会同时变为空。 对于第四个操作，B将首先变为空。 所以A变为空的总概率加上A和B同时变为空的概率的一半是 0.25 *(1 + 1 + 0.5 + 0)= 0.625。  注释:  0 &amp;lt;= N &amp;lt;= 10^9。 返回值在10^-6的范围将被认为是正确的。  来源：力扣（LeetCode）第808题  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>摆动序列</title>
      <link>https://ripple-zjw.github.io/2019/%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/</link>
      <pubDate>Sat, 09 Nov 2019 21:28:46 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/</guid>
      <description>题目：摆动序列  如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。 例如，[1,7,4,9,2,5]是一个摆动序列，因为差值(6,-3,5,-7,3)是正负交替出现的。相反, [1,4,7,2,5]和[1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。 给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。  示例 1: 输入: [1,7,4,9,2,5] 输出: 6 解释: 整个序列均为摆动序列。  示例 2: 输入: [1,17,5,10,13,15,10,5,16,8] 输出: 7 解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。  示例 3: 输入: [1,2,3,4,5,6,7,8,9] 输出: 2  进阶:  你能否用O(n)时间复杂度完成此题?  来源：力扣（LeetCode）第376题  链接：https://leetcode-cn.com/problems/wiggle-subsequence
 分析：  首先这道题的方法实在是太多了。 我首先使用了二维dp做出了O(n^2)的方法。 一个状态是以数组i为结尾的最优情况，第二个状态是当前是处于递增还是递减状态。 如果是递增状态，那么就是前几次里的递减状态 + 1。 如果是递减状态，那么就是前几次里的递增状态 + 1。 再来说说进阶。 我们发现如果数组把它分为一段递增，一段递减，那么这一段内的所有数的答案都是一样的，因为，都是递减，前一段的最后那个数都比他们大，选哪个都可以，可是一旦选择了一个，这一段里都不能再选择第二个，下一个一定在下一段里。而这一段递增那么下一段就是递减。(所谓一段，就是一段数组内连续的数) 那这每一段内我要选择什么才合适呢？我们发现，如果是递减，我们就选择最小的那个，如果是递增就选择最大的那个。因为如果你选择最小的那个，那么下一个数要比它大，你选择的越小下一个找到比它大的数的可能性就越高，递增同理。 于是乎我们每一段都要贪心的去取最小或最大的数，也就是这一段单调的最后一个数。  代码：  dp
class Solution { public int wiggleMaxLength(int[] nums) { int len = nums.</description>
    </item>
    
    <item>
      <title>多边形三角剖分的最低得分</title>
      <link>https://ripple-zjw.github.io/2019/%E5%A4%9A%E8%BE%B9%E5%BD%A2%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86%E7%9A%84%E6%9C%80%E4%BD%8E%E5%BE%97%E5%88%86/</link>
      <pubDate>Sat, 09 Nov 2019 21:25:31 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%A4%9A%E8%BE%B9%E5%BD%A2%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86%E7%9A%84%E6%9C%80%E4%BD%8E%E5%BE%97%E5%88%86/</guid>
      <description>题目：多边形三角剖分的最低得分  给定N，想象一个凸N边多边形，其顶点按顺时针顺序依次标记为A[0], A[i], ..., A[N-1]。 假设您将多边形剖分为N-2个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有N-2个三角形的值之和。 返回多边形进行三角剖分后可以得到的最低分。  示例 1： 输入：[1,2,3] 输出：6 解释：多边形已经三角化，唯一三角形的分数为 6。  示例 2： 输入：[3,7,4,5] 输出：144 解释：有两种三角剖分，可能得分分别为：3*7*5 + 4*5*7 = 245，或 3*4*5 + 3*4*7 = 144。最低分数为 144。  示例 3： 输入：[1,3,1,4,1,5] 输出：13 解释：最低分数三角剖分的得分情况为 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13。  提示：  3 &amp;lt;= A.length &amp;lt;= 50 1 &amp;lt;= A[i] &amp;lt;= 100  来源：力扣（LeetCode）第1039题  链接：https://leetcode-cn.com/problems/minimum-score-triangulation-of-polygon
 分析：  可以使用dp或者dfs两种方法(好像很多题我都会这么讲。。。) 这两种方式的思路完全一致，唯一的不同就是一个是递归一个是dp。 我们声明两个状态i，j为从第i个位置开始，到第j个位置为止。 我们发现如果i==j-1的话，是不可能会有答案的，因为中间还要有第三个位置。 至少要i+2==j才行，这样中间才能有一个位置放第三个点。 也就是说如果中间有两个位置，那么第三个点就有两种可能，以此类推。 如果中间有多个位置，我们随便选择其中的一个，一个三角形的三个点就是i,j,k(中间的那个点)，那么另外n-3个三角形的顶点的值要怎么算呢？我们发现除去i,j,k这个三角形外，其他的三角形的值我们在小一维的dp里已经算过了(就是长度比当前长度小1的那些值)。 比如现在我们要找其他的三角形那么其他的三角形的值就是dp[i][k]和dp[k][j]里面，而这两个值肯定已经算过了，因为这两个值所代表的状态肯定比当前状态的长度要小。  代码：  dp</description>
    </item>
    
    <item>
      <title>组合总和</title>
      <link>https://ripple-zjw.github.io/2019/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C4/</link>
      <pubDate>Sat, 09 Nov 2019 21:23:14 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C4/</guid>
      <description>题目：组合总和 Ⅳ  给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。  示例: nums = [1, 2, 3] target = 4 所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) 请注意，顺序不同的序列被视作不同的组合。 因此输出为 7。  进阶：  如果给定的数组中含有负数会怎么样？ 问题会产生什么变化？ 我们需要在题目中添加什么限制来允许负数的出现？  来源：力扣（LeetCode）第377题  链接：https://leetcode-cn.com/problems/combination-sum-iv
 分析：  dp和dfs两种方法。  代码：  dp
class Solution { public int combinationSum4(int[] nums, int target) { int len = nums.length; int[] dp = new int[target+1]; dp[0] = 1; for (int i = 1; i &amp;lt;= target; i++) { for (int num : nums) if (i &amp;gt;= num) dp[i] += dp[i-num]; } return dp[target]; } }  dfs + 记忆化</description>
    </item>
    
    <item>
      <title>推多米诺</title>
      <link>https://ripple-zjw.github.io/2019/%E6%8E%A8%E5%A4%9A%E7%B1%B3%E8%AF%BA/</link>
      <pubDate>Sat, 09 Nov 2019 21:17:02 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%8E%A8%E5%A4%9A%E7%B1%B3%E8%AF%BA/</guid>
      <description>题目：推多米诺  一行中有N张多米诺骨牌，我们将每张多米诺骨牌垂直竖立。 在开始时，我们同时把一些多米诺骨牌向左或向右推。  每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。 同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。 如果同时有多米诺骨牌落在一张垂直竖立的多米诺骨牌的两边，由于受力平衡， 该骨牌仍然保持不变。 就这个问题而言，我们会认为正在下降的多米诺骨牌不会对其它正在下降或已经下降的多米诺骨牌施加额外的力。 给定表示初始状态的字符串 &amp;ldquo;S&amp;rdquo; 。如果第 i 张多米诺骨牌被推向左边，则S[i] = &#39;L&#39;；如果第 i 张多米诺骨牌被推向右边，则S[i] = &#39;R&#39;；如果第 i 张多米诺骨牌没有被推动，则S[i] = &#39;.&#39;。 返回表示最终状态的字符串。  示例 1： 输入：&amp;quot;.L.R...LR..L..&amp;quot; 输出：&amp;quot;LL.RR.LLRRLL..&amp;quot;  示例 2： 输入：&amp;quot;RR.L&amp;quot; 输出：&amp;quot;RR.L&amp;quot; 说明：第一张多米诺骨牌没有给第二张施加额外的力。  提示：  0 &amp;lt;= N &amp;lt;= 10^5 表示多米诺骨牌状态的字符串只含有 &amp;lsquo;L&amp;rsquo;，&amp;rsquo;R&amp;rsquo;; 以及 &amp;lsquo;.&amp;rsquo;;  来源：力扣（LeetCode）第838题  链接：https://leetcode-cn.com/problems/push-dominoes
 分析：  首先这道题只有&amp;rsquo;L&amp;rsquo; &amp;lsquo;R&amp;rsquo; &amp;lsquo;.&amp;rsquo; 这三个值，一开始没想到怎么用动态规划 然后想着想着灵光一闪，发现我只要把R变为1，L变为-1，.变为0，就可以使用dp来求解了。 第四行我们先开辟一个和字符串长度一样的dp数组，状态就是当前的位置，值是当前连续的次数。 就是从本来就为L或R的那个数开始，你是第几个倒的。比如有一个&amp;rsquo;R&amp;rsquo;,它的右边为2，再右边为3，以此类推。 5-8行为base case，本来就会倒的肯定是1，我们姑且把他们叫做源头，源头如果往旁边移动，则源头的值就变为移到的那个值。 9-21行为解题的主要部分，我们分几种情况 第10行为遍历到源头为R的时候，即dp对应的索引的值大于0，我们判断下一个元素的情况。 只有下一个为.的情况才可以连续，因为如果出现了RR的情况，依然不能连续，根据官方给出的第2个示例，一个点的左边有两个R,右边有1个L时，点不会改变。 11-20行为遍历到源头为L的时候，dp[i] 小于0，我们判断上一个元素的情况。 第11行由于判断源头L需要往前找，所以声明一个变量j，用于往前找。 第12行和前面第10行正好相反，需要注意的是，12行最后多了一个条件，这是因为如果源头R一直向右加，加到了L，那么L应该也要向左减，可是原来可能是0的值被源头R覆盖了，所以我们要做一个判断。 首先如果对于源头L,左边为0，那么可以过去，其次源头R的值比源头L的值大，我们也可以移，直到源头R和源头L的绝对值相等，那么左右两边就平衡了。 不过，还有一种情况，就是中间这个点既不是源头左的，也不是源头右的。 我们在13-15行做一次特殊情况的判断，如果中间有一个值不属于两个源头而是.</description>
    </item>
    
    <item>
      <title>目标和</title>
      <link>https://ripple-zjw.github.io/2019/%E7%9B%AE%E6%A0%87%E5%92%8C/</link>
      <pubDate>Sat, 09 Nov 2019 21:14:39 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%9B%AE%E6%A0%87%E5%92%8C/</guid>
      <description>题目：目标和  给定一个非负整数数组，a1, a2, &amp;hellip;, an, 和一个目标数，S。现在你有两个符号+和-。对于数组中的任意一个整数，你都可以从+或-中选择一个符号添加在前面。 返回可以使最终数组和为目标数 S 的所有添加符号的方法数。  示例 1: 输入: nums: [1, 1, 1, 1, 1], S: 3 输出: 5 解释: -1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3 一共有5种方法让最终目标和为3。  注意:  数组非空，且长度不会超过20。 初始的数组的和不会超过1000。 保证返回的最终结果能被32位整数存下。  来源：力扣（LeetCode）第494题  链接：https://leetcode-cn.com/problems/target-sum
 分析：  这是一道动态规划题，也可以使用dfs完成。 此外，还有一种使用数学方法来简化的dp。 常规dp很简单，第一个状态是当前为第几个，第二个状态为当前的和是多少。 我们有两种选择，第一种是当前为+号，那么用当前的和减去当前的值去找上一次的和。 如果当前是-号，就用当前的和加上当前的值去找上一次的和。 然后来看看数学方法简化dp。 设x为其中一个解的正数和，y为其中一个解的负数和的绝对值。 因此我们可以得到两个公式 x + y = sum(sum是整个数组的和) x - y = S(S是目标值) 上下一相加，得x = (sum + S) / 2 因此我们只要知道x有多少种可能就行了 所以问题转化为01背包问题，找到当长度为数组长度时，x有多少种可能。状态直接转为一维。 x也就是符号为正的情况。  代码：  先放上常规dp</description>
    </item>
    
    <item>
      <title>“马”在棋盘上的概率</title>
      <link>https://ripple-zjw.github.io/2019/%E9%A9%AC%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/</link>
      <pubDate>Wed, 23 Oct 2019 20:17:40 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E9%A9%AC%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/</guid>
      <description>题目：“马”在棋盘上的概率  已知一个NxN的国际象棋棋盘，棋盘的行号和列号都是从 0 开始。即最左上角的格子记为(0, 0)，最右下角的记为(N-1, N-1)。 现有一个 “马”（也译作 “骑士”）位于(r, c)，并打算进行K 次移动。 如下图所示，国际象棋的 “马” 每一步先沿水平或垂直方向移动 2 个格子，然后向与之相垂直的方向再移动 1 个格子，共有 8 个可选的位置。  现在 “马” 每一步都从可选的位置（包括棋盘外部的）中独立随机地选择一个进行移动，直到移动了K次或跳到了棋盘外面。 求移动结束后，“马” 仍留在棋盘上的概率。  示例： 输入: 3, 2, 0, 0 输出: 0.0625 解释: 输入的数据依次为 N, K, r, c 第 1 步时，有且只有 2 种走法令 “马” 可以留在棋盘上（跳到（1,2）或（2,1））。对于以上的两种情况，各自在第2步均有且只有2种走法令 “马” 仍然留在棋盘上。 所以 “马” 在结束后仍在棋盘上的概率为 0.0625。  注意：  N 的取值范围为 [1, 25] K 的取值范围为 [0, 100] 开始时，“马” 总是位于棋盘上  来源：力扣（LeetCode）第688题  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>最长上升子序列</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Wed, 23 Oct 2019 20:15:25 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>题目：最长上升子序列  给定一个无序的整数数组，找到其中最长上升子序列的长度。  示例: 输入: [10,9,2,5,3,7,101,18] 输出: 4 解释: 最长的上升子序列是[2,3,7,101]，它的长度是 4。  说明:  可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为O(n^2)。 进阶: 你能将算法的时间复杂度降低到O(n logn)吗?  来源：力扣（LeetCode）第300题  链接：https://leetcode-cn.com/problems/longest-increasing-subsequence
 分析：  非常好的一道题目 可以使用动态规划来解决。 除了最常规的一种方法外还有另一种动态规划的方法，使用二分查找的思想。 具体可以看看搜索插入位置(LeetCode第35题) 动态规划：  设1个状态表示到这个数为止，最长上升子序列是多少。 然后遍历数组，当遍历到第i个状态时，查看在dp中到第i个数为止已经有多长了，那么你只要在右边找到比当前数大的值，然后在它的dp数组下加上1。 最后找到dp数组中最大的值，就是答案。  dp + 二分查找：  我们遍历数组，将每个数放进dp数组中。 由于dp数组是单调递增的，所以可以使用二分查找找到插入的位置。 有两种情况，如果找到了这个值，那么直接覆盖就行了，如果没找到这个值，那么将比它大的最小的值覆盖。其实就是插入位置。   代码：  dp
class Solution { public int lengthOfLIS(int[] nums) { int len = nums.length; int[] dp = new int[len]; Arrays.fill(dp, 1); for (int i = 0; i &amp;lt; len; i++) { for (int j = i + 1; j &amp;lt; len; j++) { if (nums[i] &amp;lt; nums[j]) dp[j] = Math.</description>
    </item>
    
    <item>
      <title>最长的斐波那契子序列的长度</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Wed, 23 Oct 2019 20:09:39 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/</guid>
      <description>题目：最长的斐波那契子序列的长度  如果序列X_1, X_2, ..., X_n满足下列条件，就说它是斐波那契式的： n &amp;gt;= 3 对于所有i + 2 &amp;lt;= n，都有X_i + X_{i+1} = X_{i+2} 给定一个严格递增的正整数数组形成序列，找到 A 中最长的斐波那契式的子序列的长度。如果一个不存在，返回0 。 （回想一下，子序列是从原序列A中派生出来的，它从A中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如，[3, 5, 8]是[3, 4, 5, 6, 7, 8]的一个子序列）  示例 1： 输入: [1,2,3,4,5,6,7,8] 输出: 5 解释: 最长的斐波那契式子序列为：[1,2,3,5,8] 。  示例2： 输入: [1,3,7,11,12,14,18] 输出: 3 解释: 最长的斐波那契式子序列有： [1,11,12]，[3,11,14] 以及 [7,11,18] 。  提示：  3 &amp;lt;= A.length &amp;lt;= 1000 1 &amp;lt;= A[0] &amp;lt; A[1] &amp;lt; &amp;hellip; &amp;lt; A[A.length - 1] &amp;lt;= 10^9 （对于以 Java，C，C++，以及C# 的提交，时间限制被减少了 50%）  来源：力扣（LeetCode）第873题  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>最大平均值和的分组</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC%E5%92%8C%E7%9A%84%E5%88%86%E7%BB%84/</link>
      <pubDate>Wed, 23 Oct 2019 20:03:28 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC%E5%92%8C%E7%9A%84%E5%88%86%E7%BB%84/</guid>
      <description>题目： 最大平均值和的分组  我们将给定的数组A分成K个相邻的非空子数组 ，我们的分数由每个子数组内的平均值的总和构成。计算我们所能得到的最大分数是多少。 注意我们必须使用A数组中的每一个数进行分组，并且分数不一定需要是整数。  示例: 输入: A = [9,1,2,3,9] K = 3 输出: 20 解释: A 的最优分组是[9], [1, 2, 3], [9]. 得到的分数是 9 + (1 + 2 + 3) / 3 + 9 = 20. 我们也可以把 A 分成[9, 1], [2], [3, 9]. 这样的分组得到的分数为 5 + 2 + 6 = 13, 但不是最大值.  说明:  1 &amp;lt;= A.length &amp;lt;= 100. 1 &amp;lt;= A[i] &amp;lt;= 10000. 1 &amp;lt;= K &amp;lt;= A.</description>
    </item>
    
    <item>
      <title>分割等和子集</title>
      <link>https://ripple-zjw.github.io/2019/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</link>
      <pubDate>Wed, 23 Oct 2019 19:58:28 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</guid>
      <description> 题目：分割等和子集  给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。  注意:  每个数组中的元素不会超过 100 数组的大小不会超过 200  示例 1: 输入: [1, 5, 11, 5] 输出: true 解释: 数组可以分割成 [1, 5, 5] 和 [11].  示例2: 输入: [1, 2, 3, 5] 输出: false 解释: 数组不能分割成两个元素和相等的子集.  来源：力扣（LeetCode）第416题  链接：https://leetcode-cn.com/problems/partition-equal-subset-sum
 分析：  动态规划题 0-1背包问题  代码： class Solution { public boolean canPartition(int[] nums) { int sum = 0; int len = nums.length; for (int num : nums) sum += num; if ((sum &amp;amp; 1) == 1) return false; // 如果是奇数，不可能分割 sum &amp;gt;&amp;gt;= 1; // 要找的答案是总和的一半。 boolean[][] dp = new boolean[len][sum+1]; // i表示nums中从0到i为止，j表示是否能找到和为j的数。 if (nums[0] &amp;lt;= sum) dp[0][nums[0]] = true; // 第一个数放在j上，其他都是false for (int i = 1; i &amp;lt; len; i++) { for (int j = 0; j &amp;lt;= sum; j++) { if (nums[i] &amp;lt;= j) // 两种选择，一种之前就找到了和为j的数，那么现在还是true。 // 如果之前没有找到和为j的数，那么我加上这次的数，要找前一次j-nums[i]的和能不能找到。 dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]]; else // 如果当前nums[i] 大于j的话，之前看它前一次是什么状态现在还是什么状态。 dp[i][j] = dp[i-1][j]; } } return dp[len-1][sum]; } }  </description>
    </item>
    
    <item>
      <title>抛掷硬币</title>
      <link>https://ripple-zjw.github.io/2019/%E6%8A%9B%E6%8E%B7%E7%A1%AC%E5%B8%81/</link>
      <pubDate>Wed, 23 Oct 2019 19:43:25 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%8A%9B%E6%8E%B7%E7%A1%AC%E5%B8%81/</guid>
      <description> 题目：抛掷硬币  有一些不规则的硬币。在这些硬币中，prob[i]表示第i枚硬币正面朝上的概率。  请对每一枚硬币抛掷一次，然后返回正面朝上的硬币数等于target的概率。
示例 1： 输入：prob = [0.4], target = 1 输出：0.40000  示例 2： 输入：prob = [0.5,0.5,0.5,0.5,0.5], target = 0 输出：0.03125  提示：  1 &amp;lt;= prob.length &amp;lt;= 1000 0 &amp;lt;= prob[i] &amp;lt;= 1 0 &amp;lt;= target&amp;lt;= prob.length 如果答案与标准答案的误差在10^-5内，则被视为正确答案。  来源：力扣（LeetCode）第5090题(临时)  链接：https://leetcode-cn.com/problems/toss-strange-coins
 分析：  概率dp 找到两个状态，一个是当前扔了第几个硬币，另一个是有几个正面朝上。  代码： class Solution { public double probabilityOfHeads(double[] prob, int target) { int n = prob.length; // 滚动数组，由于这个dp只要用到前一个状态，所以没必要把所有的硬币情况都写出来。 // dp数组表示当前有i个硬币，j个硬币正面朝上。 double[][] dp = new double[2][target+2]; dp[0][0] = 1; // 当前没有硬币，0个硬币朝上的概率为100% for (int ii = 1; ii &amp;lt;= n; ii++) { int i = ii &amp;amp; 1; // 如果最后一位是1，那么i=1，如果最后一位是0，那么i=0 int pi = i ^ 1; // 如果i=1，那么异或1得0，如果i=0，那么异或1得1 for (int j = 0; j &amp;lt;= target; j++) dp[i][j] = 0; // 由于滚动数组，所以要把之前的清空。 for (int j = 0; j &amp;lt;= target; j++) { dp[i][j] += dp[pi][j] * (1 - prob[ii-1]); // 当前有i个硬币，如果第i个硬币扔的是反面，那么i-1个硬币必须要有j个是正面。 dp[i][j+1] += dp[pi][j] * prob[ii-1]; // 如果扔的是正面，那么i-1个硬币必须要有j-1个时正面。 } } // n是奇数那么索引就是1，如果n是偶数的话，那么它答案的索引就是0 return dp[n&amp;amp;1][target]; } }  </description>
    </item>
    
    <item>
      <title>填充书架</title>
      <link>https://ripple-zjw.github.io/2019/%E5%A1%AB%E5%85%85%E4%B9%A6%E6%9E%B6/</link>
      <pubDate>Wed, 23 Oct 2019 19:34:22 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%A1%AB%E5%85%85%E4%B9%A6%E6%9E%B6/</guid>
      <description>题目：填充书架  附近的家居城促销，你买回了一直心仪的可调节书架，打算把自己的书都整理到新的书架上。 你把要摆放的书books都整理好，叠成一摞：从上往下，第i本书的厚度为books[i][0]，高度为books[i][1]。 按顺序将这些书摆放到总宽度为shelf_width的书架上。 先选几本书放在书架上（它们的厚度之和小于等于书架的宽度 shelf_width），然后再建一层书架。重复这个过程，直到把所有的书都放在书架上。 需要注意的是，在上述过程的每个步骤中，摆放书的顺序与你整理好的顺序相同。 例如，如果这里有 5 本书，那么可能的一种摆放情况是：第一和第二本书放在第一层书架上，第三本书放在第二层书架上，第四和第五本书放在最后一层书架上。 每一层所摆放的书的最大高度就是这一层书架的层高，书架整体的高度为各层高之和。 以这种方式布置书架，返回书架整体可能的最小高度。  示例： 输入：books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelf_width = 4 输出：6 解释： 3 层书架的高度和为 1 + 3 + 2 = 6 。 第 2 本书不必放在第一层书架上。  提示：
 1 &amp;lt;= books.length &amp;lt;= 1000 1 &amp;lt;= books[i][0] &amp;lt;= shelf_width &amp;lt;= 1000 1 &amp;lt;= books[i][1] &amp;lt;= 1000  来源：力扣（LeetCode）第1105题  链接：https://leetcode-cn.com/problems/filling-bookcase-shelves
 分析：  动态规划题 这道题的状态很简单，却很难想到。 我们设i为到第i本书为止的最优情况。 如果i之前都已是最优情况，那么第i种情况怎么算呢？ 首先直接换行，那么就是i-1时的最优情况加上这本书的高度。 第二种，我们把第i-1本书和第i本书放在一起，那么就是第i本书和第i-1本最高的那本加上i-2时的最优情况。 以此类推，直到把所有书都放在同一行，或者宽度不够了，下一本书放不进去了。  代码： class Solution { public int minHeightShelves(int[][] books, int shelf_width) { int m = books.</description>
    </item>
    
    <item>
      <title>掷骰子模拟</title>
      <link>https://ripple-zjw.github.io/2019/%E6%8E%B7%E9%AA%B0%E5%AD%90%E6%A8%A1%E6%8B%9F/</link>
      <pubDate>Wed, 23 Oct 2019 19:26:07 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%8E%B7%E9%AA%B0%E5%AD%90%E6%A8%A1%E6%8B%9F/</guid>
      <description>题目：掷骰子模拟  有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。 不过我们在使用它时有个约束，就是使得投掷骰子时，连续 掷出数字i的次数不能超过rollMax[i]（i从 1 开始编号）。  现在，给你一个整数数组rollMax和一个整数n，请你来计算掷n次骰子可得到的不同点数序列的数量。
假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 模10^9 + 7之后的结果。
示例 1： 输入：n = 2, rollMax = [1,1,2,2,2,3] 输出：34 解释：我们掷 2 次骰子，如果没有约束的话，共有 6 * 6 = 36 种可能的组合。但是根据 rollMax 数组，数字 1 和 2 最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。因此，最终答案是 36-2 = 34。  示例 2： 输入：n = 2, rollMax = [1,1,1,1,1,1] 输出：30 示例 3： 输入：n = 3, rollMax = [1,1,1,2,2,3] 输出：181  提示：  1 &amp;lt;= n &amp;lt;= 5000 rollMax.</description>
    </item>
    
    <item>
      <title>一和零</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%80%E5%92%8C%E9%9B%B6/</link>
      <pubDate>Wed, 23 Oct 2019 19:21:28 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%80%E5%92%8C%E9%9B%B6/</guid>
      <description>题目： 一和零  在计算机界中，我们总是追求用有限的资源获取最大的收益。 现在，假设你分别支配着 m 个0和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。 你的任务是使用给定的m个0和n 个1，找到能拼出存在于数组中的字符串的最大数量。每个0和1至多被使用一次。  注意:  给定0和1的数量都不会超过100。 给定字符串数组的长度不会超过600。  示例 1: 输入: Array = {&amp;quot;10&amp;quot;, &amp;quot;0001&amp;quot;, &amp;quot;111001&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;},m = 5, n = 3 输出: 4 解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 &amp;quot;10&amp;quot;,&amp;quot;0001&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot; 。  示例 2: 输入: Array = {&amp;quot;10&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;}, m = 1, n = 1 输出: 2 解释: 你可以拼出 &amp;quot;10&amp;quot;，但之后就没有剩余数字了。更好的选择是拼出 &amp;quot;0&amp;quot; 和 &amp;quot;1&amp;quot; 。  来源：力扣（LeetCode）第474题  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>删除与获得点数</title>
      <link>https://ripple-zjw.github.io/2019/%E5%88%A0%E9%99%A4%E4%B8%8E%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0/</link>
      <pubDate>Wed, 23 Oct 2019 19:13:59 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%88%A0%E9%99%A4%E4%B8%8E%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0/</guid>
      <description>删除与获得点数  给定一个整数数组nums，你可以对它进行一些操作。 每次操作中，选择任意一个nums[i]，删除它并获得nums[i]的点数。之后，你必须删除每个等于nums[i] - 1或nums[i] + 1的元素。 开始你拥有0个点数。返回你能通过这些操作获得的最大点数。  示例 1: 输入: nums = [3, 4, 2] 输出: 6 解释: 删除 4 来获得 4 个点数，因此 3 也被删除。 之后，删除 2 来获得 2 个点数。总共获得 6 个点数。  示例 2: 输入: nums = [2, 2, 3, 3, 3, 4] 输出: 9 解释: 删除 3 来获得 3 个点数，接着要删除两个 2 和 4 。 之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。 总共获得 9 个点数。  注意:  nums的长度最大为20000。 每个整数nums[i]的大小都在[1, 10000]范围内。  来源：力扣（LeetCode）第740题  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>石子游戏II</title>
      <link>https://ripple-zjw.github.io/2019/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8Fii/</link>
      <pubDate>Wed, 23 Oct 2019 19:06:38 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8Fii/</guid>
      <description>题目：石子游戏 II  亚历克斯和李继续他们的石子游戏。许多堆石子排成一行，每堆都有正整数颗石子piles[i]。游戏以谁手中的石子最多来决出胜负。 亚历克斯和李轮流进行，亚历克斯先开始。最初，M = 1。 在每个玩家的回合中，该玩家可以拿走剩下的前X堆的所有石子，其中1 &amp;lt;= X &amp;lt;= 2M。然后，令M = max(M, X)。 游戏一直持续到所有石子都被拿走。 假设亚历克斯和李都发挥出最佳水平，返回亚历克斯可以得到的最大数量的石头。  示例： 输入：piles = [2,7,9,4,4] 输出：10 解释： 如果亚历克斯在开始时拿走一堆石子，李拿走两堆，接着亚历克斯也拿走两堆。在这种情况下，亚历克斯可以拿到 2 + 4 + 4 = 10 颗石子。 如果亚历克斯在开始时拿走两堆石子，那么李就可以拿走剩下全部三堆石子。在这种情况下，亚历克斯可以拿到 2 + 7 = 9 颗石子。 所以我们返回更大的 10。  提示：  1 &amp;lt;= piles.length &amp;lt;= 100 1 &amp;lt;= piles[i] &amp;lt;= 10 ^ 4  来源：力扣（LeetCode）第1140题  链接：https://leetcode-cn.com/problems/stone-game-ii
 分析：  这道题可以采用递归加记忆化搜索的方式进行。 我们需要穷举出所有的状态。 由于重复计算的地方太多，所以使用记忆化搜索，也可以说使用了动态规划。  代码： class Solution { int len; int[] sum;int[][] dp; public int stoneGameII(int[] piles) { dp = new int[150][150]; // dp数组用来存放算过的值。 len = piles.</description>
    </item>
    
    <item>
      <title>叶值的最小代价生成树</title>
      <link>https://ripple-zjw.github.io/2019/%E5%8F%B6%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7%E7%94%9F%E6%88%90%E6%A0%91/</link>
      <pubDate>Wed, 23 Oct 2019 19:00:35 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%8F%B6%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7%E7%94%9F%E6%88%90%E6%A0%91/</guid>
      <description>题目：叶值的最小代价生成树  给你一个正整数数组arr，考虑所有满足以下条件的二叉树：  每个节点都有 0 个或是 2 个子节点。 数组arr中的值与树的中序遍历中每个叶节点的值一一对应。（知识回顾：如果一个节点有 0 个子节点，那么该节点为叶节点。） 每个非叶节点的值等于其左子树和右子树中叶节点的最大值的乘积。 在所有这样的二叉树中，返回每个非叶节点的值的最小可能总和。这个和的值是一个32 位整数。   示例： 输入：arr = [6,2,4] 输出：32 解释： 有两种可能的树，第一种的非叶节点的总和为 36，第二种非叶节点的总和为 32。 24 24 / \ / \ 12 4 6 8 / \ / \ 6 2 2 4  提示：  2 &amp;lt;= arr.length &amp;lt;= 40 1 &amp;lt;= arr[i] &amp;lt;= 15 答案保证是一个 32 位带符号整数，即小于2^31。  来源：力扣（LeetCode）第1130题  链接：https://leetcode-cn.com/problems/minimum-cost-tree-from-leaf-values
 分析：  这道题有两种解法，一种是动态规划，另一种是使用单调栈。  代码： 动态规划：  我们发现数组中的数可以划分为两部分，一半是左子树，一半是右子树，根节点就是左边最大和右边最大的乘积。 而左右子树里面的值就是当数组中的数为左子树的叶子节点时的情况，右边一样。 直到数组中的数只有2个时，答案就是左边右边相乘。 因此我们可以这么看，如果2个数后面又加了一个数，那么我们可以以01为一个节点再和2划分,也可以0一个节点和12划分。 树的左右两边至少有1个叶子结点。 如果有四个数，有0 123, 01 23, 012 3,同时3个数又有之前的情况。 因此我可以这样找状态，i代表起始点,j代表结束位置。如果我想知道4个数的答案，我就把上面划分的情况算出来，每一个情况还要加上左边和右边的最大值的乘积，作为根节点。 于是乎我就是要穷举所有状态。</description>
    </item>
    
    <item>
      <title>统计元音字母序列的数目</title>
      <link>https://ripple-zjw.github.io/2019/%E7%BB%9F%E8%AE%A1%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D%E5%BA%8F%E5%88%97%E7%9A%84%E6%95%B0%E7%9B%AE/</link>
      <pubDate>Wed, 23 Oct 2019 18:58:05 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%BB%9F%E8%AE%A1%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D%E5%BA%8F%E5%88%97%E7%9A%84%E6%95%B0%E7%9B%AE/</guid>
      <description>题目：统计元音字母序列的数目  给你一个整数n，请你帮忙统计一下我们可以按下述规则形成多少个长度为n的字符串 字符串中的每个字符都应当是小写元音字母（&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, &#39;u&#39;） 每个元音&#39;a&#39;后面都只能跟着&#39;e&#39; 每个元音&#39;e&#39;后面只能跟着&#39;a&#39;或者是&#39;i&#39; 每个元音&#39;i&#39;后面不能再跟着另一个&#39;i&#39; 每个元音&#39;o&#39;后面只能跟着&#39;i&#39;或者是&#39;u&#39; 每个元音&#39;u&#39;后面只能跟着&#39;a&#39; 由于答案可能会很大，所以请你返回 模10^9 + 7之后的结果。  示例 1： 输入：n = 1 输出：5 解释：所有可能的字符串分别是：&amp;quot;a&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;i&amp;quot; , &amp;quot;o&amp;quot; 和 &amp;quot;u&amp;quot;。  示例 2： 输入：n = 2 输出：10 解释：所有可能的字符串分别是：&amp;quot;ae&amp;quot;, &amp;quot;ea&amp;quot;, &amp;quot;ei&amp;quot;, &amp;quot;ia&amp;quot;, &amp;quot;ie&amp;quot;, &amp;quot;io&amp;quot;, &amp;quot;iu&amp;quot;, &amp;quot;oi&amp;quot;, &amp;quot;ou&amp;quot; 和 &amp;quot;ua&amp;quot;。  示例 3： 输入：n = 5 输出：68  提示：  1 &amp;lt;= n &amp;lt;= 2 * 10^4  来源：力扣（LeetCode）第5216题(临时)  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>大礼包</title>
      <link>https://ripple-zjw.github.io/2019/%E5%A4%A7%E7%A4%BC%E5%8C%85/</link>
      <pubDate>Tue, 01 Oct 2019 21:49:17 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%A4%A7%E7%A4%BC%E5%8C%85/</guid>
      <description>题目：大礼包  在LeetCode商店中， 有许多在售的物品。 然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。 现给定每个物品的价格，每个大礼包包含物品的清单，以及待购物品清单。请输出确切完成待购清单的最低花费。 每个大礼包的由一个数组中的一组数据描述，最后一个数字代表大礼包的价格，其他数字分别表示内含的其他种类物品的数量。 任意大礼包可无限次购买。  示例 1: 输入: [2,5], [[3,0,5],[1,2,10]], [3,2] 输出: 14 解释: 有A和B两种物品，价格分别为¥2和¥5。 大礼包1，你可以以¥5的价格购买3A和0B。 大礼包2， 你可以以¥10的价格购买1A和2B。 你需要购买3个A和2个B， 所以你付了¥10购买了1A和2B（大礼包2），以及¥4购买2A。  示例 2: 输入: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1] 输出: 11 解释: A，B，C的价格分别为¥2，¥3，¥4. 你可以用¥4购买1A和1B，也可以用¥9购买2A，2B和1C。 你需要买1A，2B和1C，所以你付了¥4买了1A和1B（大礼包1），以及¥3购买1B， ¥4购买1C。 你不可以购买超出待购清单的物品，尽管购买大礼包2更加便宜。  说明:  最多6种物品， 100种大礼包。 每种物品，你最多只需要购买6个。 你不可以购买超出待购清单的物品，即使更便宜。  来源：力扣（LeetCode）第638题  链接：https://leetcode-cn.com/problems/shopping-offers
 分析：  动态规划解法，常规解法需要使用六维数组，实在太麻烦，而且每次的维度还不一样。 使用状压dp的思想，把六维数组归为1维。 因为每一维的长度是0-6，所以我们把这7个数变为一个七进制的数字，但是把它变为10进制存在一个一维数组中。 比如111就是57，它表示a,b,c各有1个。如果是4个1，那就是a,b,c,d各有1个，然后它也有对应的十进制数。 因此，我们把needs中的数看成是一个七进制数，然后把它以十进制表示出来。 比如need如果是121，那么结果是64。那么我们就开辟一个65个的数组。最后把dp[64]返回就是最终答案了。  代码： class Solution { public int shoppingOffers(List&amp;lt;Integer&amp;gt; price, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; special, List&amp;lt;Integer&amp;gt; needs) { int[] Decinal = {1, 7, 49, 343, 2401, 16807, 117649}; // 7的一次方，7的二次方.</description>
    </item>
    
    <item>
      <title>穿过迷宫的最少移动次数</title>
      <link>https://ripple-zjw.github.io/2019/%E7%A9%BF%E8%BF%87%E8%BF%B7%E5%AE%AB%E7%9A%84%E6%9C%80%E5%B0%91%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0/</link>
      <pubDate>Tue, 01 Oct 2019 21:43:48 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%A9%BF%E8%BF%87%E8%BF%B7%E5%AE%AB%E7%9A%84%E6%9C%80%E5%B0%91%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0/</guid>
      <description>题目：穿过迷宫的最少移动次数  你还记得那条风靡全球的贪吃蛇吗？ 我们在一个n*n的网格上构建了新的迷宫地图，蛇的长度为 2，也就是说它会占去两个单元格。蛇会从左上角(0, 0)和(0, 1)开始移动。我们用 0 表示空单元格，用 1 表示障碍物。蛇需要移动到迷宫的右下角(n-1, n-2)和(n-1, n-1)。 每次移动，蛇可以这样走：  如果没有障碍，则向右移动一个单元格。并仍然保持身体的水平／竖直状态。 如果没有障碍，则向下移动一个单元格。并仍然保持身体的水平／竖直状态。 如果它处于水平状态并且其下面的两个单元都是空的，就顺时针旋转 90 度。蛇从（(r, c)、(r, c+1)）移动到 （(r, c)、(r+1, c)）。  如果它处于竖直状态并且其右面的两个单元都是空的，就逆时针旋转 90 度。蛇从（(r, c)、(r+1, c)）移动到（(r, c)、(r, c+1)）。   返回蛇抵达目的地所需的最少移动次数。 如果无法到达目的地，请返回-1。  示例 1： 输入：grid = [[0,0,0,0,0,1], [1,1,0,0,1,0], [0,0,0,0,1,1], [0,0,1,0,1,0], [0,1,1,0,0,0], [0,1,1,0,0,0]] 输出：11 解释： 一种可能的解决方案是 [右, 右, 顺时针旋转, 右, 下, 下, 下, 下, 逆时针旋转, 右, 下]。  示例 2： 输入：grid = [[0,0,1,1,1,1], [0,0,0,0,1,1], [1,1,0,0,0,1], [1,1,1,0,0,1], [1,1,1,0,0,1], [1,1,1,0,0,0]] 输出：9  提示：  2 &amp;lt;= n &amp;lt;= 100 0 &amp;lt;= grid[i][j] &amp;lt;= 1 蛇保证从空单元格开始出发。  来源：力扣（LeetCode）第5208题(临时)  链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>买卖股票的最佳时机含手续费</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/</link>
      <pubDate>Tue, 01 Oct 2019 21:42:37 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/</guid>
      <description>题目：买卖股票的最佳时机含手续费  给定一个整数数组prices，其中第i个元素代表了第i天的股票价格 ；非负整数fee代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。  示例 1: 输入: prices = [1, 3, 2, 8, 4, 9], fee = 2 输出: 8 解释: 能够达到的最大利润: 在此处买入 prices[0] = 1 在此处卖出 prices[3] = 8 在此处买入 prices[4] = 4 在此处卖出 prices[5] = 9 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.  注意:  0 &amp;lt; prices.length &amp;lt;= 50000. 0 &amp;lt; prices[i] &amp;lt; 50000. 0 &amp;lt;= fee &amp;lt; 50000.</description>
    </item>
    
    <item>
      <title>两个字符串的最小ASCII删除和</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8Fascii%E5%88%A0%E9%99%A4%E5%92%8C/</link>
      <pubDate>Tue, 01 Oct 2019 21:36:41 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8Fascii%E5%88%A0%E9%99%A4%E5%92%8C/</guid>
      <description>题目：两个字符串的最小ASCII删除和  给定两个字符串s1,s2，找到使两个字符串相等所需删除字符的ASCII值的最小和。  示例 1: 输入: s1 = &amp;quot;sea&amp;quot;, s2 = &amp;quot;eat&amp;quot; 输出: 231 解释: 在 &amp;quot;sea&amp;quot; 中删除 &amp;quot;s&amp;quot; 并将 &amp;quot;s&amp;quot; 的值(115)加入总和。 在 &amp;quot;eat&amp;quot; 中删除 &amp;quot;t&amp;quot; 并将 116 加入总和。 结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。  示例 2: 输入: s1 = &amp;quot;delete&amp;quot;, s2 = &amp;quot;leet&amp;quot; 输出: 403 解释: 在 &amp;quot;delete&amp;quot; 中删除 &amp;quot;dee&amp;quot; 字符串变成 &amp;quot;let&amp;quot;， 将 100[d]+101[e]+101[e] 加入总和。在 &amp;quot;leet&amp;quot; 中删除 &amp;quot;e&amp;quot; 将 101[e] 加入总和。 结束时，两个字符串都等于 &amp;quot;let&amp;quot;，结果即为 100+101+101+101 = 403 。 如果改为将两个字符串转换为 &amp;quot;lee&amp;quot; 或 &amp;quot;eet&amp;quot;，我们会得到 433 或 417 的结果，比答案更大。  注意:  0 &amp;lt; s1.</description>
    </item>
    
    <item>
      <title>不同的二叉搜索树II</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91ii/</link>
      <pubDate>Tue, 01 Oct 2019 21:34:34 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91ii/</guid>
      <description>题目：不同的二叉搜索树 II  给定一个整数n，生成所有由1...n为节点所组成的二叉搜索树。  示例: 输入: 3 输出: [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ] 解释: 以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3  来源：力扣（LeetCode）第95题  链接：https://leetcode-cn.com/problems/unique-binary-search-trees-ii
 分析：  可以使用递归，但我怕超时就没写。 但是几乎所有的递归都可以转换为动态规划，所以这题用dp求解。 思路和前面找个数一样，状态都是第n个数的内容，选择是谁为根节点。 不一样的是状态转移方程稍稍有点复杂，我在代码中说明。  代码： /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public List&amp;lt;TreeNode&amp;gt; generateTrees(int n) { List&amp;lt;TreeNode&amp;gt;[] dp = new ArrayList[n+1]; dp[0] = new ArrayList(); // 如果left或right为0，就会出现空指针异常。 if (n == 0) return dp[0]; dp[0].</description>
    </item>
    
    <item>
      <title>石子游戏</title>
      <link>https://ripple-zjw.github.io/2019/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/</link>
      <pubDate>Tue, 01 Oct 2019 21:32:58 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/</guid>
      <description>题目：石子游戏  亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子piles[i]。 游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。 亚历克斯和李轮流进行，亚历克斯先开始。每回合，玩家从行的开始或结束处取走整堆石头。这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。 假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回true，当李赢得比赛时返回false。  示例： 输入：[5,3,4,5] 输出：true 解释： 亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。 假设他取了前 5 颗，这一行就变成了 [3,4,5] 。 如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。 如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。 这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。  提示：  2 &amp;lt;= piles.length &amp;lt;= 500 piles.length 是偶数。 1 &amp;lt;= piles[i] &amp;lt;= 500 sum(piles)是奇数。  来源：力扣（LeetCode）第877题  链接：https://leetcode-cn.com/problems/stone-game
 分析：  这是一道典型的动态规划题。 要做出动态规划问题，首先要找到问题的状态和选择。 以这道题为例，状态有三种，分别是开始位置索引i，结束位置索引j，还有在i到j这段位置时，先手的值和后手的值。 举个例子，i = 0, j = 0时，表明在第一个索引0时先手明显是piles[0]，而后手没有东西，所以是0。 说完状态再来看选择，根据题意，选择就是你可以从开始位置i拿，也可以从结束位置j拿。 然后是状态转移方程，首先每一个i和j所对应的位置都有先后手两种情况，如果我选择拿了i的值，那么剩下留给另一个人的元素就是i + 1 到 j,而i + 1 到 j是另一个人先手拿的(i+1,j先手就是i,j的后手，因为一人一次)，所以你拿的是i+1, j的后手。 同理如果你拿的是右边的j，那么剩下的就是i, j - 1的后手。 因此状态转移方程就是：max(piles[i] + dp[i+1][j][1], piles[j] + dp[i][j-1][1])。dp是一个三维数组，前两个表示的是i,j位置索引，而1表示的是后手情况，那么0表示的是先手情况。(不一定是0,1也可以是别的，无所谓) 最后我要的结果就是从0到piles长度的下标，即dp[0][piles.</description>
    </item>
    
    <item>
      <title>比特位计数</title>
      <link>https://ripple-zjw.github.io/2019/%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/</link>
      <pubDate>Sat, 21 Sep 2019 16:04:38 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/</guid>
      <description> 题目：比特位计数  给定一个非负整数num。对于0 ≤ i ≤ num 范围中的每个数字i，计算其二进制数中的1 的数目并将它们作为数组返回。  示例 1: 输入: 2 输出: [0,1,1]  示例 2: 输入: 5 输出: [0,1,1,2,1,2]  进阶:  给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？ 要求算法的空间复杂度为O(n)。 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如C++中的__builtin_popcount）来执行此操作。  来源：力扣（LeetCode）第338题  链接：https://leetcode-cn.com/problems/counting-bits
 分析：  由于偶数的二进制数最后一位是0，所以如果一个偶数做&amp;gt;&amp;gt;1运算那么它的1的个数不变。同理如果一个奇数右移一位，1的个数减1。 因此如果1有1个1，那么2也有1个1,3就有2个1。(正推的话做左移运算),如果2有1个1的话，那么4也是1个1,5就是2个1。 所以有了状态转换公式dp[2*i] = dp[i] dp[2*i+1] = dp[i] + 1  代码： class Solution { public int[] countBits(int num) { int[] dp = new int[num + 1]; for (int i = 0; i &amp;lt;= num / 2; i++) { dp[i&amp;lt;&amp;lt;1] = dp[i]; if ((i&amp;lt;&amp;lt;1) + 1 &amp;lt;= num) dp[(i&amp;lt;&amp;lt;1)+1] = dp[i] + 1; } return dp; } }  复杂度分析：  时间复杂度：O(n) n 为num / 2 空间复杂度：O(n) n 为num  </description>
    </item>
    
    <item>
      <title>为运算表达式设计优先级</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7/</link>
      <pubDate>Tue, 10 Sep 2019 22:59:46 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7/</guid>
      <description>题目：为运算表达式设计优先级  给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含+,-以及*。  示例 1: 输入: &amp;quot;2-1-1&amp;quot; 输出: [0, 2] 解释: ((2-1)-1) = 0 (2-(1-1)) = 2  示例 2: 输入: &amp;quot;2*3-4*5&amp;quot; 输出: [-34, -14, -10, -10, 10] 解释: (2*(3-(4*5))) = -34 ((2*3)-(4*5)) = -14 ((2*(3-4))*5) = -10 (2*((3-4)*5)) = -10 (((2*3)-4)*5) = 10  来源：力扣（LeetCode）第241题  链接：https://leetcode-cn.com/problems/different-ways-to-add-parentheses
 ## 分析： - 动态规划+分治算法。 - 当只有一个运算符时，只有一种情况，当有两个运算符时有两种情况，以此类推。 - 当有三个运算符时，假设第一个运算符优先级最高，然后剩下三个数有两种情况，将两种情况与其相加，得到答案。接着判断第二个运算符优先级最低时，依次类推。
代码： from functools import lru_cache # lru缓存淘汰算法。 class Solution: @lru_cache(None) def diffWaysToCompute(self, input: str) -&amp;gt; List[int]: if input.</description>
    </item>
    
    <item>
      <title>使用最小花费爬楼梯</title>
      <link>https://ripple-zjw.github.io/2019/%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</link>
      <pubDate>Tue, 10 Sep 2019 22:45:45 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</guid>
      <description>题目：使用最小花费爬楼梯  数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值cost[i](索引从0开始)。 每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。 您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。  示例 1: 输入: cost = [10, 15, 20] 输出: 15 解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。  示例 2: 输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 输出: 6 解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。  注意：  cost的长度将会在[2, 1000]。 每一个cost[i] 将会是一个Integer类型，范围为[0, 999]。  来源：力扣（LeetCode）第746题  链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs
 分析：  可以使用递归或者动态规划来解这道题。 思路是如果要跳到第i个位置，那么就要先跳到i-1或者是i-2个位置。  代码：  动态规划： python
class Solution: def minCostClimbingStairs(self, cost: List[int]) -&amp;gt; int: for i in range(2, len(cost)): cost[i] = min(cost[i-1], cost[i-2]) + cost[i] # 你想要跳到第i个位置，就要跳先跳到i-1或i-2个位置。 return min(cost[-1], cost[-2]) # 决定最后是从倒数第一个位置跳上去，还是倒数第二个位置跳上去。  java</description>
    </item>
    
    <item>
      <title>杨辉三角</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</link>
      <pubDate>Fri, 30 Aug 2019 19:22:10 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</guid>
      <description> 题目：杨辉三角  给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。  示例: 输入: 5 输出: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ]  来源：力扣（LeetCode）第118题  链接：https://leetcode-cn.com/problems/pascals-triangle
 分析： 这题可以使用动态规划，是一道非常简单的题目。我们可以把所要求的值看成是前一行的两个值的相加，而且这两个值的位置是有规律的。
思路：  两个循环，第一遍遍历所有的层。 第二遍遍历每一层中的值。 每一层中的值只有第一个和最后一个是1，其他的值都是前一行的前一个位置和现在的位置的和。  代码： class Solution: def generate(self, numRows: int) -&amp;gt; List[List[int]]: ans = [] for i in range(numRows): numRow = [1 for _ in range(i + 1)] for j in range(1, i): numRow[j] = ans[i-1][j-1] + ans[i-1][j] ans.append(numRow) return ans  复杂度分析：  时间复杂度：O(n^2^) n 为numRows 空间复杂度：O(n^2^)  </description>
    </item>
    
    <item>
      <title>接雨水</title>
      <link>https://ripple-zjw.github.io/2019/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</link>
      <pubDate>Fri, 23 Aug 2019 12:55:03 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</guid>
      <description>题目：接雨水  给定n个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。   上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。感谢 Marcos 贡献此图。  示例: 输入: [0,1,0,2,1,0,1,3,2,1,2,1] 输出: 6  来源：力扣（LeetCode）第42题  链接：https://leetcode-cn.com/problems/trapping-rain-water
 分析： 方法太多了，一道极难题，从暴力法，到动态规划，再到单调栈，再到双指针。方法非常多，也很难理解，暴力法最好理解，dp和双指针稍难，我这里讲单调栈的方法。
思路：  维护一个单调递减栈。 当有值比栈顶元素大的时候做这么几件事情：  先出栈一个元素并保存到top中。 然后判断stack是否是空，如果是空的话，说明出栈的左边没有东西，所以无法装雨水。(一定要两边都要有东西并且两边的墙比出栈的墙要长，这样才能装雨水) 算出当前元素与栈顶元素中间的距离dis(注意现在是出栈之后的栈顶元素) 算出当前元素与栈顶元素中哪个值最小，并将小的那个值与出栈的那个元素相减，得到floor_cnt 为什么要叫floor_cnt呢，因为将floor_cnt与dis(也就是两栋大墙之间的距离)相乘，你就能得到在这两栋墙之间一层的雨水数量。 将它们加到ans答案中。例如：如果两栋墙最小的那栋是3，那么就会有3层，每一层的雨水数量可能是不一样的，所以要算3遍。 最后返回ans得到答案。  如果值比栈顶元素小的话就入栈就行了，这样就能维护单调递减栈。(注意栈中存的是数组下标，为了算起来方便。)  Talk is cheap,show me the code. class Solution(object): def trap(self, height): stack = [] ans = 0 cur = 0 while cur &amp;lt; len(height): while stack and height[stack[-1]] &amp;lt; height[cur]: top = stack.</description>
    </item>
    
  </channel>
</rss>