<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeaveIt on LeaveIt</title>
    <link>https://ripple-zjw.github.io/</link>
    <description>Recent content in LeaveIt on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 23 Oct 2019 20:17:40 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>“马”在棋盘上的概率</title>
      <link>https://ripple-zjw.github.io/2019/%E9%A9%AC%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/</link>
      <pubDate>Wed, 23 Oct 2019 20:17:40 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E9%A9%AC%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/</guid>
      <description>

&lt;h1 id=&#34;题目-马-在棋盘上的概率&#34;&gt;题目：“马”在棋盘上的概率&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;已知一个&lt;code&gt;NxN&lt;/code&gt;的国际象棋棋盘，棋盘的行号和列号都是从 0 开始。即最左上角的格子记为&lt;code&gt;(0, 0)&lt;/code&gt;，最右下角的记为&lt;code&gt;(N-1, N-1)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;现有一个 “马”（也译作 “骑士”）位于&lt;code&gt;(r, c)&lt;/code&gt;，并打算进行&lt;code&gt;K 次移动。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如下图所示，国际象棋的 “马” 每一步先沿水平或垂直方向移动 2 个格子，然后向与之相垂直的方向再移动 1 个格子，共有 8 个可选的位置。&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://ripple-zjw.github.io/images/马在棋盘上的概率/knight.png&#34; alt=&#34;image&#34; /&gt;&lt;/li&gt;
&lt;li&gt;现在 “马” 每一步都从可选的位置（包括棋盘外部的）中独立随机地选择一个进行移动，直到移动了&lt;code&gt;K&lt;/code&gt;次或跳到了棋盘外面。&lt;/li&gt;
&lt;li&gt;求移动结束后，“马” 仍留在棋盘上的概率。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: 3, 2, 0, 0
输出: 0.0625
解释: 
输入的数据依次为 N, K, r, c
第 1 步时，有且只有 2 种走法令 “马” 可以留在棋盘上（跳到（1,2）或（2,1））。对于以上的两种情况，各自在第2步均有且只有2种走法令 “马” 仍然留在棋盘上。
所以 “马” 在结束后仍在棋盘上的概率为 0.0625。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;注意&#34;&gt;注意：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;N 的取值范围为 [1, 25]&lt;/li&gt;
&lt;li&gt;K 的取值范围为 [0, 100]&lt;/li&gt;
&lt;li&gt;开始时，“马” 总是位于棋盘上&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第688题&#34;&gt;来源：力扣（LeetCode）第688题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/knight-probability-in-chessboard&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/knight-probability-in-chessboard&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;这道题的概率计算首先要先找到分子和分母，分母就是所有的情况，即K=1就是8种，K=2就是64种。&lt;/li&gt;
&lt;li&gt;然后是分子，分子是到第K步所有可能的情况。比如示例里面K=1有两种情况，k=2总共有4种可能，所以概率就是&lt;code&gt;4/64&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;因此这道题可以使用dp或者dfs来做。&lt;/li&gt;
&lt;li&gt;基本都是一些老套路。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;dfs+记忆化搜索&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
private int[] dx = {1, 1, -1, -1, 2, 2, -2, -2};
private int[] dy = {2, -2, 2, -2, 1, -1, 1, -1};
double[][][] memo;
public double knightProbability(int N, int K, int r, int c) {
    memo = new double[K+1][N][N];
    return dfs(N, K, r, c) / Math.pow(8, K);
}

public double dfs(int N, int K, int r, int c) {
    if (K == 0) return 1;
    if (memo[K][r][c] != 0) return memo[K][r][c];
    double ans = 0;
    for (int i = 0; i &amp;lt; 8; i++)
        if (r + dx[i] &amp;gt;= 0 &amp;amp;&amp;amp; r + dx[i] &amp;lt; N &amp;amp;&amp;amp; c + dy[i] &amp;gt;= 0 &amp;amp;&amp;amp; c + dy[i] &amp;lt; N)
            ans += dfs(N, K-1, r + dx[i], c + dy[i]);
            memo[K][r][c] = ans;
    return ans;
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;动态规划&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
public double knightProbability(int N, int K, int r, int c) {
    int[] dx = {1, 1, -1, -1, 2, 2, -2, -2};
    int[] dy = {2, -2, 2, -2, 1, -1, 1, -1};
    double[][][] dp = new double[K+1][N][N];
    // i 第几步  j x位置 k y位置
    dp[0][r][c] = 1;
    for (int i = 1; i &amp;lt;= K; i++) {
        for (int j = 0; j &amp;lt; N; j++) {
            for (int k = 0; k &amp;lt; N; k++) {
                if (dp[i-1][j][k] != 0) {
                    for (int l = 0; l &amp;lt; 8; l++) 
                        if (j+dx[l] &amp;gt;= 0 &amp;amp;&amp;amp; j+dx[l] &amp;lt; N &amp;amp;&amp;amp; k+dy[l] &amp;gt;= 0 &amp;amp;&amp;amp; k+dy[l] &amp;lt; N)
                            dp[i][j+dx[l]][k+dy[l]] += dp[i-1][j][k] / 8;
                }
            }
        }
    }
    double ans = 0;
    for (int i = 0; i &amp;lt; N; i++) for (int j = 0; j &amp;lt; N; j++) ans += dp[K][i][j];
    return ans;
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;另外，为了节约空间，可以使用滚动数组。大幅度节省空间，速度还快了一点。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
public double knightProbability(int N, int K, int r, int c) {
    int[] dx = {1, 1, -1, -1, 2, 2, -2, -2};
    int[] dy = {2, -2, 2, -2, 1, -1, 1, -1};
    double[][][] dp = new double[2][N][N];
    // i 第几步  j x位置 k y位置
    dp[0][r][c] = 1;
    for (int ii = 1; ii &amp;lt;= K; ii++) {
        int i = ii &amp;amp; 1;
        int pi = i ^ 1;
        for (int j = 0; j &amp;lt; N; j++) for (int k = 0; k &amp;lt; N; k++) dp[i][j][k] = 0;
        for (int j = 0; j &amp;lt; N; j++) {
            for (int k = 0; k &amp;lt; N; k++) {
                if (dp[pi][j][k] != 0) {
                    for (int l = 0; l &amp;lt; 8; l++)
                        if (j+dx[l] &amp;gt;= 0 &amp;amp;&amp;amp; j+dx[l] &amp;lt; N &amp;amp;&amp;amp; k+dy[l] &amp;gt;= 0 &amp;amp;&amp;amp; k+dy[l] &amp;lt; N)
                            dp[i][j+dx[l]][k+dy[l]] += dp[pi][j][k] / 8;
                }
            }
        }
    }
    double ans = 0;
    for (int i = 0; i &amp;lt; N; i++) for (int j = 0; j &amp;lt; N; j++) ans += dp[K&amp;amp;1][i][j];
    return ans;
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>最长上升子序列</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Wed, 23 Oct 2019 20:15:25 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>

&lt;h1 id=&#34;题目-最长上升子序列&#34;&gt;题目：最长上升子序列&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个无序的整数数组，找到其中最长上升子序列的长度。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是[2,3,7,101]，它的长度是 4。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;说明&#34;&gt;说明:&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。&lt;/li&gt;
&lt;li&gt;你算法的时间复杂度应该为&lt;code&gt;O(n^2)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;进阶: 你能将算法的时间复杂度降低到&lt;code&gt;O(n logn)&lt;/code&gt;吗?&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第300题&#34;&gt;来源：力扣（LeetCode）第300题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/longest-increasing-subsequence&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/longest-increasing-subsequence&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;非常好的一道题目&lt;/li&gt;
&lt;li&gt;可以使用动态规划来解决。&lt;/li&gt;
&lt;li&gt;除了最常规的一种方法外还有另一种动态规划的方法，使用二分查找的思想。&lt;/li&gt;
&lt;li&gt;具体可以看看搜索插入位置(LeetCode第35题)&lt;/li&gt;
&lt;li&gt;动态规划：

&lt;ul&gt;
&lt;li&gt;设1个状态表示到这个数为止，最长上升子序列是多少。&lt;/li&gt;
&lt;li&gt;然后遍历数组，当遍历到第i个状态时，查看在dp中到第i个数为止已经有多长了，那么你只要在右边找到比当前数大的值，然后在它的dp数组下加上1。&lt;/li&gt;
&lt;li&gt;最后找到dp数组中最大的值，就是答案。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;dp + 二分查找：

&lt;ul&gt;
&lt;li&gt;我们遍历数组，将每个数放进dp数组中。&lt;/li&gt;
&lt;li&gt;由于dp数组是单调递增的，所以可以使用二分查找找到插入的位置。&lt;/li&gt;
&lt;li&gt;有两种情况，如果找到了这个值，那么直接覆盖就行了，如果没找到这个值，那么将比它大的最小的值覆盖。其实就是插入位置。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;dp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
public int lengthOfLIS(int[] nums) {
    int len = nums.length;
    int[] dp = new int[len];
    Arrays.fill(dp, 1);
    for (int i = 0; i &amp;lt; len; i++) {
        for (int j = i + 1; j &amp;lt; len; j++) {
            if (nums[i] &amp;lt; nums[j]) dp[j] = Math.max(dp[j], dp[i] + 1);
        }
    }
    int ans = 0;
    for (int i = 0; i &amp;lt; len; i++) ans = Math.max(ans, dp[i]);
    return ans;
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;dp + 二分&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
private int len;
private int[] dp;
public int lengthOfLIS(int[] nums) {
    len = nums.length;
    dp = new int[len];
    Arrays.fill(dp, Integer.MAX_VALUE);
    for (int i = 0; i &amp;lt;len; i++) dp[find(nums[i])] = nums[i];
    int ans = 0;
    for (int i = 0; i &amp;lt;len; i++) {if (dp[i] != Integer.MAX_VALUE) ++ans;}
    return ans;
}

public int find(int val) {
    int left = 0, right = len - 1;
    while (left &amp;lt;= right) {
        int mid = right + (left - right &amp;gt;&amp;gt; 1);
        if (dp[mid] == val) {
            return mid;
        } else if (dp[mid] &amp;lt; val) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return left;
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>最长的斐波那契子序列的长度</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Wed, 23 Oct 2019 20:09:39 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/</guid>
      <description>

&lt;h1 id=&#34;题目-最长的斐波那契子序列的长度&#34;&gt;题目：最长的斐波那契子序列的长度&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;如果序列&lt;code&gt;X_1, X_2, ..., X_n&lt;/code&gt;满足下列条件，就说它是&lt;code&gt;斐波那契式&lt;/code&gt;的：&lt;/li&gt;
&lt;li&gt;n &amp;gt;= 3&lt;/li&gt;
&lt;li&gt;对于所有&lt;code&gt;i + 2 &amp;lt;= n&lt;/code&gt;，都有&lt;code&gt;X_i + X_{i+1} = X_{i+2}&lt;/code&gt;
给定一个严格递增的正整数数组形成序列，找到 A 中最长的斐波那契式的子序列的长度。如果一个不存在，返回0 。&lt;/li&gt;
&lt;li&gt;（回想一下，子序列是从原序列&lt;code&gt;A&lt;/code&gt;中派生出来的，它从&lt;code&gt;A&lt;/code&gt;中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如，&lt;code&gt;[3, 5, 8]&lt;/code&gt;是&lt;code&gt;[3, 4, 5, 6, 7, 8]&lt;/code&gt;的一个子序列）&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,2,3,4,5,6,7,8]
输出: 5
解释:
最长的斐波那契式子序列为：[1,2,3,5,8] 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例2&#34;&gt;示例2：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,3,7,11,12,14,18]
输出: 3
解释:
最长的斐波那契式子序列有：
[1,11,12]，[3,11,14] 以及 [7,11,18] 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;提示&#34;&gt;提示：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;3 &amp;lt;= A.length &amp;lt;= 1000&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= A[0] &amp;lt; A[1] &amp;lt; &amp;hellip; &amp;lt; A[A.length - 1] &amp;lt;= 10^9&lt;/li&gt;
&lt;li&gt;（对于以 Java，C，C++，以及C# 的提交，时间限制被减少了 50%）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第873题&#34;&gt;来源：力扣（LeetCode）第873题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;做法有暴力查询或者dp简化。&lt;/li&gt;
&lt;li&gt;暴力查就没什么好说的了，时间复杂度O(n^2logn)&lt;/li&gt;
&lt;li&gt;dp法复杂度也是O(n^2),就是系数比暴力法稍短一点。&lt;/li&gt;
&lt;li&gt;在这里直接给出LeetCode官方题解。&lt;/li&gt;
&lt;li&gt;&amp;gt; &lt;a href=&#34;https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/solution/zui-chang-de-fei-bo-na-qi-zi-xu-lie-de-chang-du-by/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/solution/zui-chang-de-fei-bo-na-qi-zi-xu-lie-de-chang-du-by/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;外来题解&#34;&gt;外来题解：&lt;/h2&gt;

&lt;h3 id=&#34;方法一-使用-set-的暴力法&#34;&gt;方法一：使用 Set 的暴力法&lt;/h3&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;每个斐波那契式的子序列都依靠两个相邻项来确定下一个预期项。例如，对于&lt;code&gt;2, 5&lt;/code&gt;我们所期望的子序列必定以&lt;code&gt;7, 12, 19, 31&lt;/code&gt;等继续。&lt;/li&gt;
&lt;li&gt;我们可以使用 Set 结构来快速确定下一项是否在数组 A 中。由于这些项的值以指数形式增长，最大值&lt;code&gt;10^9≤10^9&lt;/code&gt;
的斐波那契式的子序列最多有 43 项。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;算法&#34;&gt;算法&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;对于每个起始对&lt;code&gt;A[i], A[j]&lt;/code&gt;，我们保持下一个预期值&lt;code&gt;y = A[i] + A[j]&lt;/code&gt;和此前看到的最大值 x = A[j]。如果 y 在数组中，我们可以更新这些值&lt;code&gt;(x, y) -&amp;gt; (y, x+y)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;此外，由于子序列的长度大于等于 3 只能是斐波那契式的，所以我们必须在最后进行检查 ans &amp;gt;= 3 ? ans : 0。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;方法二-动态规划&#34;&gt;方法二：动态规划&lt;/h3&gt;

&lt;h4 id=&#34;思路-1&#34;&gt;思路&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;将斐波那契式的子序列中的两个连续项 A[i], A[j] 视为单个结点 (i, j)，整个子序列是这些连续结点之间的路径。&lt;/li&gt;
&lt;li&gt;例如，对于斐波那契式的子序列&lt;code&gt;(A[1] = 2, A[2] = 3, A[4] = 5, A[7] = 8, A[10] = 13)&lt;/code&gt;，结点之间的路径为 &lt;code&gt;(1, 2) &amp;lt;-&amp;gt; (2, 4) &amp;lt;-&amp;gt; (4, 7) &amp;lt;-&amp;gt; (7, 10)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;这样做的动机是，只有当&lt;code&gt;A[i] + A[j] == A[k]&lt;/code&gt; 时，两结点 (i, j) 和 (j, k) 才是连通的，我们需要这些信息才能知道这一连通。现在我们得到一个类似于 最长上升子序列 的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;算法-1&#34;&gt;算法&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;设 longest[i, j] 是结束在 [i, j] 的最长路径。那么 如果 (i, j) 和 (j, k) 是连通的， longest[j, k] = longest[i, j] + 1。&lt;/li&gt;
&lt;li&gt;由于 i 由 A.index(A[k] - A[j]) 唯一确定，所以这是有效的：我们在 i 潜在时检查每组 j &amp;lt; k，并相应地更新 longest[j, k]。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;暴力查询法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
public int lenLongestFibSubseq(int[] A) {
    int len = A.length;int ans = 0;
    Set&amp;lt;Integer&amp;gt; hs = new HashSet();
    for (int i = 0; i &amp;lt; len; i++) hs.add(A[i]);
    for (int i = 0; i &amp;lt; len; i++) {
        for (int j = i + 1; j &amp;lt; len; j++) {
            int x = A[j], y = A[i] + A[j];
            int cout = 2;
            while (hs.contains(y)) {
                cout++;
                int tmp = x;
                x = y;
                y += tmp;
            }
            ans = Math.max(ans, cout);
        }
    }
    return ans &amp;gt; 2 ? ans : 0;
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;dp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
public int lenLongestFibSubseq(int[] A) {
    int len = A.length;int ans = 0;
    Map&amp;lt;Integer, Integer&amp;gt; index = new HashMap();
    for (int i = 0; i &amp;lt; len; i++) index.put(A[i], i);
    Map&amp;lt;Integer, Integer&amp;gt; dp = new HashMap();
    for (int k = 0; k &amp;lt; len; k++) {
        for (int j = 0; j &amp;lt; k; j++) {
            int i = index.getOrDefault(A[k] - A[j], -1);
            if (i &amp;gt;= 0 &amp;amp;&amp;amp; i &amp;lt; j) {
                // 这个地方要注意，i乘以len再加上j是为了区分i和j的顺序，因为i+j和j+i是一样的
                int cout = dp.getOrDefault(i * len + j, 2) + 1;
                dp.put(j * len + k, cout);
                ans = Math.max(ans, cout);
            }
        }
    }
    return ans &amp;gt; 2 ? ans : 0;
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>最大平均值和的分组</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC%E5%92%8C%E7%9A%84%E5%88%86%E7%BB%84/</link>
      <pubDate>Wed, 23 Oct 2019 20:03:28 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC%E5%92%8C%E7%9A%84%E5%88%86%E7%BB%84/</guid>
      <description>

&lt;h1 id=&#34;题目-最大平均值和的分组&#34;&gt;题目： 最大平均值和的分组&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;我们将给定的数组&lt;code&gt;A&lt;/code&gt;分成&lt;code&gt;K&lt;/code&gt;个相邻的非空子数组 ，我们的分数由每个子数组内的平均值的总和构成。计算我们所能得到的最大分数是多少。&lt;/li&gt;
&lt;li&gt;注意我们必须使用A数组中的每一个数进行分组，并且分数不一定需要是整数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: 
A = [9,1,2,3,9]
K = 3
输出: 20
解释: 
A 的最优分组是[9], [1, 2, 3], [9]. 得到的分数是 9 + (1 + 2 + 3) / 3 + 9 = 20.
我们也可以把 A 分成[9, 1], [2], [3, 9].
这样的分组得到的分数为 5 + 2 + 6 = 13, 但不是最大值.
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;说明&#34;&gt;说明:&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= A.length &amp;lt;= 100.&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= A[i] &amp;lt;= 10000.&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= K &amp;lt;= A.length.&lt;/li&gt;
&lt;li&gt;答案误差在&lt;code&gt;10^-6&lt;/code&gt;内被视为是正确的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第813题&#34;&gt;来源：力扣（LeetCode）第813题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/largest-sum-of-averages&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/largest-sum-of-averages&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;动态规划题&lt;/li&gt;
&lt;li&gt;这次的状态不算难找，主要是在到底应该用三维dp还是二维就可以搞定了。&lt;/li&gt;
&lt;li&gt;最后发现二维就够了。&lt;/li&gt;
&lt;li&gt;先来说说三维，定义i，j，k分别表示当前为第i份，从数组的下标j开始，到k结束。&lt;/li&gt;
&lt;li&gt;于是我将每一种情况全部都可以算一遍，看看哪儿种最大。可是之后我发现，我并不一定要将所有的j到k的情况都存下来，我只要每次将到k为止，或者从j开始归在一起，把最大的那种情况存起来就可以了。&lt;/li&gt;
&lt;li&gt;因为下一次找的肯定是上一次分割的尾巴。如果都是以k结束的那么我只要知道最大的就行了，小的根本就用不到。&lt;/li&gt;
&lt;li&gt;因此，我们的状态就变成二维的了，即定义i，j为当前为第i份，从0到下标j为止最大的平均数和。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public double largestSumOfAverages(int[] A, int K) {
        int len = A.length;
        double[][] dp = new double[K][len];
        // i 第几份  j 到j为止
        dp[0][0] = A[0]; // base case
        // 把第一行的情况拿出来，注意不能到达最后K-1个，因为最少也要分1个，如果还要分两个的话，最少也要留两个才行。
        for (int i = 1; i &amp;lt; len - K + 1; i++) dp[0][i] = dp[0][i-1] + A[i];
        // 先取和，再求平均值
        for (int i = 1; i &amp;lt; len - K + 1; i++) dp[0][i] /= (i + 1);
        for (int i = 1; i &amp;lt; K; i++) {
            for (int j = i; j &amp;lt;= len - K + i; j++) {
                // count 用于算出和后求平均值
                int count = j - i + 1;
                // st 即每种情况的开始，我说过把到j结束的归在一起，但还是要计算的，不然怎么得到最大值。
                for (int st = i; st &amp;lt;= j; st++) {
                    double sum = 0;
                    for (int k = st; k &amp;lt;= j; k++) sum += A[k];// 拿到区域和
                    // 算一下当前区域的平均值是否最大。
                    // 由于st是当前区域的开始，所以上一次分割最后一定是st-1，那么就找上一次以st-1为结尾的最大值。
                    dp[i][j] = Math.max(dp[i][j], dp[i-1][st-1] + sum / count);
                    // 一轮循环结束后，除数也会减少，比如原来是1 2 3，现在是2 3的和那么现在只有两个数了。
                    --count;
                }
            }
        }
        // 这里为什么只要len-1而不要其他的情况呢，因为最后一次一定要分到最后，也就是说我不管从谁开始分，一定要以len-1结束。
        return dp[K-1][len-1];
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;写完之后发现，这段代码可以写的更简洁，更优化。&lt;/li&gt;
&lt;li&gt;比如我要找区域和，那么我只要先求出所有的前缀和，再将两个前缀和相减就能得到某一个区域的区域和。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;同时我对count也做了处理，不需要count变量了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
public double largestSumOfAverages(int[] A, int K) {
    int len = A.length;
    double[][] dp = new double[K][len];
    // i 第几份  j 到j为止
    double[] sum = new double[len];sum[0] = A[0];
    for (int i = 1; i &amp;lt; len; i++) sum[i] = sum[i-1] + A[i];
    for (int i = 0; i &amp;lt; len - K + 1; i++) dp[0][i] = sum[i] / (i + 1);
    for (int i = 1; i &amp;lt; K; i++) {
        for (int j = i; j &amp;lt;= len - K + i; j++) {
            for (int st = i; st &amp;lt;= j; st++) 
                dp[i][j] = Math.max(dp[i][j], dp[i-1][st-1] + (sum[j] - sum[st-1]) / (j - st + 1));
        }
    }
    return dp[K-1][len-1];
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>分割等和子集</title>
      <link>https://ripple-zjw.github.io/2019/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</link>
      <pubDate>Wed, 23 Oct 2019 19:58:28 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</guid>
      <description>

&lt;h1 id=&#34;题目-分割等和子集&#34;&gt;题目：分割等和子集&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;注意&#34;&gt;注意:&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;每个数组中的元素不会超过 100&lt;/li&gt;
&lt;li&gt;数组的大小不会超过 200&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1, 5, 11, 5]
输出: true
解释: 数组可以分割成 [1, 5, 5] 和 [11].
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例2&#34;&gt;示例2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1, 2, 3, 5]
输出: false
解释: 数组不能分割成两个元素和相等的子集.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第416题&#34;&gt;来源：力扣（LeetCode）第416题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/partition-equal-subset-sum&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/partition-equal-subset-sum&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;动态规划题&lt;/li&gt;
&lt;li&gt;0-1背包问题&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        int len = nums.length;
        for (int num : nums) sum += num;
        if ((sum &amp;amp; 1) == 1) return false; // 如果是奇数，不可能分割
        sum &amp;gt;&amp;gt;= 1; // 要找的答案是总和的一半。
        boolean[][] dp = new boolean[len][sum+1]; // i表示nums中从0到i为止，j表示是否能找到和为j的数。
        if (nums[0] &amp;lt;= sum) dp[0][nums[0]] = true; // 第一个数放在j上，其他都是false
        for (int i = 1; i &amp;lt; len; i++) {
            for (int j = 0; j &amp;lt;= sum; j++) {
                if (nums[i] &amp;lt;= j) 
                // 两种选择，一种之前就找到了和为j的数，那么现在还是true。
                // 如果之前没有找到和为j的数，那么我加上这次的数，要找前一次j-nums[i]的和能不能找到。
                    dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]];
                else // 如果当前nums[i] 大于j的话，之前看它前一次是什么状态现在还是什么状态。
                    dp[i][j] = dp[i-1][j];
            }
        }
        return dp[len-1][sum];
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>分享巧克力</title>
      <link>https://ripple-zjw.github.io/2019/%E5%88%86%E4%BA%AB%E5%B7%A7%E5%85%8B%E5%8A%9B/</link>
      <pubDate>Wed, 23 Oct 2019 19:48:36 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%88%86%E4%BA%AB%E5%B7%A7%E5%85%8B%E5%8A%9B/</guid>
      <description>

&lt;h1 id=&#34;题目-分享巧克力&#34;&gt;题目：分享巧克力&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;你有一大块巧克力，它由一些甜度不完全相同的小块组成。我们用数组&lt;code&gt;sweetness&lt;/code&gt;来表示每一小块的甜度。&lt;/li&gt;
&lt;li&gt;你打算和&lt;code&gt;K&lt;/code&gt;名朋友一起分享这块巧克力，所以你需要将切割&lt;code&gt;K&lt;/code&gt;次才能得到&lt;code&gt;K+1&lt;/code&gt;块，每一块都由一些 连续的小块组成。&lt;/li&gt;
&lt;li&gt;为了表现出你的慷慨，你将会吃掉总甜度最小 的一块，并将其余几块分给你的朋友们。&lt;/li&gt;
&lt;li&gt;请找出一个最佳的切割策略，使得你所分得的巧克力总甜度最大，并返回这个 最大总甜度。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：sweetness = [1,2,3,4,5,6,7,8,9], K = 5
输出：6
解释：你可以把巧克力分成 [1,2,3], [4,5], [6], [7], [8], [9]。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：sweetness = [5,6,7,8,9,1,2,3,4], K = 8
输出：1
解释：只有一种办法可以把巧克力分成 9 块。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-3&#34;&gt;示例 3：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：sweetness = [1,2,2,1,2,2,1,2,2], K = 2
输出：5
解释：你可以把巧克力分成 [1,2,2], [1,2,2], [1,2,2]。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;提示&#34;&gt;提示：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;0 &amp;lt;= &lt;code&gt;K&lt;/code&gt; &amp;lt;&lt;code&gt;sweetness.length&lt;/code&gt;&amp;lt;= 10^4&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= &lt;code&gt;sweetness[i]&lt;/code&gt; &amp;lt;= 10^5&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第5111题-临时&#34;&gt;来源：力扣（LeetCode）第5111题(临时)&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/divide-chocolate&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/divide-chocolate&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;二分查找 + 贪心算法&lt;/li&gt;
&lt;li&gt;如果最大甜度是mid，那么小于mid的甜度都能分到，大于mid的甜度都分不到。&lt;/li&gt;
&lt;li&gt;这就像一个排好序的数组，我们要做的就是不断逼近可以分到的最大值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int maximizeSweetness(int[] sweetness, int K) {
        int len = sweetness.length;++K; // 切割K次得到K+1块巧克力
        int ans = 0;
        int left = 0, right = (int)1e9 + 50; // 最大情况，全部是10^5，总共有10^4个。
        while (left &amp;lt;= right) { // 二分查找符合的情况
            int mid = right + (left - right &amp;gt;&amp;gt; 1); // mid是你自己分到的最小的那个甜度
            if (check(mid, K, sweetness)) { // 如果自己拿到mid，那么检查能不能至少分到K+1份并且mid是最小的。
                left = mid + 1; // 如果能，那么可能还可以分到更大的甜度。
                ans = Math.max(ans, mid); // 先将符合条件的情况保存下来。
            } else {
                right = mid - 1; // 如果不能，那么只能减少甜度。
            }
        }
        return ans;
    }

    public boolean check(int swt, int K, int[] s) { // 检查甜度是否符合
        int sum = 0, cur = 0;
        for (int x : s) { // 不停的放进去，贪心的去分，只要一符合条件，就切一刀。
            sum += x;
            if (sum &amp;gt;= swt) { // 如果分到这个发现甜度比mid大了，那么直接切一刀。
                ++cur; // 分到一块符合条件，+1.
                sum = 0; // 下一块又从0开始加了。
            }
        }
        return cur &amp;gt;= K;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>删除子文件夹</title>
      <link>https://ripple-zjw.github.io/2019/%E5%88%A0%E9%99%A4%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9/</link>
      <pubDate>Wed, 23 Oct 2019 19:45:43 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%88%A0%E9%99%A4%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9/</guid>
      <description>

&lt;h1 id=&#34;题目-删除子文件夹&#34;&gt;题目： 删除子文件夹&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;你是一位系统管理员，手里有一份文件夹列表 folder，你的任务是要删除该列表中的所有 子文件夹，并以 任意顺序 返回剩下的文件夹。&lt;/li&gt;
&lt;li&gt;我们这样定义「子文件夹」：&lt;/li&gt;
&lt;li&gt;如果文件夹&lt;code&gt;folder[i]&lt;/code&gt;位于另一个文件夹&lt;code&gt;folder[j]&lt;/code&gt;下，那么&lt;code&gt;folder[i]&lt;/code&gt;就是&lt;code&gt;folder[j]&lt;/code&gt;的子文件夹。
文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/&lt;/code&gt;后跟一个或者多个小写英文字母。
例如，&lt;code&gt;/leetcode&lt;/code&gt;和&lt;code&gt;/leetcode/problems&lt;/code&gt;都是有效的路径，而空字符串和&lt;code&gt;/&lt;/code&gt;不是。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：folder = [&amp;quot;/a&amp;quot;,&amp;quot;/a/b&amp;quot;,&amp;quot;/c/d&amp;quot;,&amp;quot;/c/d/e&amp;quot;,&amp;quot;/c/f&amp;quot;]
输出：[&amp;quot;/a&amp;quot;,&amp;quot;/c/d&amp;quot;,&amp;quot;/c/f&amp;quot;]
解释：&amp;quot;/a/b/&amp;quot; 是 &amp;quot;/a&amp;quot; 的子文件夹，而 &amp;quot;/c/d/e&amp;quot; 是 &amp;quot;/c/d&amp;quot; 的子文件夹。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：folder = [&amp;quot;/a&amp;quot;,&amp;quot;/a/b/c&amp;quot;,&amp;quot;/a/b/d&amp;quot;]
输出：[&amp;quot;/a&amp;quot;]
解释：文件夹 &amp;quot;/a/b/c&amp;quot; 和 &amp;quot;/a/b/d/&amp;quot; 都会被删除，因为它们都是 &amp;quot;/a&amp;quot; 的子文件夹。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-3&#34;&gt;示例 3：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：folder = [&amp;quot;/a/b/c&amp;quot;,&amp;quot;/a/b/d&amp;quot;,&amp;quot;/a/b/ca&amp;quot;]
输出：[&amp;quot;/a/b/c&amp;quot;,&amp;quot;/a/b/ca&amp;quot;,&amp;quot;/a/b/d&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;提示&#34;&gt;提示：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= &lt;code&gt;folder.length&lt;/code&gt;&amp;lt;= 4 * 10^4&lt;/li&gt;
&lt;li&gt;2 &amp;lt;= &lt;code&gt;folder[i].length&lt;/code&gt; &amp;lt;= 100&lt;/li&gt;
&lt;li&gt;&lt;code&gt;folder[i]&lt;/code&gt;只包含小写字母和 /&lt;/li&gt;
&lt;li&gt;&lt;code&gt;folder[i]&lt;/code&gt;总是以字符&lt;code&gt;/&lt;/code&gt;起始&lt;/li&gt;
&lt;li&gt;每个文件夹名都是唯一的&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第5231题-临时&#34;&gt;来源：力扣（LeetCode）第5231题(临时)&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/remove-sub-folders-from-the-filesystem&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/remove-sub-folders-from-the-filesystem&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;只要将数组排序一下，就能很轻松的解决。&lt;/li&gt;
&lt;li&gt;排序后所有的子文件夹都会跟在父文件夹后面，只要判断一下前缀是否一样就行了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def removeSubfolders(self, folder: List[str]) -&amp;gt; List[str]:
        folder.sort() # 先排序，让数组中相同的文件夹从少到多放在一起。
        res = []
        t = &#39;//&#39; # 初始化
        for f in folder:
            if not f.startswith(t): # 判断是否包含前一个元素的部分
                res.append(f) # 如果不包含，那么就不是子文件夹，放入答案中
                t = f + &#39;/&#39; # 将当前元素传给t，用于下一轮循环比较。
        return res
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public List&amp;lt;String&amp;gt; removeSubfolders(String[] folder) {
        Arrays.sort(folder);
        List&amp;lt;String&amp;gt; ans = new ArrayList();
        String str = &amp;quot;//&amp;quot;;
        for (String f : folder) {
            if (!startsWith(f, str)) {
                ans.add(f);
                str = f + &amp;quot;/&amp;quot;;
            }
        }
        return ans;
    }
    
    public boolean startsWith(String str, String sub) {
        for (int i = 0; i &amp;lt; sub.length(); i++) {
            if (str.charAt(i) != sub.charAt(i)) return false;
        }
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>抛掷硬币</title>
      <link>https://ripple-zjw.github.io/2019/%E6%8A%9B%E6%8E%B7%E7%A1%AC%E5%B8%81/</link>
      <pubDate>Wed, 23 Oct 2019 19:43:25 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%8A%9B%E6%8E%B7%E7%A1%AC%E5%B8%81/</guid>
      <description>

&lt;h1 id=&#34;题目-抛掷硬币&#34;&gt;题目：抛掷硬币&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;有一些不规则的硬币。在这些硬币中，&lt;code&gt;prob[i]&lt;/code&gt;表示第&lt;code&gt;i&lt;/code&gt;枚硬币正面朝上的概率。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;请对每一枚硬币抛掷一次，然后返回正面朝上的硬币数等于&lt;code&gt;target&lt;/code&gt;的概率。&lt;/p&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：prob = [0.4], target = 1
输出：0.40000
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：prob = [0.5,0.5,0.5,0.5,0.5], target = 0
输出：0.03125
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;提示&#34;&gt;提示：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= prob.length &amp;lt;= 1000&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= prob[i] &amp;lt;= 1&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= &lt;code&gt;target&lt;/code&gt;&amp;lt;= &lt;code&gt;prob.length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果答案与标准答案的误差在&lt;code&gt;10^-5&lt;/code&gt;内，则被视为正确答案。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第5090题-临时&#34;&gt;来源：力扣（LeetCode）第5090题(临时)&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/toss-strange-coins&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/toss-strange-coins&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;概率dp&lt;/li&gt;
&lt;li&gt;找到两个状态，一个是当前扔了第几个硬币，另一个是有几个正面朝上。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public double probabilityOfHeads(double[] prob, int target) {
        int n = prob.length;
        // 滚动数组，由于这个dp只要用到前一个状态，所以没必要把所有的硬币情况都写出来。
        // dp数组表示当前有i个硬币，j个硬币正面朝上。
        double[][] dp = new double[2][target+2];
        dp[0][0] = 1; // 当前没有硬币，0个硬币朝上的概率为100%
        for (int ii = 1; ii &amp;lt;= n; ii++) {
            int i = ii &amp;amp; 1; // 如果最后一位是1，那么i=1，如果最后一位是0，那么i=0
            int pi = i ^ 1; // 如果i=1，那么异或1得0，如果i=0，那么异或1得1
            for (int j = 0; j &amp;lt;= target; j++) dp[i][j] = 0; // 由于滚动数组，所以要把之前的清空。
            for (int j = 0; j &amp;lt;= target; j++) {
                dp[i][j] += dp[pi][j] * (1 - prob[ii-1]);
                // 当前有i个硬币，如果第i个硬币扔的是反面，那么i-1个硬币必须要有j个是正面。
                dp[i][j+1] += dp[pi][j] * prob[ii-1];
                // 如果扔的是正面，那么i-1个硬币必须要有j-1个时正面。
            }
        }
        // n是奇数那么索引就是1，如果n是偶数的话，那么它答案的索引就是0
        return dp[n&amp;amp;1][target];
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>安排会议日程</title>
      <link>https://ripple-zjw.github.io/2019/%E5%AE%89%E6%8E%92%E4%BC%9A%E8%AE%AE%E6%97%A5%E7%A8%8B/</link>
      <pubDate>Wed, 23 Oct 2019 19:41:34 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%AE%89%E6%8E%92%E4%BC%9A%E8%AE%AE%E6%97%A5%E7%A8%8B/</guid>
      <description>

&lt;h1 id=&#34;题目-安排会议日程&#34;&gt;题目：安排会议日程&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;你是一名行政助理，手里有两位客户的空闲时间表：slots1 和 slots2，以及会议的预计持续时间&lt;code&gt;duration&lt;/code&gt;，请你为他们安排合适的会议时间。&lt;/li&gt;
&lt;li&gt;「会议时间」是两位客户都有空参加，并且持续时间能够满足预计时间&lt;code&gt;duration&lt;/code&gt;的 最早的时间间隔。&lt;/li&gt;
&lt;li&gt;如果没有满足要求的会议时间，就请返回一个 空数组。
「空闲时间」的格式是&lt;code&gt;[start, end]&lt;/code&gt;，由开始时间&lt;code&gt;start&lt;/code&gt;和结束时间&lt;code&gt;end&lt;/code&gt;组成，表示从&lt;code&gt;start&lt;/code&gt;开始，到&lt;code&gt;end&lt;/code&gt;结束。&lt;/li&gt;
&lt;li&gt;题目保证数据有效：同一个人的空闲时间不会出现交叠的情况，也就是说，对于同一个人的两个空闲时间&lt;code&gt;[start1, end1]&lt;/code&gt;和&lt;code&gt;[start2, end2]&lt;/code&gt;，要么&lt;code&gt;start1 &amp;gt; end2&lt;/code&gt;，要么&lt;code&gt;start2 &amp;gt; end1&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：slots1 = [[10,50],[60,120],[140,210]], slots2 = [[0,15],[60,70]], duration = 8
输出：[60,68]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：slots1 = [[10,50],[60,120],[140,210]], slots2 = [[0,15],[60,70]], duration = 12
输出：[]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;提示&#34;&gt;提示：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= slots1.length, slots2.length &amp;lt;= 10^4&lt;/li&gt;
&lt;li&gt;slots1[i].length, slots2[i].length == 2&lt;/li&gt;
&lt;li&gt;slots1[i][0] &amp;lt; slots1[i][1]&lt;/li&gt;
&lt;li&gt;slots2[i][0] &amp;lt; slots2[i][1]&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= slots1[i][j], slots2[i][j] &amp;lt;= 10^9&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= duration &amp;lt;= 10^6&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第5089题-临时&#34;&gt;来源：力扣（LeetCode）第5089题(临时)&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/meeting-scheduler&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/meeting-scheduler&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;我们使用两个指针分别指向&lt;code&gt;slots1&lt;/code&gt;和&lt;code&gt;slots2&lt;/code&gt;，计作i，j。&lt;/li&gt;
&lt;li&gt;我们判断当前i和j指向的那个时间段最大的开始时间和最小的结束时间之内是否可以容纳&lt;code&gt;duration&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果可以容纳的话就直接返回结果，如果不行，我们将结束时间小的那个指针向前走一个位置，让他比另一个指针的结束时间大。&lt;/li&gt;
&lt;li&gt;如果没找到的话，返回空。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution(object):
    def minAvailableDuration(self, slots1, slots2, duration):
        slots1.sort(key=lambda x : x[0]) # 先将两个数组排序一下。
        slots2.sort(key=lambda x : x[0])
        m1, m2 = len(slots1), len(slots2)
        i = j = 0
        while i &amp;lt; m1 and j &amp;lt; m2: # 双指针的结束条件
            st = max(slots1[i][0], slots2[j][0]) # 找到开始时间大的那个
            en = min(slots1[i][1], slots2[j][1]) # 找到结束时间小的那个。
            if st + duration &amp;lt;= en: # 看一下st到en之间是否可以容纳duration
                return [st, st+duration]
            if slots1[i][1] &amp;lt; slots2[j][1]: # 谁的结束时间小，谁就往前走。
                i += 1
            else:
                j += 1
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>等差数列中缺失的数字</title>
      <link>https://ripple-zjw.github.io/2019/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Wed, 23 Oct 2019 19:40:20 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>

&lt;h1 id=&#34;题目-等差数列中缺失的数字&#34;&gt;题目：等差数列中缺失的数字&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;有一个数组，其中的值符合等差数列的数值规律，也就是说：&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;0 &amp;lt;= i &amp;lt; arr.length - 1&lt;/code&gt;的前提下，&lt;code&gt;arr[i+1] - arr[i]&lt;/code&gt;的值都相等。&lt;/li&gt;
&lt;li&gt;我们会从该数组中删除一个既不是第一个也不是最后一个的值，得到一个新的数组arr。&lt;/li&gt;
&lt;li&gt;给你这个缺值的数组&lt;code&gt;arr&lt;/code&gt;，请你帮忙找出被删除的那个数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：arr = [5,7,11,13]
输出：9
解释：原来的数组是 [5,7,9,11,13]。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：arr = [15,13,12]
输出：14
解释：原来的数组是 [15,14,13,12]。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;提示&#34;&gt;提示：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;3 &amp;lt;= arr.length &amp;lt;= 1000&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= arr[i] &amp;lt;= 10^5&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第5088题-临时&#34;&gt;来源：力扣（LeetCode）第5088题(临时)&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/missing-number-in-arithmetic-progression&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/missing-number-in-arithmetic-progression&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;我们算出数组中的总值，然后用等差数列求和公式求出原来的总值，相减一下就得到了答案。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int missingNumber(int[] arr) {
        int sum = 0;
        for (int a : arr) sum += a;
        return (arr.length + 1) * (arr[0] + arr[arr.length-1]) / 2 - sum;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>填充书架</title>
      <link>https://ripple-zjw.github.io/2019/%E5%A1%AB%E5%85%85%E4%B9%A6%E6%9E%B6/</link>
      <pubDate>Wed, 23 Oct 2019 19:34:22 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%A1%AB%E5%85%85%E4%B9%A6%E6%9E%B6/</guid>
      <description>

&lt;h1 id=&#34;题目-填充书架&#34;&gt;题目：填充书架&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;附近的家居城促销，你买回了一直心仪的可调节书架，打算把自己的书都整理到新的书架上。&lt;/li&gt;
&lt;li&gt;你把要摆放的书&lt;code&gt;books&lt;/code&gt;都整理好，叠成一摞：从上往下，第&lt;code&gt;i&lt;/code&gt;本书的厚度为&lt;code&gt;books[i][0]&lt;/code&gt;，高度为&lt;code&gt;books[i][1]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;按顺序将这些书摆放到总宽度为&lt;code&gt;shelf_width&lt;/code&gt;的书架上。&lt;/li&gt;
&lt;li&gt;先选几本书放在书架上（它们的厚度之和小于等于书架的宽度 shelf_width），然后再建一层书架。重复这个过程，直到把所有的书都放在书架上。&lt;/li&gt;
&lt;li&gt;需要注意的是，在上述过程的每个步骤中，摆放书的顺序与你整理好的顺序相同。 例如，如果这里有 5 本书，那么可能的一种摆放情况是：第一和第二本书放在第一层书架上，第三本书放在第二层书架上，第四和第五本书放在最后一层书架上。&lt;/li&gt;
&lt;li&gt;每一层所摆放的书的最大高度就是这一层书架的层高，书架整体的高度为各层高之和。&lt;/li&gt;
&lt;li&gt;以这种方式布置书架，返回书架整体可能的最小高度。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例：&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;https://ripple-zjw.github.io/images/填充书架/shelves.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输入：books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelf_width = 4
输出：6
解释：
3 层书架的高度和为 1 + 3 + 2 = 6 。
第 2 本书不必放在第一层书架上。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提示：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= &lt;code&gt;books.length&lt;/code&gt; &amp;lt;= 1000&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= &lt;code&gt;books[i][0]&lt;/code&gt; &amp;lt;= &lt;code&gt;shelf_width&lt;/code&gt; &amp;lt;= 1000&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= &lt;code&gt;books[i][1]&lt;/code&gt; &amp;lt;= 1000&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第1105题&#34;&gt;来源：力扣（LeetCode）第1105题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/filling-bookcase-shelves&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/filling-bookcase-shelves&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;动态规划题&lt;/li&gt;
&lt;li&gt;这道题的状态很简单，却很难想到。&lt;/li&gt;
&lt;li&gt;我们设i为到第i本书为止的最优情况。&lt;/li&gt;
&lt;li&gt;如果i之前都已是最优情况，那么第i种情况怎么算呢？&lt;/li&gt;
&lt;li&gt;首先直接换行，那么就是i-1时的最优情况加上这本书的高度。&lt;/li&gt;
&lt;li&gt;第二种，我们把第i-1本书和第i本书放在一起，那么就是第i本书和第i-1本最高的那本加上i-2时的最优情况。&lt;/li&gt;
&lt;li&gt;以此类推，直到把所有书都放在同一行，或者宽度不够了，下一本书放不进去了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int minHeightShelves(int[][] books, int shelf_width) {
        int m = books.length;
        int[] dp = new int[m+1];
        for (int i = 1; i &amp;lt;= m; i++) dp[i] = Integer.MAX_VALUE;
        for (int i = 1; i &amp;lt;= m; i++) {
            int curh = 0;
            int curw = 0;
            for (int j = i; j &amp;gt;= 1; j--) {
                // 一开始是第i本书的高度，接下来是第i本书和第i-1本书高的那个，以此类推。
                curh = Math.max(curh, books[j-1][1]);
                // 一开始是第i本书的宽度，接下来是第i-1本书加上第i本书的宽度，以此类推。
                curw += books[j-1][0];
                if (curw &amp;gt; shelf_width) break; // 宽度过了就直接退出了。
                dp[i] = Math.min(dp[i], dp[j-1] + curh); // 看看哪种情况最优。
            }
        }
        return dp[m];
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>掷骰子模拟</title>
      <link>https://ripple-zjw.github.io/2019/%E6%8E%B7%E9%AA%B0%E5%AD%90%E6%A8%A1%E6%8B%9F/</link>
      <pubDate>Wed, 23 Oct 2019 19:26:07 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%8E%B7%E9%AA%B0%E5%AD%90%E6%A8%A1%E6%8B%9F/</guid>
      <description>

&lt;h1 id=&#34;题目-掷骰子模拟&#34;&gt;题目：掷骰子模拟&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。&lt;/li&gt;
&lt;li&gt;不过我们在使用它时有个约束，就是使得投掷骰子时，&lt;strong&gt;连续&lt;/strong&gt; 掷出数字&lt;code&gt;i&lt;/code&gt;的次数不能超过&lt;code&gt;rollMax[i]（i&lt;/code&gt;从 1 开始编号）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;现在，给你一个整数数组&lt;code&gt;rollMax&lt;/code&gt;和一个整数&lt;code&gt;n&lt;/code&gt;，请你来计算掷&lt;code&gt;n&lt;/code&gt;次骰子可得到的不同点数序列的数量。&lt;/p&gt;

&lt;p&gt;假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 模&lt;code&gt;10^9 + 7&lt;/code&gt;之后的结果。&lt;/p&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：n = 2, rollMax = [1,1,2,2,2,3]
输出：34
解释：我们掷 2 次骰子，如果没有约束的话，共有 6 * 6 = 36 种可能的组合。但是根据 rollMax 数组，数字 1 和 2 最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。因此，最终答案是 36-2 = 34。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：n = 2, rollMax = [1,1,1,1,1,1]
输出：30
示例 3：
输入：n = 3, rollMax = [1,1,1,2,2,3]
输出：181
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;提示&#34;&gt;提示：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= n &amp;lt;= 5000&lt;/li&gt;
&lt;li&gt;rollMax.length == 6&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= rollMax[i] &amp;lt;= 15&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第1223题&#34;&gt;来源：力扣（LeetCode）第1223题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/dice-roll-simulation&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/dice-roll-simulation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;这是一道动态规划题&lt;/li&gt;
&lt;li&gt;题目有一点要注意，是连续投掷次数不能超过i，而不是总次数不能超过i。&lt;/li&gt;
&lt;li&gt;我们设三个状态，i，j，k。i代表第i轮，j代表投掷了第j个数，k代表第j个数已经连续投出多少次了。&lt;/li&gt;
&lt;li&gt;当k等于1，说明之前一轮没有投出j，因此次数是之前一轮没有投出j的次数之和。&lt;/li&gt;
&lt;li&gt;当k大于1时，说明之前一轮投的也是k，所以次数就是之前一轮投的是j的时候k-1次。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    private long mod = (long)1e9 + 7;
    public int dieSimulator(int n, int[] rollMax) {
        long[][][] dp = new long[n][6][16];
        for (int j = 0; j &amp;lt; 6; j++) dp[0][j][1] = 1;
        for (int i = 1; i &amp;lt; n; i++) {
            for (int j = 0; j &amp;lt; 6; j++) {
                for (int l = 0; l &amp;lt; 6; l++) {
                    for (int k = 1; k &amp;lt;= rollMax[l]; k++) {
                        if (l == j) continue;
                        dp[i][j][1] += dp[i-1][l][k];
                        dp[i][j][1] %= mod;
                    }
                }

                for (int k = 2; k &amp;lt;= rollMax[j]; k++) dp[i][j][k] = dp[i-1][j][k-1];
            }
        }
        long ans = 0;
        for (int j = 0; j &amp;lt; 6; j++) for (int k = 1; k &amp;lt;= 15; k++) {ans += dp[n-1][j][k];ans %= mod;}
        return (int)ans;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>一和零</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%80%E5%92%8C%E9%9B%B6/</link>
      <pubDate>Wed, 23 Oct 2019 19:21:28 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%80%E5%92%8C%E9%9B%B6/</guid>
      <description>

&lt;h1 id=&#34;题目-一和零&#34;&gt;题目： 一和零&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;在计算机界中，我们总是追求用有限的资源获取最大的收益。&lt;/li&gt;
&lt;li&gt;现在，假设你分别支配着 m 个&lt;code&gt;0&lt;/code&gt;和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。&lt;/li&gt;
&lt;li&gt;你的任务是使用给定的&lt;code&gt;m&lt;/code&gt;个&lt;code&gt;0&lt;/code&gt;和&lt;code&gt;n&lt;/code&gt; 个&lt;code&gt;1&lt;/code&gt;，找到能拼出存在于数组中的字符串的最大数量。每个&lt;code&gt;0&lt;/code&gt;和&lt;code&gt;1&lt;/code&gt;至多被使用一次。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;注意&#34;&gt;注意:&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;给定&lt;code&gt;0&lt;/code&gt;和&lt;code&gt;1&lt;/code&gt;的数量都不会超过100。&lt;/li&gt;
&lt;li&gt;给定字符串数组的长度不会超过600。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: Array = {&amp;quot;10&amp;quot;, &amp;quot;0001&amp;quot;, &amp;quot;111001&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;},m = 5, n = 3
输出: 4
解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 &amp;quot;10&amp;quot;,&amp;quot;0001&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot; 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: Array = {&amp;quot;10&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;}, m = 1, n = 1
输出: 2
解释: 你可以拼出 &amp;quot;10&amp;quot;，但之后就没有剩余数字了。更好的选择是拼出 &amp;quot;0&amp;quot; 和 &amp;quot;1&amp;quot; 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第474题&#34;&gt;来源：力扣（LeetCode）第474题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/ones-and-zeroes&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/ones-and-zeroes&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;典型的背包问题，有两个状态，i是当0有i个时，j是当1有j个时。&lt;/li&gt;
&lt;li&gt;我们举出小于m和小于n的0和1的个数。每当一个str进来时有两种选择，一种是放进去，另一种不放。&lt;/li&gt;
&lt;li&gt;如果放进去，那么放完后还要加上&lt;code&gt;i-count(0)&lt;/code&gt;和&lt;code&gt;j-count(1)&lt;/code&gt;时候的个数，如果不放就不用动它。比较两者谁大，把大的存在当前状态。&lt;/li&gt;
&lt;li&gt;我们每次把所有状态都更新一遍。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int[][] dp = new int[m+1][n+1];
        for (String str : strs) {
            int zero = 0, one = 0;
            // 找到0 和 1的个数
            for (int i = 0; i &amp;lt; str.length(); i++) {
                if (str.charAt(i) == &#39;1&#39;) one++;
                else zero++;
            }
            // 如果str的0和1的个数是x，y，那么我们将能够装下x个0，和y个1的状态依次进行比较。
            // 如果装下x个0， y个1后，然后查看剩下的i-x个0和j-y个1能装下几个，这个状态在上一次已经算过了。
            for (int i = m; i &amp;gt;= zero; i--) 
                for (int j = n; j &amp;gt;= one; j--) 
                    dp[i][j] = Math.max(dp[i][j], dp[i-zero][j-one] + 1);
        }
        return dp[m][n];
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>删除与获得点数</title>
      <link>https://ripple-zjw.github.io/2019/%E5%88%A0%E9%99%A4%E4%B8%8E%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0/</link>
      <pubDate>Wed, 23 Oct 2019 19:13:59 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%88%A0%E9%99%A4%E4%B8%8E%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0/</guid>
      <description>

&lt;h1 id=&#34;删除与获得点数&#34;&gt;删除与获得点数&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个整数数组&lt;code&gt;nums&lt;/code&gt;，你可以对它进行一些操作。&lt;/li&gt;
&lt;li&gt;每次操作中，选择任意一个&lt;code&gt;nums[i]&lt;/code&gt;，删除它并获得&lt;code&gt;nums[i]&lt;/code&gt;的点数。之后，你必须删除每个等于&lt;code&gt;nums[i] - 1&lt;/code&gt;或&lt;code&gt;nums[i] + 1&lt;/code&gt;的元素。&lt;/li&gt;
&lt;li&gt;开始你拥有0个点数。返回你能通过这些操作获得的最大点数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: nums = [3, 4, 2]
输出: 6
解释: 
删除 4 来获得 4 个点数，因此 3 也被删除。
之后，删除 2 来获得 2 个点数。总共获得 6 个点数。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: nums = [2, 2, 3, 3, 3, 4]
输出: 9
解释: 
删除 3 来获得 3 个点数，接着要删除两个 2 和 4 。
之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。
总共获得 9 个点数。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;注意&#34;&gt;注意:&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nums&lt;/code&gt;的长度最大为&lt;code&gt;20000&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;每个整数&lt;code&gt;nums[i]&lt;/code&gt;的大小都在&lt;code&gt;[1, 10000]&lt;/code&gt;范围内。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第740题&#34;&gt;来源：力扣（LeetCode）第740题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/delete-and-earn&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/delete-and-earn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;这道题与另一道动态规划题打家劫舍几乎一模一样，状态转移方程基本没差。&lt;/li&gt;
&lt;li&gt;首先，我们应当使用一个计数方法把相同值放在一起。&lt;/li&gt;
&lt;li&gt;我们先来看最通俗版本，我们用两个状态，在当前第i位时拿或不拿，拿为0，不拿为1。

&lt;ul&gt;
&lt;li&gt;如果当前位置拿，那么要么是前一个位置没拿，要么是前两个位置拿了现在再拿。&lt;/li&gt;
&lt;li&gt;如果当前位置不拿，那么要么是前一个位置拿了，要么是前一个位置不拿现在依然不拿。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;再来看看优化后的版本，我们发现不管拿或不拿，我们都要判断前一个位置不拿的情况。因此我们可以直接判断出最优情况，也就是说，拿与不拿的状态可以省略，可以直接比较拿或不拿找到当前位置的最优解。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;初始版本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
public int deleteAndEarn(int[] nums) {
    int len = nums.length;
    if (len == 0) return 0;
    int max = nums[0];
    for (int i = 0; i &amp;lt; len; i++) if (max &amp;lt; nums[i]) max = nums[i];max++;
    int[] arr = new int[max];
    int[][] dp = new int[max][2];
    for (int i = 0; i &amp;lt; len; i++) arr[nums[i]]++;
    // 0 获取 1 不获取
    dp[1][0] = arr[1];
 // dp[1][1] = 0;
    for (int i = 2; i &amp;lt; max; i++) {
        // 这两句代码中的其中一个比较是相同的。
        dp[i][0] = Math.max(dp[i-2][0] , dp[i-1][1]) + arr[i] * i;
        dp[i][1] = Math.max(dp[i-1][0], dp[i-1][1]);
    }
    return Math.max(dp[max-1][0], dp[max-1][1]);
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;优化后：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
public int deleteAndEarn(int[] nums) {
    int len = nums.length;
    if (len == 0) return 0;
    int max = nums[0];
    for (int i = 0; i &amp;lt; len; i++) if (max &amp;lt; nums[i]) max = nums[i];max++;
    int[] arr = new int[max];
    int[] dp = new int[max];
    for (int i = 0; i &amp;lt; len; i++) arr[nums[i]]++;
    dp[1] = arr[1];
    for (int i = 2; i &amp;lt; max; i++) {
        dp[i] = Math.max(dp[i-2] + arr[i] * i, dp[i-1]);
    }
    return dp[max-1];
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>石子游戏II</title>
      <link>https://ripple-zjw.github.io/2019/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8Fii/</link>
      <pubDate>Wed, 23 Oct 2019 19:06:38 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8Fii/</guid>
      <description>

&lt;h1 id=&#34;题目-石子游戏-ii&#34;&gt;题目：石子游戏 II&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;亚历克斯和李继续他们的石子游戏。许多堆石子排成一行，每堆都有正整数颗石子&lt;code&gt;piles[i]&lt;/code&gt;。游戏以谁手中的石子最多来决出胜负。&lt;/li&gt;
&lt;li&gt;亚历克斯和李轮流进行，亚历克斯先开始。最初，M = 1。&lt;/li&gt;
&lt;li&gt;在每个玩家的回合中，该玩家可以拿走剩下的前&lt;code&gt;X&lt;/code&gt;堆的所有石子，其中&lt;code&gt;1 &amp;lt;= X &amp;lt;= 2M&lt;/code&gt;。然后，令&lt;code&gt;M = max(M, X)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;游戏一直持续到所有石子都被拿走。&lt;/li&gt;
&lt;li&gt;假设亚历克斯和李都发挥出最佳水平，返回亚历克斯可以得到的最大数量的石头。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：piles = [2,7,9,4,4]
输出：10
解释：
如果亚历克斯在开始时拿走一堆石子，李拿走两堆，接着亚历克斯也拿走两堆。在这种情况下，亚历克斯可以拿到 2 + 4 + 4 = 10 颗石子。 
如果亚历克斯在开始时拿走两堆石子，那么李就可以拿走剩下全部三堆石子。在这种情况下，亚历克斯可以拿到 2 + 7 = 9 颗石子。
所以我们返回更大的 10。 
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;提示&#34;&gt;提示：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= piles.length &amp;lt;= 100&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= piles[i] &amp;lt;= 10 ^ 4&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第1140题&#34;&gt;来源：力扣（LeetCode）第1140题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/stone-game-ii&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/stone-game-ii&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;这道题可以采用递归加记忆化搜索的方式进行。&lt;/li&gt;
&lt;li&gt;我们需要穷举出所有的状态。&lt;/li&gt;
&lt;li&gt;由于重复计算的地方太多，所以使用记忆化搜索，也可以说使用了动态规划。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    int len;
    int[] sum;int[][] dp;
    public int stoneGameII(int[] piles) {
        dp = new int[150][150]; // dp数组用来存放算过的值。
        len = piles.length;
        sum = new int[len+1];
        // 求第i个数到最后的总和。
        for (int i = len - 1; i &amp;gt;= 0; i--) sum[i] = sum[i+1] + piles[i];
        return dfs(0, 1);
    }
    // 返回从第i个石子堆开始，M为m的最优情况。
    public int dfs(int i, int m) {
        if (dp[i][m] != 0) return dp[i][m]; // 如果i，m已经算过了，不用再算了。
        if (i &amp;gt;= len) return 0; // i超出数组下标，也不用再算了，这是递归的基线条件。
        if (i + 2 * m &amp;gt;= len) return sum[i]; // 特殊情况，如果剩下的石子堆可以一次拿完，那么肯定全拿了。
        int best = 0; // 存放最优情况
        for (int x = 1; x &amp;lt;= 2 * m; x++) 
            /*
                如果i之前的石子堆被拿完，那么首先判断在这1-2*m次里Alex能拿到最大的情况是哪次。
                于是我们穷举每一次情况，找出最大的情况。
                每一次情况中，我们看从第i堆石子到最后。i + x，也就是你从i开始拿x堆石子，之间的总和。
                然后还要加上从i+x+1到最后你拿的最优情况，就是值最大的情况。
                因此，我们减去Lee的最优情况，因为Lee也会取最优，得到的就是Alex的情况。
            */
            best = Math.max(best, sum[i] - dfs(i + x, Math.max(m, x)));
        dp[i][m] = best;
        return best;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>