<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>双指针 on LeaveIt</title>
    <link>https://ripple-zjw.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/</link>
    <description>Recent content in 双指针 on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 06 Sep 2019 20:24:19 +0800</lastBuildDate>
    
	<atom:link href="https://ripple-zjw.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>两数之和II 输入有序数组</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8Cii-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Fri, 06 Sep 2019 20:24:19 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8Cii-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
      <description>题目：两数之和 II - 输入有序数组  给定一个已按照升序排列的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中index1必须小于index2。  说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。  示例: 输入: numbers = [2, 7, 11, 15], target = 9 输出: [1,2] 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。  来源：力扣（LeetCode）第167题  链接：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted
 分析： 方法有：hash表，二分查找，双指针。
代码：  hash表:
class Solution: def twoSum(self, numbers: List[int], target: int) -&amp;gt; List[int]: hashTable = {} for i in range(len(numbers)): if hashTable.</description>
    </item>
    
    <item>
      <title>复写零</title>
      <link>https://ripple-zjw.github.io/2019/%E5%A4%8D%E5%86%99%E9%9B%B6/</link>
      <pubDate>Fri, 06 Sep 2019 20:16:32 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%A4%8D%E5%86%99%E9%9B%B6/</guid>
      <description>题目：复写零  给你一个长度固定的整数数组arr，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。 注意：请不要在超过该数组长度的位置写入元素。 要求：请对输入的数组就地进行上述修改，不要从函数返回任何东西。  示例 1： 输入：[1,0,2,3,0,4,5,0] 输出：null 解释：调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4]  示例 2： 输入：[1,2,3] 输出：null 解释：调用函数后，输入的数组将被修改为：[1,2,3]  提示：  1 &amp;lt;= arr.length &amp;lt;= 10000 0 &amp;lt;= arr[i] &amp;lt;= 9  来源：力扣（LeetCode）第1089题  链接：https://leetcode-cn.com/problems/duplicate-zeros
 分析： 这道题的难点在于要在原数组上操作，不可以申请新的数组。因此，快慢双指针就派上用场了。
思路：  声明两个指针i,j 一个指针正常遍历i，另一个j遇到0就往前再+1 遍历完之后i之后的数都是被移出去的，j指针在最后一位 依次将i指针的元素赋在j的位置，遇到0，j不仅要将i的值赋上，还要往前一位再赋上0。  代码：  双指针法：
class Solution: def duplicateZeros(self, arr: List[int]) -&amp;gt; None: i = j = 0 n = len(arr) while j &amp;lt; n: if arr[i] == 0: j += 1 i += 1 j += 1 i -= 1 j -= 1 while i &amp;gt;= 0: if j &amp;lt; n: arr[j] = arr[i] if arr[i] == 0: j -= 1 arr[j] = 0 j -= 1 i -= 1  非原地解法：</description>
    </item>
    
    <item>
      <title>有序数组的平方</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</link>
      <pubDate>Fri, 23 Aug 2019 13:01:17 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</guid>
      <description>题目：有序数组的平方  给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。  示例 1： 输入：[-4,-1,0,3,10] 输出：[0,1,9,16,100]  示例 2： 输入：[-7,-3,2,3,11] 输出：[4,9,9,49,121]  提示：  1 &amp;lt;= A.length &amp;lt;= 10000 10000 &amp;lt;= A[i] &amp;lt;= 10000 A已按非递减顺序排序。  来源：力扣（LeetCode）第977题  链接：https://leetcode-cn.com/problems/squares-of-a-sorted-array
 分析： 这道题的方法有两种，一种最简单，先计算，再排序。第二种用双指针做到一遍遍历解答。
思路：  由于数组是按照递增的顺序增长的，因此所有的正数都是递增的，所有的负数加上绝对值都是递减的。 我们用两个指针i和j，i从前往后遍历，j从后往前遍历。 i遇到正数就停下来，j遇到负数就停下来，然后比较他们两谁小，小的那个放到ans答案中。 然后就把放入答案中的那个指针往后前移。 最后退出循环，但是可能有一个指针并没有移到终点，因此要在循环结束后去判断两个指针的情况，把指针后面的值都加到ans中去。 最后得到答案。  代码： class Solution: def sortedSquares(self, A: List[int]) -&amp;gt; List[int]: i = 0 j = len(A) - 1 ans = [] while i &amp;lt; len(A) and j &amp;gt;= 0: # 主循环 while i &amp;lt; len(A) and A[i] &amp;lt; 0: # 遍历到第一个正数 i += 1 while j &amp;gt;= 0 and A[j] &amp;gt;= 0: # 遍历到第一个负数 j -= 1 if i &amp;lt; len(A) and j &amp;gt;= 0: # 谁小就把谁加进来 if A[i] ** 2 &amp;gt; A[j] ** 2: ans.</description>
    </item>
    
    <item>
      <title>接雨水</title>
      <link>https://ripple-zjw.github.io/2019/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</link>
      <pubDate>Fri, 23 Aug 2019 12:55:03 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</guid>
      <description>题目：接雨水  给定n个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。   上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。感谢 Marcos 贡献此图。  示例: 输入: [0,1,0,2,1,0,1,3,2,1,2,1] 输出: 6  来源：力扣（LeetCode）第42题  链接：https://leetcode-cn.com/problems/trapping-rain-water
 分析： 方法太多了，一道极难题，从暴力法，到动态规划，再到单调栈，再到双指针。方法非常多，也很难理解，暴力法最好理解，dp和双指针稍难，我这里讲单调栈的方法。
思路：  维护一个单调递减栈。 当有值比栈顶元素大的时候做这么几件事情：  先出栈一个元素并保存到top中。 然后判断stack是否是空，如果是空的话，说明出栈的左边没有东西，所以无法装雨水。(一定要两边都要有东西并且两边的墙比出栈的墙要长，这样才能装雨水) 算出当前元素与栈顶元素中间的距离dis(注意现在是出栈之后的栈顶元素) 算出当前元素与栈顶元素中哪个值最小，并将小的那个值与出栈的那个元素相减，得到floor_cnt 为什么要叫floor_cnt呢，因为将floor_cnt与dis(也就是两栋大墙之间的距离)相乘，你就能得到在这两栋墙之间一层的雨水数量。 将它们加到ans答案中。例如：如果两栋墙最小的那栋是3，那么就会有3层，每一层的雨水数量可能是不一样的，所以要算3遍。 最后返回ans得到答案。  如果值比栈顶元素小的话就入栈就行了，这样就能维护单调递减栈。(注意栈中存的是数组下标，为了算起来方便。)  Talk is cheap,show me the code. class Solution(object): def trap(self, height): stack = [] ans = 0 cur = 0 while cur &amp;lt; len(height): while stack and height[stack[-1]] &amp;lt; height[cur]: top = stack.</description>
    </item>
    
    <item>
      <title>双指针</title>
      <link>https://ripple-zjw.github.io/2019/%E5%8F%8C%E6%8C%87%E9%92%88/</link>
      <pubDate>Wed, 14 Aug 2019 13:22:20 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%8F%8C%E6%8C%87%E9%92%88/</guid>
      <description>运用双指针解题 参考题目：LeetCode（26、27题）  https://leetcode-cn.com/problemset/all/
 使用场景： 需要遍历一个数组，在遍历过程中根据要求改变数组中元素的值、位置等一些关系。我们可以使用两个指针进行求解。
例如：删除数组中的重复项，移除摸一个元素
双指针使用思路： 一个数（i）作为已经过滤了的标记，另一个数（j）去寻找不符合条件的数，找到之后将两个元素进行交换。这样当j完全遍历一遍时，就可以把不符合要求的数都放到后面去，i之前的数都是符合规范的数。这种思路和插入排序很像，都是将一个指针作为排好序的部分，只不过插入排序还需要将排好序的部分再遍历一遍，把新的值插入进去。
使用双指针的好处： 首先使用双指针是原地排序，不会需要额外的储存空间，空间复杂度是O（1）。而且被过滤的数并没有被移除，只是与后面符合要求的数进行交换，这样虽然是删除了这个数，但是不需要进行数据的搬移操作，大大节省了时间。
c语言代码：（LeetCode 26题） int removeDuplicates(int* nums, int numsSize){ if(numsSize==0) return 0; int i, j; for(j = 1, i = 0; j &amp;lt; numsSize; j++){ if(nums[i] != nums[j]){ i++; nums[i] = nums[j]; } } return i + 1; }  python代码：（LeetCode 27题） class Solution: def removeElement(self, nums: List[int], val: int) -&amp;gt; int: i = 0 for j in range(len(nums)): if nums[j] !</description>
    </item>
    
  </channel>
</rss>