<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeaveIt on LeaveIt</title>
    <link>https://ripple-zjw.github.io/</link>
    <description>Recent content in LeaveIt on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 01 Oct 2019 21:49:17 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>大礼包</title>
      <link>https://ripple-zjw.github.io/2019/%E5%A4%A7%E7%A4%BC%E5%8C%85/</link>
      <pubDate>Tue, 01 Oct 2019 21:49:17 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%A4%A7%E7%A4%BC%E5%8C%85/</guid>
      <description>

&lt;h1 id=&#34;题目-大礼包&#34;&gt;题目：大礼包&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;在LeetCode商店中， 有许多在售的物品。&lt;/li&gt;
&lt;li&gt;然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。&lt;/li&gt;
&lt;li&gt;现给定每个物品的价格，每个大礼包包含物品的清单，以及待购物品清单。请输出确切完成待购清单的最低花费。&lt;/li&gt;
&lt;li&gt;每个大礼包的由一个数组中的一组数据描述，最后一个数字代表大礼包的价格，其他数字分别表示内含的其他种类物品的数量。&lt;/li&gt;
&lt;li&gt;任意大礼包可无限次购买。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [2,5], [[3,0,5],[1,2,10]], [3,2]
输出: 14
解释: 
有A和B两种物品，价格分别为¥2和¥5。
大礼包1，你可以以¥5的价格购买3A和0B。
大礼包2， 你可以以¥10的价格购买1A和2B。
你需要购买3个A和2个B， 所以你付了¥10购买了1A和2B（大礼包2），以及¥4购买2A。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1]
输出: 11
解释: 
A，B，C的价格分别为¥2，¥3，¥4.
你可以用¥4购买1A和1B，也可以用¥9购买2A，2B和1C。
你需要买1A，2B和1C，所以你付了¥4买了1A和1B（大礼包1），以及¥3购买1B， ¥4购买1C。
你不可以购买超出待购清单的物品，尽管购买大礼包2更加便宜。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;说明&#34;&gt;说明:&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;最多6种物品， 100种大礼包。&lt;/li&gt;
&lt;li&gt;每种物品，你最多只需要购买6个。&lt;/li&gt;
&lt;li&gt;你不可以购买超出待购清单的物品，即使更便宜。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第638题&#34;&gt;来源：力扣（LeetCode）第638题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/shopping-offers&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/shopping-offers&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;动态规划解法，常规解法需要使用六维数组，实在太麻烦，而且每次的维度还不一样。&lt;/li&gt;
&lt;li&gt;使用状压dp的思想，把六维数组归为1维。&lt;/li&gt;
&lt;li&gt;因为每一维的长度是0-6，所以我们把这7个数变为一个七进制的数字，但是把它变为10进制存在一个一维数组中。&lt;/li&gt;
&lt;li&gt;比如&lt;code&gt;111&lt;/code&gt;就是57，它表示a,b,c各有1个。如果是4个1，那就是a,b,c,d各有1个，然后它也有对应的十进制数。&lt;/li&gt;
&lt;li&gt;因此，我们把&lt;code&gt;needs&lt;/code&gt;中的数看成是一个七进制数，然后把它以十进制表示出来。&lt;/li&gt;
&lt;li&gt;比如&lt;code&gt;need&lt;/code&gt;如果是&lt;code&gt;121&lt;/code&gt;，那么结果是64。那么我们就开辟一个65个的数组。最后把dp[64]返回就是最终答案了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int shoppingOffers(List&amp;lt;Integer&amp;gt; price, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; special, List&amp;lt;Integer&amp;gt; needs) {
        int[] Decinal = {1, 7, 49, 343, 2401, 16807, 117649}; // 7的一次方，7的二次方....用于算7进制数转10进制数。
        int goods = price.size(); // 物品的总数量。
        for (int i = 0; i &amp;lt; goods; i++) { // 把每一个物品各买一个的情况放入大礼包中，因为大礼包不可能正好等于needs，还要添加单个买的数量。
            List&amp;lt;Integer&amp;gt; tmp = new ArrayList();
            for (int j = 0; j &amp;lt; goods; j++) tmp.add(0);
            tmp.set(i, 1);
            tmp.add(price.get(i));
            special.add(tmp);
        }
        int box = special.size(); // 大礼包的数量。
        int tol = change(needs, goods, Decinal); // 算出总量,比如needs是[1,2,1],那么就会算出64，也就是说有0-64个情况。[0,0,0]-[1,2,1](7进制)
        long[] dp = new long[tol+1]; // 每一种情况放在数组的相应位置。注意这里类型必须是long或以上，否则等会比大小的时候会因为过大而溢出。
        Arrays.fill(dp, Integer.MAX_VALUE); // 初始化为最大值。
        dp[0] = 0; // base case 0。
        for (int i = 0; i &amp;lt; box; i++) {
            for (int j = 0; j &amp;lt;= tol; j++) {
                if (!check(special.get(i), needs, j)) continue; // 检查加上这个大礼包后是不是多出去了。
                int state = change(special.get(i), goods, Decinal) + j; // 算出加上大礼包后在dp中对应的位置。
                dp[state] = Math.min(dp[state], dp[j] + special.get(i).get(goods)); // 更新dp，取最小的情况。
            }
        }
        return (int)dp[tol]; // 返回，注意强转回int类型。
    }
    
    public int change(List&amp;lt;Integer&amp;gt; sp, int n, int[] Deci) { // 把7进制数变为10进制数。
        int res = 0;
        for (int i = 0; i &amp;lt; n; i++) res += sp.get(i) * Deci[i]; // 7变10公式,sp[i] * 7 ** i,i从0开始。
        return res;
    }
    
    public boolean check(List&amp;lt;Integer&amp;gt; sp, List&amp;lt;Integer&amp;gt; needs, int cur) { // 检查数量是否小于needs。
        for (int i = 0; i &amp;lt; sp.size() - 1; i++) {
            if (cur % 7 + sp.get(i) &amp;gt; needs.get(i)) return false;//7进制最左边一位就是a物品的数量，加上当前大礼包后和needs的a物品数量进行比较
            cur /= 7; // 相当于向右移一位，那么a物品就没了，最左边的变成了b物品。
        }
        return true;
    }

}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>穿过迷宫的最少移动次数</title>
      <link>https://ripple-zjw.github.io/2019/%E7%A9%BF%E8%BF%87%E8%BF%B7%E5%AE%AB%E7%9A%84%E6%9C%80%E5%B0%91%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0/</link>
      <pubDate>Tue, 01 Oct 2019 21:43:48 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%A9%BF%E8%BF%87%E8%BF%B7%E5%AE%AB%E7%9A%84%E6%9C%80%E5%B0%91%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0/</guid>
      <description>

&lt;h1 id=&#34;题目-穿过迷宫的最少移动次数&#34;&gt;题目：穿过迷宫的最少移动次数&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;你还记得那条风靡全球的贪吃蛇吗？&lt;/li&gt;
&lt;li&gt;我们在一个&lt;code&gt;n*n&lt;/code&gt;的网格上构建了新的迷宫地图，蛇的长度为 2，也就是说它会占去两个单元格。蛇会从左上角&lt;code&gt;(0, 0)&lt;/code&gt;和&lt;code&gt;(0, 1)&lt;/code&gt;开始移动。我们用 0 表示空单元格，用 1 表示障碍物。蛇需要移动到迷宫的右下角&lt;code&gt;(n-1, n-2)&lt;/code&gt;和&lt;code&gt;(n-1, n-1)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;每次移动，蛇可以这样走：

&lt;ul&gt;
&lt;li&gt;如果没有障碍，则向右移动一个单元格。并仍然保持身体的水平／竖直状态。&lt;/li&gt;
&lt;li&gt;如果没有障碍，则向下移动一个单元格。并仍然保持身体的水平／竖直状态。&lt;/li&gt;
&lt;li&gt;如果它处于水平状态并且其下面的两个单元都是空的，就顺时针旋转 90 度。蛇从（&lt;code&gt;(r, c)&lt;/code&gt;、&lt;code&gt;(r, c+1)&lt;/code&gt;）移动到 （&lt;code&gt;(r, c)&lt;/code&gt;、&lt;code&gt;(r+1, c)&lt;/code&gt;）。
&lt;img src=&#34;https://ripple-zjw.github.io/images/穿过迷宫的最少移动次数/image-2.png&#34; alt=&#34;image&#34; /&gt;&lt;/li&gt;
&lt;li&gt;如果它处于竖直状态并且其右面的两个单元都是空的，就逆时针旋转 90 度。蛇从（&lt;code&gt;(r, c)&lt;/code&gt;、&lt;code&gt;(r+1, c)&lt;/code&gt;）移动到（&lt;code&gt;(r, c)&lt;/code&gt;、&lt;code&gt;(r, c+1)&lt;/code&gt;）。
&lt;img src=&#34;https://ripple-zjw.github.io/images/穿过迷宫的最少移动次数/image-1.png&#34; alt=&#34;image&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;返回蛇抵达目的地所需的最少移动次数。&lt;/li&gt;
&lt;li&gt;如果无法到达目的地，请返回-1。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1：&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;https://ripple-zjw.github.io/images/穿过迷宫的最少移动次数/image.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输入：grid = [[0,0,0,0,0,1],
               [1,1,0,0,1,0],
               [0,0,0,0,1,1],
               [0,0,1,0,1,0],
               [0,1,1,0,0,0],
               [0,1,1,0,0,0]]
输出：11
解释：
一种可能的解决方案是 [右, 右, 顺时针旋转, 右, 下, 下, 下, 下, 逆时针旋转, 右, 下]。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：grid = [[0,0,1,1,1,1],
               [0,0,0,0,1,1],
               [1,1,0,0,0,1],
               [1,1,1,0,0,1],
               [1,1,1,0,0,1],
               [1,1,1,0,0,0]]
输出：9
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;提示&#34;&gt;提示：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;2 &amp;lt;= n &amp;lt;= 100&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= grid[i][j] &amp;lt;= 1&lt;/li&gt;
&lt;li&gt;蛇保证从空单元格开始出发。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第5208题-临时&#34;&gt;来源：力扣（LeetCode）第5208题(临时)&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/minimum-moves-to-reach-target-with-rotations&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/minimum-moves-to-reach-target-with-rotations&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;这是一道较难的动态规划困难题，代码量非常的多。&lt;/li&gt;
&lt;li&gt;首先先找状态，状态有三个，分别是当蛇的尾巴在哪个点上的时候蛇是处于水平还是垂直。&lt;/li&gt;
&lt;li&gt;所以有dp数组为i, j, k。i代表尾巴的横坐标，j代表尾巴的纵坐标，k代表蛇是水平还是垂直状态。&lt;/li&gt;
&lt;li&gt;然后是选择，选择就是可以向右移一格或向下移一格或水平边垂直以及垂直边水平。&lt;/li&gt;
&lt;li&gt;每一种选择进行后答案就会+1，所以状态选择方程就是将当前状态进行每一次选择，看看当前状态次数+1之后是否比那种状态下的次数小，小就更新那种状态。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int minimumMoves(int[][] grid) {
        int n = grid.length;
        int[][][] dp = new int[n][n][2]; // 放上三种状态，尾巴的横纵坐标和垂直或水平,0表示水平,1表示垂直。
        int[] dx = {0, 1}, dy = {1, 0}; // 如果让蛇向右移动一格，那么蛇整个身体x轴不变，y轴+1，同理向下也一样。
        dp[0][0][0] = 1;
        // base case是1，为什么是一呢，因为java开辟数组时默认会把所有数组归为0，本来应该是0，但是为了方便先让他比答案多1，最后返回时再-1就行了
        for (int i = 0; i &amp;lt; n; i++) {
            for (int j = 0; j &amp;lt; n; j++) {
                // Rotate
                for (int k = 0; k &amp;lt; 2; k++) {
                    if (dp[i][j][k] == 0) continue; // 等于0说明当前位置不可达，不用计算。
                    if (i + 1 &amp;gt;= n || j + 1 &amp;gt;= n) continue; // 如果i+1或j+1超出边界，说明它不可能做翻转操作，因为另一种状态以及越界了。
                    if (k == 0) { // 水平位置判断下面以及右下位置是否有障碍，没有才能更新
                        if (grid[i+1][j] != 1 &amp;amp;&amp;amp; grid[i+1][j+1] != 1)
                            // 如果要更新的状态本来里面存的次数要少，那就不用更新了。
                            if (dp[i][j][1-k] == 0 || dp[i][j][1-k] &amp;gt; dp[i][j][k] + 1) dp[i][j][1-k] = dp[i][j][k] + 1;
                    } else { // 垂直位置判断右边以及右下位置
                        if (grid[i][j+1] != 1 &amp;amp;&amp;amp; grid[i+1][j+1] != 1)
                            if (dp[i][j][1-k] == 0 || dp[i][j][1-k] &amp;gt; dp[i][j][k] + 1) dp[i][j][1-k] = dp[i][j][k] + 1;
                    }
                }
                
                // move
                for (int k = 0; k &amp;lt; 2; k++) {
                    if (dp[i][j][k] == 0) continue; // 同理当前位置不可达，结束
                    int[] nx = new int[2], ny = new int[2]; // nx,ny表示蛇身体的位置，前一个是尾巴，后一个是头
                    for (int w = 0; w &amp;lt; 2; w++) { // w循环表示蛇向右移动和向下移动
                        boolean flag = true; // 用于判断蛇是否能到达，就是有没有障碍物
                        nx[0] = i;nx[1] = i + dx[k]; // 计算蛇的身体位置。
                        ny[0] = j;ny[1] = j + dy[k];
                        for (int mv = 0; mv &amp;lt; 2; mv++) { // mv循环表示移动蛇的尾巴和头，先移尾巴后头。
                            nx[mv] += dx[w];ny[mv] += dy[w]; // 计算移动后的位置。
                            if (nx[mv] &amp;lt; 0 || nx[mv] &amp;gt;= n || ny[mv] &amp;lt; 0 || ny[mv] &amp;gt;= n) flag = false; 
                            // 如果移动后身体的某个位置超出数组，说明不可达。
                            else if (grid[nx[mv]][ny[mv]] == 1) flag = false; // 同样有障碍也不可达。
                        }
                        if (flag == false) continue; // 不可达就不能更新。
                        if (dp[nx[0]][ny[0]][k] == 0 || dp[nx[0]][ny[0]][k] &amp;gt; dp[i][j][k] + 1) dp[nx[0]][ny[0]][k] = dp[i][j][k] + 1;
                    }
                }
            }
        }
        return dp[n-1][n-2][0] - 1; // 蛇最后结束的位置就是尾巴在(n-1, n-2)上处于水平状态。然后别忘了之前的-1。
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n^2)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n^2)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>买卖股票的最佳时机含手续费</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/</link>
      <pubDate>Tue, 01 Oct 2019 21:42:37 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/</guid>
      <description>

&lt;h1 id=&#34;题目-买卖股票的最佳时机含手续费&#34;&gt;题目：买卖股票的最佳时机含手续费&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个整数数组&lt;code&gt;prices&lt;/code&gt;，其中第&lt;code&gt;i&lt;/code&gt;个元素代表了第&lt;code&gt;i&lt;/code&gt;天的股票价格 ；非负整数&lt;code&gt;fee&lt;/code&gt;代表了交易股票的手续费用。&lt;/li&gt;
&lt;li&gt;你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。&lt;/li&gt;
&lt;li&gt;返回获得利润的最大值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: prices = [1, 3, 2, 8, 4, 9], fee = 2
输出: 8
解释: 能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;注意&#34;&gt;注意:&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;0 &amp;lt; prices.length &amp;lt;= 50000.&lt;/li&gt;
&lt;li&gt;0 &amp;lt; prices[i] &amp;lt; 50000.&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= fee &amp;lt; 50000.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第714题&#34;&gt;来源：力扣（LeetCode）第714题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;这道题看似很难，但只要找准状态，就变得很简单。&lt;/li&gt;
&lt;li&gt;我们把数组长度理解为天数，我们每一天只要知道两个状态。&lt;/li&gt;
&lt;li&gt;cost：手里没有股票的最大利润&lt;/li&gt;
&lt;li&gt;hold：手里有股票的最大利润&lt;/li&gt;
&lt;li&gt;如果当天是cost，有两种可能，一种是昨天手里就没股票，今天依然不买。第二种昨天手里有股票，今天卖了。&lt;/li&gt;
&lt;li&gt;如果当天是hold，也有两种可能，一种昨天手里有股票，今天不操作，另一种昨天手里没股票，今天买了。&lt;/li&gt;
&lt;li&gt;你每次都要选择最优的情况，比如昨天100.今天就10块，如果你手里有股票，那你肯定不会卖。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int maxProfit(int[] prices, int fee) {
        int cash = 0, hold = -prices[0];
        for (int i = 1; i &amp;lt; prices.length; i++) {
            cash = Math.max(cash, hold + prices[i] - fee);
            hold = Math.max(hold, cash - prices[i]);
        }
        return cash;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def maxProfit(self, prices: List[int], fee: int) -&amp;gt; int:
        cash, hold = 0, -prices[0]
        for i in range(1, len(prices)):
            cash = max(cash, prices[i] + hold - fee)
            hold = max(hold, cash - prices[i])
        return cash
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>机器人大冒险</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%A4%A7%E5%86%92%E9%99%A9/</link>
      <pubDate>Tue, 01 Oct 2019 21:40:38 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%A4%A7%E5%86%92%E9%99%A9/</guid>
      <description>

&lt;h1 id=&#34;题目-机器人大冒险&#34;&gt;题目：机器人大冒险&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;力扣团队买了一个可编程机器人，机器人初始位置在原点&lt;code&gt;(0, 0)&lt;/code&gt;。小伙伴事先给机器人输入一串指令&lt;code&gt;command&lt;/code&gt;，机器人就会无限循环这条指令的步骤进行移动。指令有两种：&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;U&lt;/code&gt;: 向&lt;code&gt;y&lt;/code&gt;轴正方向移动一格&lt;/li&gt;
&lt;li&gt;&lt;code&gt;R&lt;/code&gt;: 向&lt;code&gt;x&lt;/code&gt;轴正方向移动一格。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;不幸的是，在xy平面上还有一些障碍物，他们的坐标用&lt;code&gt;obstacles&lt;/code&gt;表示。机器人一旦碰到障碍物就会被损毁。&lt;/li&gt;
&lt;li&gt;给定终点坐标&lt;code&gt;(x,y)&lt;/code&gt;，返回机器人能否完好地到达终点。如果能，返回&lt;code&gt;true&lt;/code&gt;；否则返回&lt;code&gt;false&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：command = &amp;quot;URR&amp;quot;, obstacles = [], x = 3, y = 2
输出：true
解释：U(0, 1) -&amp;gt; R(1, 1) -&amp;gt; R(2, 1) -&amp;gt; U(2, 2) -&amp;gt; R(3, 2)。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：command = &amp;quot;URR&amp;quot;, obstacles = [[2, 2]], x = 3, y = 2
输出：false
解释：机器人在到达终点前会碰到(2, 2)的障碍物。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-3&#34;&gt;示例 3：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：command = &amp;quot;URR&amp;quot;, obstacles = [[4, 2]], x = 3, y = 2
输出：true
解释：到达终点后，再碰到障碍物也不影响返回结果。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;限制&#34;&gt;限制：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;2 &amp;lt;= command&lt;/code&gt;的长度&lt;code&gt;&amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;command由U，R构成，且至少有一个U，至少有一个R&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= x &amp;lt;= 1e9&lt;/code&gt;,&lt;code&gt;0 &amp;lt;= y &amp;lt;= 1e9&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= obstacles&lt;/code&gt;的长度&lt;code&gt;&amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;obstacles[i]&lt;/code&gt;不为原点或者终点&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-lcp-3&#34;&gt;来源：力扣（LeetCode）LCP.3&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/programmable-robot&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/programmable-robot&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;由于x和y最多10亿，一个一个遍历肯定不现实。&lt;/li&gt;
&lt;li&gt;经过思考发现，我们可以找每一个要找的点的前一行或前一列的最后一个。&lt;/li&gt;
&lt;li&gt;比如终点为&lt;code&gt;(x, y)&lt;/code&gt;，我们可以找到x-1或者y-1时的最后一个位置。&lt;/li&gt;
&lt;li&gt;然后再遍历一遍就能判断是否经过该点。因为&lt;code&gt;command&lt;/code&gt;至少有一个U和R。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public boolean robot(String command, int[][] obstacles, int x, int y) {
        int dx = 0, dy = 0;
        char[] cmd = command.toCharArray(); // 把String转为数组，方便遍历。
        for (char c : cmd) { // 算出up和right各有多少个。
            if (c == &#39;U&#39;) dy++;
            else dx++;
        }
        int ans = isPassed(cmd, x, y, dx, dy); // 拿到走到终点的次数。
        // 先看isPassed函数再往下看。
        /*
            为什么isPassed要拿到走的总次数而不直接返回true或false呢
            比如你发现有一个obstacle是经过的，那么最终答案并不一定是false，
            因为如果终点在这个点的前面，那么机器人根本不会走到那个点。答案是true。
        */
        if (ans == -1) return false; // 终点都没经过，肯定false
        for (int[] obstacle : obstacles) {
            int cnt = isPassed(cmd, obstacle[0], obstacle[1], dx, dy);
            if (cnt != -1 &amp;amp;&amp;amp; cnt &amp;lt; ans) return false; 
            //不等于-1，说明经过了，然后再看这个点和终点哪个次数多。ans多，说明这个点在ans前面，返回false。
        }
        return true;
    }
    // 判断是否经过该点，经过返回走的次数，没经过返回-1。
    public int isPassed(char[] cmd, int x, int y, int dx, int dy) {
        int round = Math.min(x / dx, y / dy); // 计算走到第x-1或y-1层需要多少轮
        int cnt = cmd.length * round;  // 前几轮的总次数
        dx *= round; dy *= round; // 在第x-1或y-1层时的位置。
        if (dx == x &amp;amp;&amp;amp; dy == y) return cnt; // 正好就是要找的点，直接返回。
        for (char c : cmd) { // 遍历第x层或y层，如果经过，那么答案一定会遍历到。
            if (c == &#39;U&#39;) dy++; // 要按command的顺序走
            else dx++;
            cnt++; // 不要忘了每遍历一次，次数都要加1
            if (dx == x &amp;amp;&amp;amp; dy == y) return cnt; // 一旦找到，直接返回所需要的次数。
        }
        return -1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>两个字符串的最小ASCII删除和</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8Fascii%E5%88%A0%E9%99%A4%E5%92%8C/</link>
      <pubDate>Tue, 01 Oct 2019 21:36:41 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8Fascii%E5%88%A0%E9%99%A4%E5%92%8C/</guid>
      <description>

&lt;h1 id=&#34;题目-两个字符串的最小ascii删除和&#34;&gt;题目：两个字符串的最小ASCII删除和&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定两个字符串s1,s2，找到使两个字符串相等所需删除字符的ASCII值的最小和。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: s1 = &amp;quot;sea&amp;quot;, s2 = &amp;quot;eat&amp;quot;
输出: 231
解释: 在 &amp;quot;sea&amp;quot; 中删除 &amp;quot;s&amp;quot; 并将 &amp;quot;s&amp;quot; 的值(115)加入总和。
在 &amp;quot;eat&amp;quot; 中删除 &amp;quot;t&amp;quot; 并将 116 加入总和。
结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: s1 = &amp;quot;delete&amp;quot;, s2 = &amp;quot;leet&amp;quot;
输出: 403
解释: 在 &amp;quot;delete&amp;quot; 中删除 &amp;quot;dee&amp;quot; 字符串变成 &amp;quot;let&amp;quot;，
将 100[d]+101[e]+101[e] 加入总和。在 &amp;quot;leet&amp;quot; 中删除 &amp;quot;e&amp;quot; 将 101[e] 加入总和。
结束时，两个字符串都等于 &amp;quot;let&amp;quot;，结果即为 100+101+101+101 = 403 。
如果改为将两个字符串转换为 &amp;quot;lee&amp;quot; 或 &amp;quot;eet&amp;quot;，我们会得到 433 或 417 的结果，比答案更大。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;注意&#34;&gt;注意:&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;0 &amp;lt; s1.length, s2.length &amp;lt;= 1000。&lt;/li&gt;
&lt;li&gt;所有字符串中的字符ASCII值在[97, 122]之间。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第712题&#34;&gt;来源：力扣（LeetCode）第712题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;这道题和LCS最长公共子序列非常像。&lt;/li&gt;
&lt;li&gt;使用动态规划，分别找到&lt;code&gt;[:i]&lt;/code&gt;和&lt;code&gt;[:j]&lt;/code&gt;作为状态。&lt;/li&gt;
&lt;li&gt;而选择就是对于每个&lt;code&gt;[:i]&lt;/code&gt;和&lt;code&gt;[:j]&lt;/code&gt;,都有两种可能，就是第i个和第j个相同时或不同时。&lt;/li&gt;
&lt;li&gt;相同时，你需要找到[:i-1]和[:j-1]时的答案。&lt;/li&gt;
&lt;li&gt;不同时，你有两种选择，要么删除i，要么删除j。&lt;/li&gt;
&lt;li&gt;删除i就把[:i-1]的答案拿出来再加上i，删除j就把[:j-1]的答案拿出来，再加上j。&lt;/li&gt;
&lt;li&gt;根据题意，要最小的答案，所以选取二者中最小的那个。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int minimumDeleteSum(String s1, String s2) {
        if (s1.equals(s2)) return 0;
        int m = s1.length(), n = s2.length();
        int[][] dp = new int[m+1][n+1];
        dp[0][0] = 0; // 初始化第一个数就是两个字符串都为空时。
        /*如果有一个字符串为空，那么答案就是另一个字符串中的所有ascll码相加*/
        for (int i = 0; i &amp;lt; m; i++) dp[i+1][0] = dp[i][0] + s1.codePointAt(i);
        for (int j = 0; j &amp;lt; n; j++) dp[0][j+1] = dp[0][j] + s2.codePointAt(j);
        for (int i = 1; i &amp;lt;= m; i++) {
            for (int j = 1; j &amp;lt;= n; j++) {
                // 两种情况
                if (s1.charAt(i-1) == s2.charAt(j-1)) dp[i][j] = dp[i-1][j-1];
                else dp[i][j] = Math.min(dp[i-1][j] + s1.codePointAt(i-1), dp[i][j-1] + s2.codePointAt(j-1));
            }
        }
        return dp[m][n];
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n^2)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n^2)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>不同的二叉搜索树II</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91ii/</link>
      <pubDate>Tue, 01 Oct 2019 21:34:34 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91ii/</guid>
      <description>

&lt;h1 id=&#34;题目-不同的二叉搜索树-ii&#34;&gt;题目：不同的二叉搜索树 II&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个整数n，生成所有由&lt;code&gt;1...n&lt;/code&gt;为节点所组成的二叉搜索树。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: 3
输出:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释:
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第95题&#34;&gt;来源：力扣（LeetCode）第95题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/unique-binary-search-trees-ii&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/unique-binary-search-trees-ii&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;可以使用递归，但我怕超时就没写。&lt;/li&gt;
&lt;li&gt;但是几乎所有的递归都可以转换为动态规划，所以这题用dp求解。&lt;/li&gt;
&lt;li&gt;思路和前面找个数一样，状态都是第n个数的内容，选择是谁为根节点。&lt;/li&gt;
&lt;li&gt;不一样的是状态转移方程稍稍有点复杂，我在代码中说明。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List&amp;lt;TreeNode&amp;gt; generateTrees(int n) {
        List&amp;lt;TreeNode&amp;gt;[] dp = new ArrayList[n+1];
        dp[0] = new ArrayList(); // 如果left或right为0，就会出现空指针异常。
        if (n == 0) return dp[0];
        dp[0].add(null);// 如果不加null，那么后面当left或right为0时，就不会执行for循环。而一旦left不执行，right也会被跳过。
        for (int i = 1; i &amp;lt;= n; i++) {
            dp[i] = new ArrayList();
            for (int root = 1; root &amp;lt;= i; root++) {
                int left = root - 1; // root为根节点，left是root左边的节点数。
                int right = i - root;// 同理，right为root右边的节点数。
                /*
                    假设n为5，root是3，那么左边有2个节点，所以去dp[2]里面找，右边也有两个节点4,5。所以还去dp[2]里面找。
                    因为只有dp[2]里面都是2个节点的数。但是dp[2]中的数只有1和2，我们要的是4,5。
                    我们不妨将1,2加上root，你会发现正好是4,5。
                    所以得到结论，左子树的值直接找前面节点数一样的dp索引，右子树的值也找前面一样的dp索引,
                    但是你需要加上root才能保证val是你需要的，所以右子树要重新创建，不然会破坏前面的树。
                */
                // 如果dp[left]里有两种可能，dp[right]里有三种可能，那么总共有6种可能。
                for (TreeNode leftTree : dp[left]) {
                    for (TreeNode rightTree : dp[right]) {
                        TreeNode newRoot = new TreeNode(root); // 这个是每一种可能的root节点。
                        newRoot.left = leftTree; // 左子树直接连接。
                        newRoot.right = clone(root, rightTree); // 右子树创建一个新的树。
                        dp[i].add(newRoot); // 将一种可能加入dp中。
                    }
                }
            }
        }
        return dp[n]; // 这个不用多说，答案在第n个数上。
    }
    
    public TreeNode clone(int val, TreeNode root) { // 重新创建一个新的子树
        if (root == null) return null; // 如果为null，返回
        TreeNode newTree = new TreeNode(val + root.val); // 创建节点时，不要忘了还要加上那个root。
        newTree.left = clone(val, root.left); // 递归左和右，和先序遍历很像。
        newTree.right = clone(val, root.right);
        return newTree; // 返回回去的这个节点正好跟在你需要的右子树上。
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>石子游戏</title>
      <link>https://ripple-zjw.github.io/2019/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/</link>
      <pubDate>Tue, 01 Oct 2019 21:32:58 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/</guid>
      <description>

&lt;h1 id=&#34;题目-石子游戏&#34;&gt;题目：石子游戏&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子&lt;code&gt;piles[i]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。&lt;/li&gt;
&lt;li&gt;亚历克斯和李轮流进行，亚历克斯先开始。每回合，玩家从行的开始或结束处取走整堆石头。这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。&lt;/li&gt;
&lt;li&gt;假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回&lt;code&gt;true&lt;/code&gt;，当李赢得比赛时返回&lt;code&gt;false&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：[5,3,4,5]
输出：true
解释：
亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。
假设他取了前 5 颗，这一行就变成了 [3,4,5] 。
如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。
如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。
这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;提示&#34;&gt;提示：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;2 &amp;lt;= piles.length &amp;lt;= 500&lt;/li&gt;
&lt;li&gt;piles.length 是偶数。&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= piles[i] &amp;lt;= 500&lt;/li&gt;
&lt;li&gt;sum(piles)是奇数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第877题&#34;&gt;来源：力扣（LeetCode）第877题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/stone-game&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/stone-game&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;这是一道典型的动态规划题。&lt;/li&gt;
&lt;li&gt;要做出动态规划问题，首先要找到问题的&lt;strong&gt;状态&lt;/strong&gt;和&lt;strong&gt;选择&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;以这道题为例，状态有三种，分别是开始位置索引&lt;code&gt;i&lt;/code&gt;，结束位置索引&lt;code&gt;j&lt;/code&gt;，还有在i到j这段位置时，先手的值和后手的值。&lt;/li&gt;
&lt;li&gt;举个例子，i = 0, j = 0时，表明在第一个索引0时先手明显是piles[0]，而后手没有东西，所以是0。&lt;/li&gt;
&lt;li&gt;说完状态再来看选择，根据题意，选择就是你可以从开始位置&lt;code&gt;i&lt;/code&gt;拿，也可以从结束位置&lt;code&gt;j&lt;/code&gt;拿。&lt;/li&gt;
&lt;li&gt;然后是状态转移方程，首先每一个i和j所对应的位置都有先后手两种情况，如果我选择拿了i的值，那么剩下留给另一个人的元素就是&lt;code&gt;i + 1 到 j&lt;/code&gt;,而&lt;code&gt;i + 1 到 j&lt;/code&gt;是另一个人先手拿的(&lt;code&gt;i+1,j&lt;/code&gt;先手就是&lt;code&gt;i,j&lt;/code&gt;的后手，因为一人一次)，所以你拿的是&lt;code&gt;i+1, j&lt;/code&gt;的后手。&lt;/li&gt;
&lt;li&gt;同理如果你拿的是右边的&lt;code&gt;j&lt;/code&gt;，那么剩下的就是&lt;code&gt;i, j - 1&lt;/code&gt;的后手。&lt;/li&gt;
&lt;li&gt;因此状态转移方程就是：&lt;code&gt;max(piles[i] + dp[i+1][j][1], piles[j] + dp[i][j-1][1])&lt;/code&gt;。dp是一个三维数组，前两个表示的是i,j位置索引，而1表示的是后手情况，那么0表示的是先手情况。(不一定是0,1也可以是别的，无所谓)&lt;/li&gt;
&lt;li&gt;最后我要的结果就是从0到piles长度的下标，即&lt;code&gt;dp[0][piles.length-1]&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public boolean stoneGame(int[] piles) {
        int N = piles.length;
        int[][][] dp = new int[N][N][2];
        for (int i = 0; i &amp;lt; N; i++) {
            dp[i][i][0] = piles[i];
            dp[i][i][1] = 0;
        }
        for (int size = 2; size &amp;lt;= N; size++) {
            for (int i = 0; i &amp;lt;= N - size; i++) {
                int j = i + size - 1; // 由于i,j之间的差一开始会是1，第二次是2...所以这样就保证了j的下标是对的。
                int left = piles[i] + dp[i+1][j][1];
                int right = piles[j] + dp[i][j-1][1];
                if (left &amp;lt; right) {  // 每次都取最优情况，不要忘了先手最优，但是后手也要添加进去的。
                    dp[i][j][0] = right;
                    dp[i][j][1] = dp[i][j-1][0];
                } else {
                    dp[i][j][0] = left;
                    dp[i][j][1] = dp[i+1][j][0];
                }
            }
        }
        return dp[0][N-1][0] &amp;gt; dp[0][N-1][1]; // 比较先手是否大于后手
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;你以为这样就结束了？？？&lt;/li&gt;
&lt;li&gt;如果你写完这段dp代码去测试，你就会发现一件神奇的事情，你无论怎么换测试用例，只要符合题目要求，答案都是true，也就是说只要Alex先手，那么他必赢。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;所以第二种方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def stoneGame(self, piles: List[int]) -&amp;gt; bool:
    return True
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n^2)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n^2)&lt;/li&gt;
&lt;li&gt;虽然是个三维数组，但最后一位是常数2，所以忽略不计。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>比特位计数</title>
      <link>https://ripple-zjw.github.io/2019/%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/</link>
      <pubDate>Sat, 21 Sep 2019 16:04:38 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/</guid>
      <description>

&lt;h1 id=&#34;题目-比特位计数&#34;&gt;题目：比特位计数&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个非负整数&lt;code&gt;num&lt;/code&gt;。对于&lt;code&gt;0 ≤ i ≤ num&lt;/code&gt; 范围中的每个数字&lt;code&gt;i&lt;/code&gt;，计算其二进制数中的&lt;code&gt;1&lt;/code&gt; 的数目并将它们作为数组返回。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: 2
输出: [0,1,1]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: 5
输出: [0,1,1,2,1,2]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;进阶&#34;&gt;进阶:&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？&lt;/li&gt;
&lt;li&gt;要求算法的空间复杂度为O(n)。&lt;/li&gt;
&lt;li&gt;你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如C++中的&lt;code&gt;__builtin_popcount&lt;/code&gt;）来执行此操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第338题&#34;&gt;来源：力扣（LeetCode）第338题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/counting-bits&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/counting-bits&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;由于偶数的二进制数最后一位是0，所以如果一个偶数做&lt;code&gt;&amp;gt;&amp;gt;1&lt;/code&gt;运算那么它的1的个数不变。同理如果一个奇数右移一位，1的个数减1。&lt;/li&gt;
&lt;li&gt;因此如果1有1个1，那么2也有1个1,3就有2个1。(正推的话做左移运算),如果2有1个1的话，那么4也是1个1,5就是2个1。&lt;/li&gt;
&lt;li&gt;所以有了状态转换公式&lt;code&gt;dp[2*i] = dp[i] dp[2*i+1] = dp[i] + 1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int[] countBits(int num) {
        int[] dp = new int[num + 1];
        for (int i = 0; i &amp;lt;= num / 2; i++) {
            dp[i&amp;lt;&amp;lt;1] = dp[i];
            if ((i&amp;lt;&amp;lt;1) + 1 &amp;lt;= num) dp[(i&amp;lt;&amp;lt;1)+1] = dp[i] + 1;
        }
        return dp;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n 为num / 2&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n) n 为num&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>有序链表转换二叉搜索树</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Sat, 21 Sep 2019 15:50:29 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>

&lt;h1 id=&#34;题目-有序链表转换二叉搜索树&#34;&gt;题目：有序链表转换二叉搜索树&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。&lt;/li&gt;
&lt;li&gt;本题中，一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过&lt;code&gt;1&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;给定的有序链表： [-10, -3, 0, 5, 9],

一个可能的答案是：[0, -3, 9, -10, null, 5],
它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第109题&#34;&gt;来源：力扣（LeetCode）第109题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;递归 + 快慢双指针

&lt;ul&gt;
&lt;li&gt;使用快慢指针找出链表的中点。&lt;/li&gt;
&lt;li&gt;然后将中点生成树的根。&lt;/li&gt;
&lt;li&gt;递归进入左右子树。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;模拟遍历中序二叉树

&lt;ul&gt;
&lt;li&gt;算出链表的长度&lt;/li&gt;
&lt;li&gt;把链表一分为二&lt;/li&gt;
&lt;li&gt;递归进入链表的左边和右边&lt;/li&gt;
&lt;li&gt;同时，在左边递归完后生成父节点&lt;/li&gt;
&lt;li&gt;再把递归得到的左右子节点放在父节点的left和right&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;递归 + 快慢双指针&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* Definition for singly-linked list.
* public class ListNode {
*     int val;
*     ListNode next;
*     ListNode(int x) { val = x; }
* }
*/
/**
* Definition for a binary tree node.
* public class TreeNode {
*     int val;
*     TreeNode left;
*     TreeNode right;
*     TreeNode(int x) { val = x; }
* }
*/
class Solution {
public TreeNode sortedListToBST(ListNode head) {
    return recursion(head,null);
}
public TreeNode recursion(ListNode point, ListNode end) {
    if (point == end) return null;
    ListNode head = point, fast = point, slow = point;
    while (fast != end &amp;amp;&amp;amp; fast.next != end) {slow = slow.next;fast = fast.next.next;}
    TreeNode node = new TreeNode(slow.val);
    node.left = recursion(head, slow);
    node.right = recursion(slow.next, end);
    return node;
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;模拟遍历中序二叉树&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* Definition for singly-linked list.
* public class ListNode {
*     int val;
*     ListNode next;
*     ListNode(int x) { val = x; }
* }
*/
/**
* Definition for a binary tree node.
* public class TreeNode {
*     int val;
*     TreeNode left;
*     TreeNode right;
*     TreeNode(int x) { val = x; }
* }
*/
class Solution {
private ListNode head;

public TreeNode sortedListToBST(ListNode head) {
    this.head = head;
    int cnt = -1;ListNode tail = head;
    while (tail != null) {cnt++;tail = tail.next;} // 拿到链表的长度
    return recursion(0, cnt);
}

public TreeNode recursion(int left, int right) {
    if (left &amp;gt; right) return null;
    int mid = (left + right) &amp;gt;&amp;gt; 1;
    TreeNode l = recursion(left, mid - 1);
    TreeNode node = new TreeNode(head.val);
    node.left = l;
    head = head.next;
    node.right = recursion(mid + 1, right);
    return node;
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
def sortedListToBST(self, head: ListNode) -&amp;gt; TreeNode:
    self.head = head
    tail = head
    cnt = -1
    while tail:
        cnt += 1
        tail = tail.next;

    def recursion(left, right):
        if left &amp;gt; right:
            return
        mid = (left + right) &amp;gt;&amp;gt; 1
        l = recursion(left, mid - 1)
        node = TreeNode(self.head.val)
        self.head = self.head.next
        node.left = l
        node.right = recursion(mid + 1, right)
        return node
    return recursion(0, cnt)   
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>回文链表</title>
      <link>https://ripple-zjw.github.io/2019/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sat, 21 Sep 2019 15:48:18 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</guid>
      <description>

&lt;h1 id=&#34;题目-回文链表&#34;&gt;题目：回文链表&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;请判断一个链表是否为回文链表。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: 1-&amp;gt;2
输出: false
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: 1-&amp;gt;2-&amp;gt;2-&amp;gt;1
输出: true
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;进阶&#34;&gt;进阶：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;你能否用&lt;code&gt;O(n)&lt;/code&gt;时间复杂度和&lt;code&gt;O(1)&lt;/code&gt;空间复杂度解决此题？&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第234题&#34;&gt;来源：力扣（LeetCode）第234题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/palindrome-linked-list&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/palindrome-linked-list&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;最常见的做法是将链表变为数组，通过数组的随机访问的特性检测回文链表。&lt;/li&gt;
&lt;li&gt;第二种更为方便的方法是使用快慢双指针找到链表的中点，然后将前半部分的链表翻转。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null)  //两种特殊情况 return true;
        ListNode slow = head, fast = head; //快慢指针
        while (fast != null &amp;amp;&amp;amp; fast.next != null) {slow = slow.next;fast = fast.next.next;} //找到链表的中间位置奇数找到的是正中间，偶数得到的是中间靠右的数
        ListNode pre = head.next, next; // 翻转前半链表，pre储存的是后面的结点，next储存的是head翻转后的head.next
        while (pre != slow) { // 如果pre等于slow，那么head会指向slow前面的那个数
            next = head;head = pre;  // 如果实在看不懂的话自己画一下就明白了
            pre = head.next;head.next = next;
        }
        if (fast != null) slow = slow.next; // 如果链表是奇数的长度，那么fast.next == null，这时slow往前移一位
        while (head != null &amp;amp;&amp;amp; slow != null) { // 检测是否回文
            if (head.val != slow.val) return false;
            head = head.next;slow = slow.next;
        }
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>环形链表</title>
      <link>https://ripple-zjw.github.io/2019/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sat, 21 Sep 2019 15:45:40 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</guid>
      <description>

&lt;h1 id=&#34;题目-环形链表&#34;&gt;题目：环形链表&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个链表，判断链表中是否有环。&lt;/li&gt;
&lt;li&gt;为了表示给定链表中的环，我们使用整数&lt;code&gt;pos&lt;/code&gt; 来表示链表尾连接到链表中的位置（索引从&lt;code&gt;0&lt;/code&gt;开始）。 如果&lt;code&gt;pos&lt;/code&gt;是&lt;code&gt;-1&lt;/code&gt;,则在该链表中没有环。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-3&#34;&gt;示例 3：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;进阶&#34;&gt;进阶：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;你能用 O(1)（即，常量）内存解决此问题吗？&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第141题&#34;&gt;来源：力扣（LeetCode）第141题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/linked-list-cycle&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/linked-list-cycle&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;这道题可以使用哈希表来做，但这样的空间复杂度是O(n),另一种方法是快慢双指针。&lt;/li&gt;
&lt;li&gt;使用两个指针，一个每次走一格，另一个每次走两格。&lt;/li&gt;
&lt;li&gt;最后看快指针会不会走到头，或者这两个指针碰到了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) return false;
        ListNode slow = head, fast = head.next;
        while (slow != fast) {
            if (fast == null || fast.next == null) return false;
            slow = slow.next;fast = fast.next.next;
        }
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用set来做&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* Definition for singly-linked list.
* class ListNode {
*     int val;
*     ListNode next;
*     ListNode(int x) {
*         val = x;
*         next = null;
*     }
* }
*/
public class Solution {
public boolean hasCycle(ListNode head) {
    Set&amp;lt;ListNode&amp;gt; cycle = new HashSet();
    while (head != null) {
        if (cycle.contains(head)) return true;
        cycle.add(head);
        head = head.next;
    }
    return false;
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>漂亮数组</title>
      <link>https://ripple-zjw.github.io/2019/%E6%BC%82%E4%BA%AE%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sat, 21 Sep 2019 15:32:09 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%BC%82%E4%BA%AE%E6%95%B0%E7%BB%84/</guid>
      <description>

&lt;h1 id=&#34;题目-漂亮数组&#34;&gt;题目：漂亮数组&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;对于某些固定的&lt;code&gt;N&lt;/code&gt;，如果数组&lt;code&gt;A&lt;/code&gt;是整数&lt;code&gt;1, 2, ...&lt;/code&gt;, &lt;code&gt;N&lt;/code&gt;组成的排列，使得：
对于每个&lt;code&gt;i &amp;lt; j&lt;/code&gt;，都不存在&lt;code&gt;k&lt;/code&gt;满足&lt;code&gt;i &amp;lt; k &amp;lt; j&lt;/code&gt;使得&lt;code&gt;A[k] * 2 = A[i] + A[j]&lt;/code&gt;。
那么数组&lt;code&gt;A&lt;/code&gt;是漂亮数组。&lt;/li&gt;
&lt;li&gt;给定&lt;code&gt;N&lt;/code&gt;，返回任意漂亮数组&lt;code&gt;A&lt;/code&gt;（保证存在一个）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：4
输出：[2,1,4,3]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：5
输出：[3,1,2,5,4]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;提示&#34;&gt;提示：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= N &amp;lt;= 1000&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第932题&#34;&gt;来源：力扣（LeetCode）第932题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/beautiful-array&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/beautiful-array&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;根据题目的要求，所谓漂亮数组就是&lt;code&gt;A[k] * 2 != A[i] + A[j]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A[k] * 2&lt;/code&gt;一定是一个偶数，那么我们只需要让&lt;code&gt;A[i] + A[j]&lt;/code&gt;是奇数就行了，如果我们把奇数放在左边，偶数放在右边，那么左右两边各取一个数相加一定是奇数。&lt;/li&gt;
&lt;li&gt;那么还有一个问题，若&lt;code&gt;i&lt;/code&gt;是偶数，&lt;code&gt;j&lt;/code&gt;也是偶数怎么办？&lt;/li&gt;
&lt;li&gt;如果我们要知道8个数的漂亮数组，首先8有4个奇数，4个偶数，我们需要知道4个数的漂亮数组，如果要知道4个数的漂亮数组又要分为2奇数，2偶数，直到为1个数时，漂亮数组为&lt;code&gt;[1]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;漂亮数组又有一个性质，如果我们把数组中每个元素都乘以a并且加上b(a,b为任意除0外的数)，那么它还是漂亮数组。&lt;/li&gt;
&lt;li&gt;同样的我们把奇偶两个漂亮数组相加，结果还是漂亮数组。&lt;/li&gt;
&lt;li&gt;既然如此，&lt;code&gt;[1]&lt;/code&gt;是漂亮数组，那么我将&lt;code&gt;1*2-1&lt;/code&gt;也是是漂亮数组，我将&lt;code&gt;1*2&lt;/code&gt;也是漂亮数组，我把这两个数放在一起，也就是&lt;code&gt;[1,2]&lt;/code&gt;也是漂亮数组。以此类推，4个数的漂亮数组就是&lt;code&gt;[1,3,2,4]&lt;/code&gt;,8个数就是&lt;code&gt;[1,5,3,7,2,6,4,8]&lt;/code&gt;。如果数不足8个多于4个，我只需要把多余的拿掉就行了。&lt;/li&gt;
&lt;li&gt;通过这种方式，可以发现，比如奇数部分的数两数相加除以2要么是偶数，要么在中间根本找不到这个数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;分治算法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def beautifulArray(self, N: int) -&amp;gt; List[int]:
    def divi(N):
        ans = {1: [1]}
        if N not in ans:
            odds = divi((N + 1) // 2)
            evens = divi(N // 2)
            ans[N] = [2 * odd - 1 for odd in odds] + [2 * even for even in evens]
        return ans[N]
    return divi(N)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;分治法的迭代版本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def beautifulArray(self, N: int) -&amp;gt; List[int]:
    ans = [1]
    while len(ans) &amp;lt; N:
        ans = [2 * odd - 1 for odd in ans] + [2 * even for even in ans]
    return [i for i in ans if i &amp;lt;= N]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(nlogn)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>数组中的第K个最大元素</title>
      <link>https://ripple-zjw.github.io/2019/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</link>
      <pubDate>Sat, 21 Sep 2019 15:30:13 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</guid>
      <description>

&lt;h1 id=&#34;题目-数组中的第k个最大元素&#34;&gt;题目：数组中的第K个最大元素&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;在未排序的数组中找到第k个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;说明&#34;&gt;说明:&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第215题&#34;&gt;来源：力扣（LeetCode）第215题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/kth-largest-element-in-an-array&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/kth-largest-element-in-an-array&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;有两种做法，一种是使用快排思想，选中一个数，对其进行&lt;code&gt;partition&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;第二种做法是使用堆，维护一个大顶堆，要拿到第k大元素就删除堆顶k次&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;快速排序改进：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def findKthLargest(self, nums: List[int], k: int) -&amp;gt; int:
    self.k = k
    ans =  self.quickSort(nums, 0, len(nums) - 1)
    return ans if ans else nums[k-1]
        
def portition(self, arr, start, end):
    pivot = arr[end]
    i = start - 1
    for j in range(start, end):
        if pivot &amp;lt; arr[j]:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i+1], arr[end] = arr[end], arr[i+1]
    return i + 1
    
def quickSort(self, arr, start, end):
    if start &amp;lt; end:
        pivot = self.portition(arr, start, end)
        if pivot + 1 == self.k:  # 唯一与快排的区别就是当pivot已经是第k大元素时就直接返回。
            return arr[pivot]
        self.quickSort(arr, start, pivot - 1)
        self.quickSort(arr, pivot + 1, end)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用堆：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def findKthLargest(self, nums: List[int], k: int) -&amp;gt; int:
    self.length = len(nums)
    for i in range(self.length // 2 - 1, -1, -1):  # 把数组构建成堆
        self.maxheapify(nums, i)
    ans = nums[0]
    for i in range(k):  # 拿到第k大元素
        ans = nums[0]
        nums[0] = nums[self.length - 1]
        self.length -= 1
        self.maxheapify(nums, 0)
    return ans

def maxheapify(self, heap, i):  # 堆的关键方法，作用是维护堆，任何涉及到堆的操作基本都需要。
    left = 2 * (i + 1) - 1
    right = 2 * (i + 1)
    largest = i
    if left &amp;lt; self.length and heap[largest] &amp;lt; heap[left]:
        largest = left
    if right &amp;lt; self.length and heap[largest] &amp;lt; heap[right]:
        largest = right
    if largest != i:
        heap[largest], heap[i] = heap[i], heap[largest]
        self.maxheapify(heap, largest)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;快速排序：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(nlogn)这是最坏情况下，最好情况下为O(n)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1) 快速排序本来就是原地排序，不需要额外的空间。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;使用堆：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(nlogn) n为二分之一的数组长度，&lt;code&gt;maxheapify&lt;/code&gt;的时间复杂度为&lt;code&gt;logn&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1) 构建堆以及拿出堆顶都只需要常数空间。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>为运算表达式设计优先级</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7/</link>
      <pubDate>Tue, 10 Sep 2019 22:59:46 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7/</guid>
      <description>

&lt;h1 id=&#34;题目-为运算表达式设计优先级&#34;&gt;题目：为运算表达式设计优先级&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含&lt;code&gt;+&lt;/code&gt;,&lt;code&gt;-&lt;/code&gt;以及&lt;code&gt;*&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;2-1-1&amp;quot;
输出: [0, 2]
解释: 
((2-1)-1) = 0 
(2-(1-1)) = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;2*3-4*5&amp;quot;
输出: [-34, -14, -10, -10, 10]
解释: 
(2*(3-(4*5))) = -34 
((2*3)-(4*5)) = -14 
((2*(3-4))*5) = -10 
(2*((3-4)*5)) = -10 
(((2*3)-4)*5) = 10
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第241题&#34;&gt;来源：力扣（LeetCode）第241题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/different-ways-to-add-parentheses&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/different-ways-to-add-parentheses&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;## 分析：
 - 动态规划+分治算法。
 - 当只有一个运算符时，只有一种情况，当有两个运算符时有两种情况，以此类推。
 - 当有三个运算符时，假设第一个运算符优先级最高，然后剩下三个数有两种情况，将两种情况与其相加，得到答案。接着判断第二个运算符优先级最低时，依次类推。&lt;/p&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from functools import lru_cache  # lru缓存淘汰算法。
class Solution:
    @lru_cache(None)
    def diffWaysToCompute(self, input: str) -&amp;gt; List[int]:
        if input.isdigit():  # 基线条件
            return [int(input)]
        opt = {&#39;-&#39;, &#39;+&#39;, &#39;*&#39;}  # 运算符集合
        ans = []  # 储存答案
        for i, char in enumerate(input):  # 判断每个运算符优先级最低的时候。
            if char in opt:  # 如果是运算符才执行
                left = self.diffWaysToCompute(input[:i])  # 拿到运算符的左边，递归
                right = self.diffWaysToCompute(input[i+1:])  # 拿到运算符的右边，递归
                ans.extend([self.operator(l, r, char) for l in left for r in right])  # 将运算符的左右两边的值按照运算符做运算。left和right拿到的是列表，就像前面说的，如果左边有不止一个运算符时答案也不止一个，右边同理。
        return ans
    def operator(self, l, r, char):  # 根据运算符做运算符操作，char就是运算符。
        if char == &#39;-&#39;:
            return l - r
        elif char == &#39;+&#39;:
            return l + r
        else:
            return l * r
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n!)n为运算符的个数，个人认为&lt;/li&gt;
&lt;li&gt;空间复杂度：实在算不出来了。。。。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>搜索插入位置</title>
      <link>https://ripple-zjw.github.io/2019/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Tue, 10 Sep 2019 22:48:08 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</guid>
      <description>

&lt;h1 id=&#34;搜索插入位置&#34;&gt;搜索插入位置&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;/li&gt;
&lt;li&gt;你可以假设数组中无重复元素。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,3,5,6], 5
输出: 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,3,5,6], 2
输出: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-3&#34;&gt;示例 3:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,3,5,6], 7
输出: 4
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-4&#34;&gt;示例 4:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,3,5,6], 0
输出: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第35题&#34;&gt;来源：力扣（LeetCode）第35题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/search-insert-position&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/search-insert-position&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;两种二分查找模版&#34;&gt;两种二分查找模版：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;target = 要查找的值
left = 0, right = arr.length
while left &amp;lt; right:
    mid = (left + right) &amp;gt;&amp;gt; 1
    // 为了防止数组溢出，也可以写成left + (right - left) &amp;gt;&amp;gt; 1
    if arr[mid] == target:
        return arr[mid]
    elif arr[mid] &amp;gt; target:
        right = mid
    else:
        left = mid + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;target = 要查找的值
left = 0, right = arr.length - 1
while left &amp;lt;= right:
    mid = (left + right) &amp;gt;&amp;gt; 1
    // 为了防止数组溢出，也可以写成left + (right - left) &amp;gt;&amp;gt; 1
    if arr[mid] == target:
        return arr[mid]
    elif arr[mid] &amp;gt; target:
        right = mid - 1
    else:
        left = mid + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def searchInsert(self, nums: List[int], target: int) -&amp;gt; int:
        left = 0
        right = len(nums)
        while left &amp;lt; right:
            mid = (left + right) &amp;gt;&amp;gt; 1
            if nums[mid] == target:
                return mid
            elif nums[mid] &amp;gt; target:
                right = mid
            else:
                left = mid + 1
        return left  # 基本和模版一样，就是如果没有找到的话，就返回left，可以自己推测出来
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left &amp;lt;= right) {
            int mid = left + ((right - left) &amp;gt;&amp;gt; 1);
            if (nums[mid] == target) return mid;
            else if (nums[mid] &amp;lt; target) left = mid + 1;
            else right = mid - 1;
        }
        return left;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(logn) 二分查找&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>