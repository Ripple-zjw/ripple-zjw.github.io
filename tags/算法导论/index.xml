<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法导论 on LeaveIt</title>
    <link>https://ripple-zjw.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/</link>
    <description>Recent content in 算法导论 on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 23 Aug 2019 12:57:06 +0800</lastBuildDate>
    
	<atom:link href="https://ripple-zjw.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>求最大子数组</title>
      <link>https://ripple-zjw.github.io/2019/%E6%B1%82%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</link>
      <pubDate>Fri, 23 Aug 2019 12:57:06 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%B1%82%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</guid>
      <description>题目：求最大子数组  在一个数组中找到和最大的子数组。 数组中有正有负，但都是integer类型。  题目来源：算法导论第38页 4.1 最大子数组问题 分析： 根据书中的问题，采用分治思想来解题。具体可参考算法导论。
思路：  将整个数组一分为二，每次分完之后做四件事件：  查看是否是最小数组即长度是1，因为数组长度是1那么总和就是这一个数的值。 如果不是1，那就分别递归进左边的数组和右边的数组继续分，直到分到1再返回。 每次递归除了左边的最大子数组和右边的最大子数组外，还有交叉在中间的最大子数组。所以要把中间的最大子数组也算出来。 算出三者的各自的和将和最大的那个子数组并返回，同时返回它的两端下标。  每次递归都会返回左边，右边，中间的最大的那个子数组。 最后一次递归返回最大的子数组，答案就出来了。  代码： class FindMaxNum: def _find_crossing(self, A, low, mid, high): # 寻找穿过中间值的最大子数组 leftSum = float(&#39;-inf&#39;) ans = 0 maxLeft = mid maxRight = mid + 1 for i in range(mid, low - 1, -1): # 找到左边的最大子数组 ans += A[i] if ans &amp;gt; leftSum: leftSum = ans maxLeft = i rightSum = float(&#39;-inf&#39;) ans = 0 for j in range(mid + 1, high + 1): # 找到右边的最大子数组 ans += A[j] if ans &amp;gt; rightSum: rightSum = ans maxRight = j return maxLeft, maxRight, leftSum + rightSum # 返回最大的子数组以及它的两端下标 def find_max_num(self, A, low, high): if low == high: # 如果分到了1，那么就返回 return low, high, A[low] else: mid = (low + high) // 2 # 将数组一分为二 left_low, left_high, left_sum = self.</description>
    </item>
    
  </channel>
</rss>