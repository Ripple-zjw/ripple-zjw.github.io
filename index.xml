<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeaveIt on LeaveIt</title>
    <link>https://ripple-zjw.github.io/</link>
    <description>Recent content in LeaveIt on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 30 Aug 2019 19:27:49 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>数组的相对排序</title>
      <link>https://ripple-zjw.github.io/2019/%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Fri, 30 Aug 2019 19:27:49 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/</guid>
      <description>

&lt;h1 id=&#34;题目-数组的相对排序&#34;&gt;题目：数组的相对排序&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给你两个数组，&lt;code&gt;arr1&lt;/code&gt; 和&lt;code&gt;arr2&lt;/code&gt;，

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;arr2&lt;/code&gt;中的元素各不相同&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arr2&lt;/code&gt; 中的每个元素都出现在&lt;code&gt;arr1&lt;/code&gt;中&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对&lt;code&gt;arr1&lt;/code&gt;中的元素进行排序，使arr1中项的相对顺序和&lt;code&gt;arr2&lt;/code&gt;中的相对顺序相同。&lt;/li&gt;
&lt;li&gt;未在&lt;code&gt;arr2&lt;/code&gt;中出现过的元素需要按照升序放在&lt;code&gt;arr1&lt;/code&gt;的末尾。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
输出：[2,2,2,1,4,3,3,9,6,7,19]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;提示&#34;&gt;提示：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;arr1.length, arr2.length&lt;/code&gt; &amp;lt;= 1000&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= &lt;code&gt;arr1[i], arr2[i]&lt;/code&gt; &amp;lt;= 1000&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arr2&lt;/code&gt;中的元素&lt;code&gt;arr2[i]&lt;/code&gt;各不相同&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arr2&lt;/code&gt; 中的每个元素&lt;code&gt;arr2[i]&lt;/code&gt;都出现在&lt;code&gt;arr1&lt;/code&gt;中&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第1122题&#34;&gt;来源：力扣（LeetCode）第1122题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/relative-sort-array&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/relative-sort-array&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;最近一直在做数组的题目，这种题一眼就想到了计数排序，唯一的不同就是在排序的时候要按arr2的顺序排。&lt;/li&gt;
&lt;li&gt;我的代码是遍历了两边，第一遍是遍历arr2，第二遍遍历整个排序，如果你有更好的计数排序方法，欢迎你告诉我。&lt;/li&gt;
&lt;li&gt;不知道你们有没有遇到过计数排序，我尽可能的把注释写的详细一点，好给没接触过的人参考一下。（反正多遇到几次就写的很熟了）&lt;/li&gt;
&lt;li&gt;其实就是用到了hash表。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -&amp;gt; List[int]:
        arr = [0 for _ in range(1001)]  # 由于题目说arr1的范围在0-1000，所以生成一个1001大小的数组用来存放每个数出现的次数。
        ans = []  # 储存答案的数组。
        for i in range(len(arr1)):  # 遍历arr1，把整个arr1的数的出现次数储存在arr上，arr的下标对应arr1的值，arr的值对应arr1中值出现的次数。
            arr[arr1[i]] += 1  # 如果遇到了这个数，就把和它值一样的下标位置上+1，表示这个数在这个下标i上出现了1次。
        for i in range(len(arr2)):  # 遍历arr2，现在开始要输出答案了。
            while arr[arr2[i]] &amp;gt; 0:  # 如果arr2的值在arr所对应的下标位置出现次数大于0，那么就说明arr中的这个位置存在值。
                ans.append(arr2[i])  # 如果存在值，那就把它加到ans中，因为要按arr2的顺序排序。
                arr[arr2[i]] -= 1  # 加进去了次数 -1 ，不然就死循环了。
        for i in range(len(arr)):  # 如果arr1的值不在arr2中，那么不能就这么结束了，因为题目说了如果不在，剩下的值按照升序排序。
            while arr[i] &amp;gt; 0:  # 同样也是找到大于0的下标，然后一直加到ans中，直到次数为0。
                ans.append(i)
                arr[i] -= 1
        return ans  # 返回最终答案。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n+m) n 为arr2的长度，m为arr1的长度。arr的长度固定是1001，所以就算arr中只有1个有次数,也要遍历1001遍。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n) n 为arr1的长度。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>杨辉三角</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</link>
      <pubDate>Fri, 30 Aug 2019 19:22:10 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</guid>
      <description>

&lt;h1 id=&#34;题目-杨辉三角&#34;&gt;题目：杨辉三角&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。&lt;/li&gt;
&lt;li&gt;在杨辉三角中，每个数是它左上方和右上方的数的和。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://ripple-zjw.github.io/images/杨辉三角/PascalTriangleAnimated2.gif&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第118题&#34;&gt;来源：力扣（LeetCode）第118题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/pascals-triangle&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/pascals-triangle&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;这题可以使用动态规划，是一道非常简单的题目。我们可以把所要求的值看成是前一行的两个值的相加，而且这两个值的位置是有规律的。&lt;/p&gt;

&lt;h2 id=&#34;思路&#34;&gt;思路：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;两个循环，第一遍遍历所有的层。&lt;/li&gt;
&lt;li&gt;第二遍遍历每一层中的值。&lt;/li&gt;
&lt;li&gt;每一层中的值只有第一个和最后一个是1，其他的值都是前一行的前一个位置和现在的位置的和。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def generate(self, numRows: int) -&amp;gt; List[List[int]]:
        ans = []
        for i in range(numRows):
            numRow = [1 for _ in range(i + 1)]
            for j in range(1, i):
                numRow[j] = ans[i-1][j-1] + ans[i-1][j]
            ans.append(numRow)
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n^2^) n 为numRows&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n^2^)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>按奇偶排序数组</title>
      <link>https://ripple-zjw.github.io/2019/%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%842/</link>
      <pubDate>Fri, 30 Aug 2019 19:20:28 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%842/</guid>
      <description>

&lt;h1 id=&#34;题目-按奇偶排序数组-ii&#34;&gt;题目：按奇偶排序数组 II&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个非负整数数组&lt;code&gt;A&lt;/code&gt;，&lt;code&gt;A&lt;/code&gt;中一半整数是奇数，一半整数是偶数。&lt;/li&gt;
&lt;li&gt;对数组进行排序，以便当&lt;code&gt;A[i]&lt;/code&gt; 为奇数时，&lt;code&gt;i&lt;/code&gt;也是奇数；当&lt;code&gt;A[i]&lt;/code&gt;为偶数时，&lt;code&gt;i&lt;/code&gt; 也是偶数。&lt;/li&gt;
&lt;li&gt;你可以返回任何满足上述条件的数组作为答案。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：[4,2,5,7]
输出：[4,5,2,7]
解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;提示&#34;&gt;提示：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;2 &amp;lt;= A.length &amp;lt;= 20000&lt;/li&gt;
&lt;li&gt;A.length % 2 == 0&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= A[i] &amp;lt;= 1000&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第922题&#34;&gt;来源：力扣（LeetCode）第922题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/sort-array-by-parity-ii&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/sort-array-by-parity-ii&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;一遍遍历数组即可求解。但是为了追求极致，采用双指针法可以实现原地交换。&lt;/p&gt;

&lt;h2 id=&#34;思路&#34;&gt;思路：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;使用两个指针&lt;code&gt;i&lt;/code&gt;,&lt;code&gt;j&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;一个遍历偶数下标，一个遍历奇数下标。&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;i&lt;/code&gt;在偶数的下标中找到了一个奇数，那么就从&lt;code&gt;j&lt;/code&gt;奇数下标中找一个偶数。&lt;/li&gt;
&lt;li&gt;将两者交换位置。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;双指针法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def sortArrayByParityII(self, A: List[int]) -&amp;gt; List[int]:
    j = 1
    for i in range(0, len(A), 2):
        if A[i] % 2 == 1:
            while A[j] % 2 == 1:
                j += 2
            A[i], A[j] = A[j], A[i]
    return A
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;正常一次遍历：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def sortArrayByParityII(self, A: List[int]) -&amp;gt; List[int]:
    ans = [0 for _ in range(len(A))]
    single = 1
    double = 0
    for i in range(len(A)):
        if A[i] % 2 == 0:
            ans[double] = A[i]
            double += 2
        else:
            ans[single] = A[i]
            single += 2
    return ans
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;双指针法：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n 为数组长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;正常遍历：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n 为数组长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;双指针法可以降低空间的使用，用过原地交换实现不需要额外的空间去储存答案。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>求众数</title>
      <link>https://ripple-zjw.github.io/2019/%E6%B1%82%E4%BC%97%E6%95%B0/</link>
      <pubDate>Fri, 30 Aug 2019 19:17:44 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%B1%82%E4%BC%97%E6%95%B0/</guid>
      <description>

&lt;h1 id=&#34;题目-求众数&#34;&gt;题目：求众数&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于&lt;code&gt;⌊ n/2 ⌋&lt;/code&gt;的元素。&lt;/li&gt;
&lt;li&gt;你可以假设数组是非空的，并且给定的数组总是存在众数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [3,2,3]
输出: 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [2,2,1,1,1,2,2]
输出: 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第169题&#34;&gt;来源：力扣（LeetCode）第169题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/majority-element&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/majority-element&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;这道题很经典，方法有很多，暴力法，分治法，哈希法，排序法，随机法，投票法。我自己用了哈希法做出来的，但是官方的投票法真的是太秀了，这里着重讲投票法。&lt;/p&gt;

&lt;h2 id=&#34;思路&#34;&gt;思路：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;先让第一个人作为&lt;code&gt;candidate&lt;/code&gt;，&lt;/li&gt;
&lt;li&gt;然后和它一样的元素给他加票，不一样的元素给它减票，&lt;/li&gt;
&lt;li&gt;当票数为0时，就换掉&lt;code&gt;candidate&lt;/code&gt;，让新的元素担任。&lt;/li&gt;
&lt;li&gt;最后成为&lt;code&gt;candidate&lt;/code&gt;的元素就是众数。&lt;/li&gt;
&lt;li&gt;当然，前提是题目给出地假设一定存在众数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;投票法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def majorityElement(self, nums: List[int]) -&amp;gt; int:
    candidate = 0
    count = 0
    for num in nums:
        if count == 0:
            candidate = num
        count += 1 if num == candidate else -1
    return candidate
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;哈希法：(自己做的)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def majorityElement(self, nums: List[int]) -&amp;gt; int:
    cnt = len(nums) / 2
    dic = {}
    for num in nums:
        if num in dic:
            dic[num] += 1
        else:
            dic[num] = 1
        if dic[num] &amp;gt;= cnt:
            return num
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;投票法：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>有序数组的平方</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</link>
      <pubDate>Fri, 23 Aug 2019 13:01:17 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</guid>
      <description>

&lt;h1 id=&#34;题目-有序数组的平方&#34;&gt;题目：有序数组的平方&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：[-4,-1,0,3,10]
输出：[0,1,9,16,100]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：[-7,-3,2,3,11]
输出：[4,9,9,49,121]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;提示&#34;&gt;提示：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= &lt;code&gt;A.length&lt;/code&gt; &amp;lt;= 10000&lt;/li&gt;
&lt;li&gt;10000 &amp;lt;= &lt;code&gt;A[i]&lt;/code&gt; &amp;lt;= 10000&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A&lt;/code&gt;已按非递减顺序排序。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第977题&#34;&gt;来源：力扣（LeetCode）第977题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/squares-of-a-sorted-array&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/squares-of-a-sorted-array&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;这道题的方法有两种，一种最简单，先计算，再排序。第二种用双指针做到一遍遍历解答。&lt;/p&gt;

&lt;h2 id=&#34;思路&#34;&gt;思路：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;由于数组是按照递增的顺序增长的，因此所有的正数都是递增的，所有的负数加上绝对值都是递减的。&lt;/li&gt;
&lt;li&gt;我们用两个指针&lt;code&gt;i&lt;/code&gt;和&lt;code&gt;j&lt;/code&gt;，&lt;code&gt;i&lt;/code&gt;从前往后遍历，&lt;code&gt;j&lt;/code&gt;从后往前遍历。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt;遇到正数就停下来，&lt;code&gt;j&lt;/code&gt;遇到负数就停下来，然后比较他们两谁小，小的那个放到ans答案中。&lt;/li&gt;
&lt;li&gt;然后就把放入答案中的那个指针往后前移。&lt;/li&gt;
&lt;li&gt;最后退出循环，但是可能有一个指针并没有移到终点，因此要在循环结束后去判断两个指针的情况，把指针后面的值都加到ans中去。&lt;/li&gt;
&lt;li&gt;最后得到答案。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def sortedSquares(self, A: List[int]) -&amp;gt; List[int]:
        i = 0
        j = len(A) - 1
        ans = []
        while i &amp;lt; len(A) and j &amp;gt;= 0:  # 主循环
            while i &amp;lt; len(A) and A[i] &amp;lt; 0:  # 遍历到第一个正数
                i += 1
            while j &amp;gt;= 0 and A[j] &amp;gt;= 0:  # 遍历到第一个负数
                j -= 1
            if i &amp;lt; len(A) and j &amp;gt;= 0:  # 谁小就把谁加进来
                if A[i] ** 2 &amp;gt; A[j] ** 2:
                    ans.append(A[j] ** 2)
                    j -= 1
                else:
                    ans.append(A[i] ** 2)
                    i += 1
        while i &amp;lt; len(A):  # 如果i没有到遍历完吧i加进去
            ans.append(A[i] ** 2)
            i += 1
        while j &amp;gt;=0:  # j没有到头把j加进去
            ans.append(A[j] ** 2)
            j -= 1
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;简单暴力法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def sortedSquares(self, A: List[int]) -&amp;gt; List[int]:
    return sorted(x * x for x in A)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;双指针法：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n 为数组长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;暴力法：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(nlogn) n为数组长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;双指针法在解数组这一块的问题时是一个不错的方法。&lt;/li&gt;
&lt;li&gt;一段递增的数，如果有负数那么负数的绝对值是递减的。反向遍历就能使其递增。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>高度检查器</title>
      <link>https://ripple-zjw.github.io/2019/%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/</link>
      <pubDate>Fri, 23 Aug 2019 12:59:06 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/</guid>
      <description>

&lt;h1 id=&#34;题目-高度检查器&#34;&gt;题目：高度检查器&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。&lt;/li&gt;
&lt;li&gt;请你返回至少有多少个学生没有站在正确位置数量。该人数指的是：能让所有学生以 非递减 高度排列的必要移动人数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：[1,1,4,2,1,3]
输出：3
解释：
高度为 4、3 和最后一个 1 的学生，没有站在正确的位置。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;提示&#34;&gt;提示：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= heights.length &amp;lt;= 100&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= heights[i] &amp;lt;= 100&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第1051题&#34;&gt;来源：力扣（LeetCode）第1051题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/height-checker&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/height-checker&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;有两种方法。都是先排序，然后比较两者之间的差异。不同处，第一种是比较排序，第二种是计数排序。计数排序的时间复杂度相对较低，本文讲解计数排序。&lt;/p&gt;

&lt;h2 id=&#34;思路&#34;&gt;思路：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;因为&lt;code&gt;heights[i]&lt;/code&gt;不会超过100，所以采用hash的思想，将所给数组每个值出现的次数作为值，将所给数组的值作为下标，这样相同值出现的次数就会被归在一起，而且值小的元素会在前面，因为下标就是值。&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;1&lt;/code&gt;出现了3次，那么这3次一定是在最前面的，所以我们顺序遍历原数组，如果前3次不是1，就说明这个数要移动，以此类推。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def heightChecker(self, heights: List[int]) -&amp;gt; int:
        ans = 0
        arr = [0] * 101  # heights[i]最多不超过100个
        for height in heights:  # 将heights散列到arr中
            arr[height] += 1
        j = 0
        for i in range(1, len(arr)):  # 根据arr中的计数排序比较原数组
            while arr[i] &amp;gt; 0:
                if heights[j] != i:  # 如果值不同，那么ans就+1
                    ans += 1
                j += 1
                arr[i] -= 1  # 比较完一次计数就-1，减到0说明这个数没有了。
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;然后再放上比较排序的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def heightChecker(self, heights: List[int]) -&amp;gt; int:
    sorted_list = sorted(heights)
    ans = 0
    for i in range(len(heights)):
        if heights[i] != sorted_list[i]:
            ans += 1
    return ans
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;计数排序：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) &lt;code&gt;n = n + n&lt;/code&gt; n为数组&lt;code&gt;heights&lt;/code&gt;的长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1) 1 为arr的长度101&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;比较排序：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(nlogn) n 为&lt;code&gt;heights&lt;/code&gt;的长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;计数排序的效率比快速排序还要快，但是只适用于特殊场景。&lt;/li&gt;
&lt;li&gt;例如在该题中，如果&lt;code&gt;heights[i]&lt;/code&gt;的大小非常大，那么需要的内存空间会非常多。如果大小不确定，那么就无法知道该声明多长的数组，一旦内存溢出，程序就崩溃了。又比如次数非常少，基本没有重复的数，那么排序的时间也不会快到哪里去。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>求最大子数组</title>
      <link>https://ripple-zjw.github.io/2019/%E6%B1%82%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</link>
      <pubDate>Fri, 23 Aug 2019 12:57:06 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%B1%82%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</guid>
      <description>

&lt;h1 id=&#34;题目-求最大子数组&#34;&gt;题目：求最大子数组&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;在一个数组中找到和最大的子数组。&lt;/li&gt;
&lt;li&gt;数组中有正有负，但都是&lt;code&gt;integer&lt;/code&gt;类型。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;题目来源-算法导论第38页-4-1-最大子数组问题&#34;&gt;题目来源：算法导论第38页 4.1 最大子数组问题&lt;/h4&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;根据书中的问题，采用分治思想来解题。具体可参考算法导论。&lt;/p&gt;

&lt;h2 id=&#34;思路&#34;&gt;思路：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;将整个数组一分为二，每次分完之后做四件事件：

&lt;ul&gt;
&lt;li&gt;查看是否是最小数组即长度是1，因为数组长度是1那么总和就是这一个数的值。&lt;/li&gt;
&lt;li&gt;如果不是1，那就分别递归进左边的数组和右边的数组继续分，直到分到1再返回。&lt;/li&gt;
&lt;li&gt;每次递归除了左边的最大子数组和右边的最大子数组外，还有交叉在中间的最大子数组。所以要把中间的最大子数组也算出来。&lt;/li&gt;
&lt;li&gt;算出三者的各自的和将和最大的那个子数组并返回，同时返回它的两端下标。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;每次递归都会返回左边，右边，中间的最大的那个子数组。&lt;/li&gt;
&lt;li&gt;最后一次递归返回最大的子数组，答案就出来了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class FindMaxNum:
	def _find_crossing(self, A, low, mid, high):  # 寻找穿过中间值的最大子数组
		leftSum = float(&#39;-inf&#39;)
		ans = 0
		maxLeft = mid
		maxRight = mid + 1
		for i in range(mid, low - 1, -1):  # 找到左边的最大子数组
			ans += A[i]
			if ans &amp;gt; leftSum:
				leftSum = ans
				maxLeft = i
		rightSum = float(&#39;-inf&#39;)
		ans = 0
		for j in range(mid + 1, high + 1):  # 找到右边的最大子数组
			ans += A[j]
			if ans &amp;gt; rightSum:
				rightSum = ans
				maxRight = j
		return maxLeft, maxRight, leftSum + rightSum  # 返回最大的子数组以及它的两端下标


	def find_max_num(self, A, low, high):
		if low == high:  # 如果分到了1，那么就返回
			return low, high, A[low]
		else:
			mid = (low + high) // 2  # 将数组一分为二
			left_low, left_high, left_sum = self.find_max_num(A, low, mid)  # 递归进左子数组
			right_low, right_high, right_sum = self.find_max_num(A, mid + 1, high)  # 递归进右子数组
			cro_low, cro_high, cro_sum = self._find_crossing(A, low, mid, high)  # 寻找中间子数组
			if left_sum &amp;gt;= right_sum and left_sum &amp;gt;= cro_sum:  # 左边最大返回左边
				return left_low, left_high, left_sum
			elif right_sum &amp;gt;= left_sum and right_sum &amp;gt;= cro_sum:  # 右边最大返回右边
				return right_low, right_high, right_sum
			else:  # 否则中间最大返回中间
				return cro_low, cro_high, cro_sum

if __name__ == &#39;__main__&#39;:  # 测试通过
	test = [13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7]
	fn = FindMaxNum()
	i, j, res = fn.find_max_num(test, 0, len(test) - 1)
	print(test[i:j+1])
	print(i,j)
	print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(nlogn) n 为数组的长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1) 完全没有开辟新的数组空间，仅仅是在原数组上分治。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;分治算法可以大幅度提高运行效率，相比于暴力法，速度提升很多。&lt;/li&gt;
&lt;li&gt;算法导论上的这个分治法应该是我看到的最好的分治法了，很多地方的算法解这道题时总是会开辟新的数组，这就导致了内存空间的浪费，如果数据量多的话，很容易空间不够。&lt;/li&gt;
&lt;li&gt;分治的主要思想就是找到递归条件和线性条件。然后用分而治之的方法从线性条件不停地向前合并，最终找到答案。主要的原理和递归很像。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>接雨水</title>
      <link>https://ripple-zjw.github.io/2019/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</link>
      <pubDate>Fri, 23 Aug 2019 12:55:03 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</guid>
      <description>

&lt;h1 id=&#34;题目-接雨水&#34;&gt;题目：接雨水&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定&lt;code&gt;n&lt;/code&gt;个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://ripple-zjw.github.io/images/接雨水/rainwatertrap.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;上面是由数组 &lt;code&gt;[0,1,0,2,1,0,1,3,2,1,2,1]&lt;/code&gt; 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。感谢 &lt;code&gt;Marcos&lt;/code&gt; 贡献此图。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第42题&#34;&gt;来源：力扣（LeetCode）第42题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/trapping-rain-water&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/trapping-rain-water&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;方法太多了，一道极难题，从暴力法，到动态规划，再到单调栈，再到双指针。方法非常多，也很难理解，暴力法最好理解，dp和双指针稍难，我这里讲单调栈的方法。&lt;/p&gt;

&lt;h2 id=&#34;思路&#34;&gt;思路：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;维护一个单调递减栈。&lt;/li&gt;
&lt;li&gt;当有值比栈顶元素大的时候做这么几件事情：

&lt;ul&gt;
&lt;li&gt;先出栈一个元素并保存到top中。&lt;/li&gt;
&lt;li&gt;然后判断stack是否是空，如果是空的话，说明出栈的左边没有东西，所以无法装雨水。(一定要两边都要有东西并且两边的墙比出栈的墙要长，这样才能装雨水)&lt;/li&gt;
&lt;li&gt;算出当前元素与栈顶元素中间的距离&lt;code&gt;dis&lt;/code&gt;(注意现在是出栈之后的栈顶元素)&lt;/li&gt;
&lt;li&gt;算出当前元素与栈顶元素中哪个值最小，并将小的那个值与出栈的那个元素相减，得到&lt;code&gt;floor_cnt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;为什么要叫&lt;code&gt;floor_cnt&lt;/code&gt;呢，因为将&lt;code&gt;floor_cnt&lt;/code&gt;与&lt;code&gt;dis&lt;/code&gt;(也就是两栋大墙之间的距离)相乘，你就能得到在这两栋墙之间一层的雨水数量。&lt;/li&gt;
&lt;li&gt;将它们加到ans答案中。例如：如果两栋墙最小的那栋是&lt;code&gt;3&lt;/code&gt;，那么就会有3层，每一层的雨水数量可能是不一样的，所以要算3遍。&lt;/li&gt;
&lt;li&gt;最后返回ans得到答案。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果值比栈顶元素小的话就入栈就行了，这样就能维护单调递减栈。(注意栈中存的是数组下标，为了算起来方便。)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;talk-is-cheap-show-me-the-code&#34;&gt;Talk is cheap,show me the code.&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution(object):
    def trap(self, height):
        stack = []
        ans = 0
        cur = 0
        while cur &amp;lt; len(height):
            while stack and height[stack[-1]] &amp;lt; height[cur]:
                top = stack.pop()
                if not stack:
                    break
                dis = cur - stack[-1] - 1
                floor_cnt = min(height[stack[-1]], height[cur]) - height[top]
                ans += dis * floor_cnt
            stack.append(cur)
            cur += 1
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;顺便写上双指针法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def trap(self, height: List[int]) -&amp;gt; int:
        lMax = 0
        rMax = 0
        res = 0
        i = 0
        j = len(height) - 1
        while i &amp;lt; j:
            if height[i] &amp;lt; height[j]:
                if height[i] &amp;gt;= lMax:
                    lMax = height[i]
                else:
                    res += (lMax - height[i])
                i += 1
            else:
                if height[j] &amp;gt;= rMax:
                    rMax = height[j]
                else:
                    res += (rMax - height[j])
                j -= 1
        return res
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n 为height长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n) n为stack长度。最坏情况下完全是单调递减栈，n变为height的长度。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;这是一道hard题。难度挺大的，其实我自己第一次想的时侯方法已经很接近了，但就是那个突破口没有想到，导致做不出来。&lt;/li&gt;
&lt;li&gt;如果我能想到一层一层算的话这道题就能解决了。&lt;/li&gt;
&lt;li&gt;而且这道题非常经典，有非常多的解法，建议大家收藏。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>任务调度器</title>
      <link>https://ripple-zjw.github.io/2019/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/</link>
      <pubDate>Fri, 23 Aug 2019 12:52:54 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/</guid>
      <description>

&lt;h1 id=&#34;题目-任务调度器&#34;&gt;题目：任务调度器&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。&lt;/li&gt;
&lt;li&gt;任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。&lt;/li&gt;
&lt;li&gt;CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。&lt;/li&gt;
&lt;li&gt;然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。&lt;/li&gt;
&lt;li&gt;你需要计算完成所有任务所需要的最短时间。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: tasks = [&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;,&amp;quot;B&amp;quot;,&amp;quot;B&amp;quot;,&amp;quot;B&amp;quot;], n = 2
输出: 8
执行顺序: A -&amp;gt; B -&amp;gt; (待命) -&amp;gt; A -&amp;gt; B -&amp;gt; (待命) -&amp;gt; A -&amp;gt; B.
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;注&#34;&gt;注：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;任务的总个数为 [1, 10000]。&lt;/li&gt;
&lt;li&gt;n 的取值范围为 [0, 100]。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第621题&#34;&gt;来源：力扣（LeetCode）第621题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/task-scheduler&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/task-scheduler&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;写在队列的标签里，本质上用的却是贪心算法，不知道为什么，同时还用到了一点hashmap的知识。&lt;/p&gt;

&lt;h2 id=&#34;思路&#34;&gt;思路：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;要知道最短时间首先要找到出现次数最多的那个值，如果出现次数一样多，选哪个都无所谓。&lt;/li&gt;
&lt;li&gt;然后看&lt;code&gt;A-Z&lt;/code&gt;中总共有几个数字出现了，假设最多次数的值是&lt;code&gt;A&lt;/code&gt;，那么第一个&lt;code&gt;A&lt;/code&gt;到第二个&lt;code&gt;A&lt;/code&gt;之间总共还能再放&lt;code&gt;n&lt;/code&gt;个不一样的值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A -&amp;gt; (单位时间) -&amp;gt; (单位时间) -&amp;gt; A -&amp;gt; (单位时间) -&amp;gt; (单位时间) -&amp;gt; A&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果填不满那就为&lt;code&gt;等待时间&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果填满了，那就说明不需要&lt;code&gt;等待时间&lt;/code&gt;就能得到最短时间，所以最短时间就是数组的长度。&lt;/li&gt;
&lt;li&gt;如果没填满，那么我们可以计算&lt;code&gt;(出现的次数最多的元素 - 1) * (n + 1) + 出现次数一样多的元素的个数&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;我们依靠出现的次数最多的元素&lt;code&gt;A&lt;/code&gt;把整个答案划分为a份(a为&lt;code&gt;A&lt;/code&gt;的次数)，每一份就是&lt;code&gt;n+1&lt;/code&gt;，由于最后一份不一定是&lt;code&gt;n+1&lt;/code&gt;，所以是&lt;code&gt;(a-1)*(n+1)&lt;/code&gt;，最后在把不相等的最后一份加进去就得到了答案。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def leastInterval(self, tasks: List[str], n: int) -&amp;gt; int:
        count = [0] * 26
        for task in tasks:
            count[ord(task) - 65] += 1  # 这里是我自己写的简单hash函数，也可以用字典，我这里觉得简单就没用字典。
        maxNum = max(count)
        maxCount = 0
        for c in count:
            if c == maxNum:
                maxCount += 1
        return max((maxNum - 1) * (n + 1) + maxCount, len(tasks))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为tasks的长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;第一次写贪心算法题，标签写错了，本来有想到贪心算法的，可是标签是队列我就一直在想队列，想了半天没有思路。&lt;/li&gt;
&lt;li&gt;贪心算法得到的有可能是近似解，在使用贪心算法时要想清楚特殊的情况。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>二叉树的后序遍历</title>
      <link>https://ripple-zjw.github.io/2019/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Fri, 23 Aug 2019 12:49:52 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>

&lt;h1 id=&#34;题目-二叉树的后序遍历&#34;&gt;题目：二叉树的后序遍历&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个二叉树，返回它的 后序 遍历。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,null,2,3]  
   1
    \
     2
    /
   3 
输出: [3,2,1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;进阶:递归算法很简单，你可以通过迭代算法完成吗？&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第145题&#34;&gt;来源：力扣（LeetCode）第145题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/binary-tree-postorder-traversal&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/binary-tree-postorder-traversal&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;方法有很多，递归法最简单，迭代法使用栈辅助完成，还有莫里斯遍历。本文讲解官方写的题解迭代法。虽然我也写出了迭代法，但是官方的解法既简单又高效，非常厉害。使用了迭代法+逆向工作法。&lt;/p&gt;

&lt;h2 id=&#34;思路&#34;&gt;思路：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;后序遍历是左，右，中。可是中在最后，如果正常解后序遍历的话有的复杂。&lt;/li&gt;
&lt;li&gt;如果我们用中，右，左这样来遍历的话岂不是将后序遍历变成了前序遍历的翻版类型。&lt;/li&gt;
&lt;li&gt;这样的话答案只是与我们要求的答案相反，翻转一下列表就可以了。&lt;/li&gt;
&lt;li&gt;所以解法就是一个反向的先序遍历方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;官方的迭代法+逆向工作法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
def postorderTraversal(self, root: TreeNode) -&amp;gt; List[int]:
    if root is None:
        return []
    stack = [root]
    res = []
    while stack:
        root = stack.pop()
        res.append(root.val)
        if root.left is not None:  # 先加左再加右，出栈的时候就是先加右，再加左。
            stack.append(root.left)
        if root.right is not None:
            stack.append(root.right)
    return res[::-1]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我自己写的迭代法，内容有点复杂，不是很好理解。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
def postorderTraversal(self, root):
    stack = []
    helper = []
    res = []
    while stack or root:
        while root:
            stack.append(root)
            root = root.left
        helper.append(stack[-1])
        root = stack.pop().right
        if root is None:
            res.append(helper.pop().val)
            while stack and stack[-1].left in helper and helper:
                res.append(helper.pop().val)
            while not stack and helper:
                res.append(helper.pop().val)
    return res
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;虽然我的方法写的多了一点，但是速度和官方的一样，甚至有时比官方解法快。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;两种方法相同，都是迭代法：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为树的所有节点。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;再一次遇到逆向工作法，事实证明如果你遇到问题解不开来反向解一下，思路清晰，易于求解。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>132模式</title>
      <link>https://ripple-zjw.github.io/2019/132%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 19 Aug 2019 22:52:15 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/132%E6%A8%A1%E5%BC%8F/</guid>
      <description>

&lt;h1 id=&#34;题目-132模式&#34;&gt;题目：132模式&lt;/h1&gt;

&lt;p&gt;给定一个整数序列：&lt;code&gt;a1, a2, ..., an&lt;/code&gt;，一个132模式的子序列&lt;code&gt;ai, aj, ak&lt;/code&gt;被定义为：当 &lt;code&gt;i &amp;lt; j &amp;lt; k&lt;/code&gt;时，&lt;code&gt;ai &amp;lt; ak &amp;lt; aj&lt;/code&gt;。设计一个算法，当给定有 n 个数字的序列时，验证这个序列中是否含有132模式的子序列。
- 注意：n 的值小于15000。&lt;/p&gt;

&lt;h5 id=&#34;示例1&#34;&gt;示例1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1, 2, 3, 4]
输出: False
解释: 序列中不存在132模式的子序列。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [3, 1, 4, 2]
输出: True
解释: 序列中有 1 个132模式的子序列： [1, 4, 2].
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-3&#34;&gt;示例 3:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [-1, 3, 2, 0]
输出: True
解释: 序列中有 3 个132模式的的子序列: [-1, 3, 2], [-1, 3, 0] 和 [-1, 2, 0].
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第456题&#34;&gt;来源：力扣（LeetCode）第456题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/132-pattern&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/132-pattern&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;分析&#34;&gt;分析：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;还是单调栈，不过还需要用到另一个方法，逆向工作法。反向遍历列表就会发现不一样的做法。&lt;/li&gt;
&lt;li&gt;根据题意&lt;code&gt;1&lt;/code&gt;代表最小元素，&lt;code&gt;3&lt;/code&gt;代表最大元素，&lt;code&gt;2&lt;/code&gt;代表次大元素&lt;/li&gt;
&lt;li&gt;通过单调递减栈找到最大元素的最大次大元素，然后再确定最小元素要比最大次大元素小。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;反向遍历列表。&lt;/li&gt;
&lt;li&gt;严格维护一个单调递减栈。&lt;/li&gt;
&lt;li&gt;一旦遇到一个大的元素，将栈内元素出栈，维护单调递减。入栈后，将自己作为题目中的最大元素，即中间的元素。&lt;/li&gt;
&lt;li&gt;将最后一个出栈的元素作为次大元素，即右边的元素。&lt;/li&gt;
&lt;li&gt;这样的好处是我找到的次大元素一定是与当前最大元素的值最近的，而且还在最大元素的后面。&lt;/li&gt;
&lt;li&gt;这样我只要在前面找到一个比次大元素小的值，也就是最小值，那么就是True。&lt;/li&gt;
&lt;li&gt;如果找不到，那么可能有两种情况。

&lt;ul&gt;
&lt;li&gt;第一种在最大元素和次大元素之间，最小值比最大的次大元素还要大，不符合题意。但是要维护单调递减栈，所以入栈。&lt;/li&gt;
&lt;li&gt;第二种在最大元素之上，那么用刚才的方法重新确定最大元素和次大元素。由于它在最大元素之上，当它为最大元素时它能包括之前的最大元素在内，重新确定的次大元素一定会比之前的次大元素大。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果遍历完为止都没有返回True，那么返回False。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;上代码&#34;&gt;上代码：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def find132pattern(self, nums: List[int]) -&amp;gt; bool:
        stack = []
        _min = float(&#39;-inf&#39;)
        for i in range(len(nums) - 1, -1, -1):
            if nums[i] &amp;lt; _min:
                return True
            while stack and stack[-1] &amp;lt; nums[i]:
                _min = stack.pop()
            stack.append(nums[i])
        return False
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为列表的长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;逆向工作法，如果你想不出来细节时可以考虑使用。&lt;/li&gt;
&lt;li&gt;我一开始的思路是正向遍历，维护一个单调递减栈。&lt;/li&gt;
&lt;li&gt;然后确定一个最小值，但是次大元素在右边，所以单调栈内无法找到次大元素。如果次大元素在左边的话，就可以直接正向单调递减了。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>验证二叉树的前序序列化</title>
      <link>https://ripple-zjw.github.io/2019/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96/</link>
      <pubDate>Mon, 19 Aug 2019 22:51:58 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
      <description>

&lt;h1 id=&#34;题目-验证二叉树的前序序列化&#34;&gt;题目：验证二叉树的前序序列化&lt;/h1&gt;

&lt;p&gt;序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     _9_
    /   \
   3     2
  / \   / \
 4   1  #  6
/ \ / \   / \
# # # #   # #
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;例如，上面的二叉树可以被序列化为字符串 &lt;code&gt;&amp;quot;9,3,4,#,#,1,#,#,2,#,6,#,#&amp;quot;&lt;/code&gt;，其中 &lt;code&gt;#&lt;/code&gt;代表一个空节点。&lt;/li&gt;
&lt;li&gt;给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。&lt;/li&gt;
&lt;li&gt;每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 &lt;code&gt;&#39;#&#39;&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如&lt;code&gt;&amp;quot;1,,3&amp;quot;&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;9,3,4,#,#,1,#,#,2,#,6,#,#&amp;quot;
输出: true
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;1,#&amp;quot;
输出: false
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-3&#34;&gt;示例 3:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;9,#,#,1&amp;quot;
输出: false
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第331题&#34;&gt;来源：力扣（LeetCode）第331题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;分析&#34;&gt;分析：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;就是每个爸爸都要找到两个儿子。(两个儿子可以是数字也可以是&lt;code&gt;#&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#&lt;/code&gt;爸爸什么都没有，比较惨。&lt;/li&gt;
&lt;li&gt;上面两条任意一条不对都不合法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;前序遍历严格遵守中，左，右的顺序。&lt;/li&gt;
&lt;li&gt;所以第一个为根节点，到第一个&lt;code&gt;#&lt;/code&gt;为止，前面这些数字都是根节点的最左边的左子节点&lt;/li&gt;
&lt;li&gt;维护一个栈&lt;code&gt;stack&lt;/code&gt;，栈中存的是未确认它是否有两个子节点的节点，就是说如果该节点找到了他的两个子节点，就出栈(&lt;code&gt;#&lt;/code&gt;也算它的子节点)。&lt;/li&gt;
&lt;li&gt;凡是找到数字，全都入栈，因为一开始找到数字，你只能确认它的左子节点是下一个值(数字或&lt;code&gt;#&lt;/code&gt;)，无法知道它的右子节点。&lt;/li&gt;
&lt;li&gt;当找到第一个&lt;code&gt;#&lt;/code&gt;时，开始遍历右子节点。因为没有左子节点了，遍历最近的节点的右子节点，也就是栈顶元素！！！&lt;/li&gt;
&lt;li&gt;一旦遍历了右子节点，那么该节点的左右子节点都找到了，出栈。&lt;/li&gt;
&lt;li&gt;接下来继续重复之前的规律，如果字符串合法，那么stack中的元素都被弹出去了，如果栈中还有元素，那么就说明有的元素找不到它的两个儿子。&lt;/li&gt;
&lt;li&gt;大概是这么个思路，不过还有些细节要处理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;看我写的代码&#34;&gt;看我写的代码：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isValidSerialization(self, preorder: str) -&amp;gt; bool:
        if preorder == &#39;&#39;:
            return False
        if preorder == &#39;#&#39;:
            return True
        pol = preorder.split(&#39;,&#39;)  # PreOrderList
        stack = []  # 只有数字入栈，当确认了该数字的两个子节点后出栈
        n = len(pol)
        isLeftTree = True  # 如果现在遍历的是左子树的话，不用出栈，如果为右子树的话无论是什么都要出栈
        for i in range(n):
            if pol[i].isdigit():
                if not isLeftTree:
                    if not stack:  # 如果栈是空的还要弹元素的话说明这字符串不合法。
                        return False
                    stack.pop()
                stack.append(pol[i])  # 无论是左子树还是右子树，遇到数字都要入栈
                isLeftTree = True  # 如果遍历到的是数字的话，那么又开始遍历左子树了。
            else:
                isLeftTree = False  # 当左子树遍历到#号时那么左子树完了，开始遍历右子树。
                if pol[i - 1] == &#39;#&#39;:
                    if not stack:
                        return False
                    stack.pop()
        return len(stack) == 0  # 栈为空就说明合法，每一个节点都找到了它的两个子节点了。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为pol列表长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;p&gt;写的不是最优，总的来说就是将数据分为遍历左子树和右子树两种情况。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>移掉K位数字</title>
      <link>https://ripple-zjw.github.io/2019/%E7%A7%BB%E6%8E%89k%E4%BD%8D%E6%95%B0%E5%AD%97/</link>
      <pubDate>Mon, 19 Aug 2019 22:51:46 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%A7%BB%E6%8E%89k%E4%BD%8D%E6%95%B0%E5%AD%97/</guid>
      <description>

&lt;h1 id=&#34;题目-移掉k位数字&#34;&gt;题目：移掉K位数字&lt;/h1&gt;

&lt;p&gt;给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。&lt;/p&gt;

&lt;h5 id=&#34;注意&#34;&gt;注意:&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;num 的长度小于 10002 且 ≥ k。&lt;/li&gt;
&lt;li&gt;num 不会包含任何前导零。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1 :&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: num = &amp;quot;1432219&amp;quot;, k = 3
输出: &amp;quot;1219&amp;quot;
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2 :&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: num = &amp;quot;10200&amp;quot;, k = 1
输出: &amp;quot;200&amp;quot;
解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-3&#34;&gt;示例 3 :&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: num = &amp;quot;10&amp;quot;, k = 2
输出: &amp;quot;0&amp;quot;
解释: 从原数字移除所有的数字，剩余为空就是0。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第402题&#34;&gt;来源：力扣（LeetCode）第402题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/remove-k-digits&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/remove-k-digits&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;分析&#34;&gt;分析：&lt;/h3&gt;

&lt;p&gt;维护一个单调递增栈，主要的方法很容易想到，但是在处理细节上我还是费了的时间，其实不难处理但是我想的有点复杂了。&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;维护一个单调递增栈。&lt;/li&gt;
&lt;li&gt;依次遍历整个字符串，将元素放入栈，同时使单调栈严格单调递增。&lt;/li&gt;
&lt;li&gt;如果已经弹出去k个元素了，那么剩下的值直接放入栈中即可，不用再删了。&lt;/li&gt;
&lt;li&gt;如果还没到k个元素字符串就遍历完了，那么根据剩下还要加的元素数量，从栈顶依次出栈。&lt;/li&gt;
&lt;li&gt;栈有可能是空，根据示例3，栈为空答案时&lt;code&gt;&amp;quot;0&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果栈有值，那么将栈合并为字符串，得出答案。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;激动人心的代码环节&#34;&gt;激动人心的代码环节：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def removeKdigits(self, num: str, k: int) -&amp;gt; str:
        stack = []
        cnt = 0
        n = len(num)
        for i in range(n):
            while cnt &amp;lt; k and stack and stack[-1] &amp;gt; num[i]:
                tmp = stack.pop()
                cnt += 1
            if stack or num[i] != &#39;0&#39;:
                stack.append(num[i])
        while stack and cnt &amp;lt; k:
            stack.pop()
            cnt += 1
        ans = &#39;&#39;.join(stack)
        return ans if ans != &#39;&#39; else &#39;0&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为字符串的长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n) n为k的长度&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;单调栈的思想越来越熟了，但是在处理细节上还是不够熟练。&lt;/li&gt;
&lt;li&gt;虽然自己第一遍做出来了，但是并没有想到最优算法，写的稍微有的啰嗦了。&lt;/li&gt;
&lt;li&gt;我觉得一开始没处理好是因为我忽略了k这个值，于是关于k的细节没有想得很全面，导致最后自己测试时总是会发现一些小错误，浪费时间。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>搭建Hugo时需要注意的坑</title>
      <link>https://ripple-zjw.github.io/2019/%E6%90%AD%E5%BB%BAhugo%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9D%91/</link>
      <pubDate>Sat, 17 Aug 2019 18:58:39 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%90%AD%E5%BB%BAhugo%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9D%91/</guid>
      <description>

&lt;h1 id=&#34;搭建hugo时需要注意的坑&#34;&gt;搭建Hugo时需要注意的坑&lt;/h1&gt;

&lt;p&gt;Hugo是一种博客框架，可以说是非常优秀的博客框架。基于go语言，网页生成的速度非常的快，而且下载简单，在GitHub上就能下载，还有官方的中文文档，操作也是很简单。但是对于刚开始搭建博客的小白，还是会遇到各种各样的问题，在这里我把我遇到的坑分享给各位读者。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;从GitHub上把Hugo下载下来会慢，当然也有人网速没问题。这个问题可以找网上的一些方法，比如改hosts文件。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可能有人和我一样下载完解压后在终端输入&lt;code&gt;hugo xxx&lt;/code&gt;的命令无效，那是因为系统找不到你要输的是什么东西，有两种解决方法。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一种是每次输入命令都带上你&lt;code&gt;hugo.exe&lt;/code&gt;文件的绝对路径，但是这样太麻烦了。&lt;/li&gt;
&lt;li&gt;第二种是将&lt;code&gt;hugo.exe&lt;/code&gt;添加到你系统的环境变量中，这样直接输入hugo就能启动命令了。&lt;/li&gt;
&lt;li&gt;设置方法为：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;控制面板 &amp;gt; 系统和安全 &amp;gt; 系统 &amp;gt; 高级系统设置 &amp;gt; 高级 &amp;gt; 环境变量&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;上下两个一个是用户变量，一个是系统变量，建议两个都设置。&lt;/li&gt;
&lt;li&gt;点击&lt;code&gt;Path&lt;/code&gt;变量，然后点击&lt;code&gt;新建&lt;/code&gt;，将你&lt;code&gt;hugo.exe&lt;/code&gt;的绝对路径目录添加进去，注意是目录。不要把&lt;code&gt;hugo.exe&lt;/code&gt;带进去。例如：你的目录为&lt;code&gt;c:/xxx/xxx/hugo.exe&lt;/code&gt;，你只要添加&lt;code&gt;c:/xxx/xxx&lt;/code&gt;就行了。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;主题是下载到&lt;code&gt;themes\&lt;/code&gt;文件夹中的，用git clone。如果不会使用git，请参考我关于git的文章&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下载完之后，里面基本都会有一个&lt;code&gt;exampleSite\&lt;/code&gt;文件夹，里面放的是一个样式，你可以直接把里面的&lt;code&gt;config.toml&lt;/code&gt;中的内容复制到你的博客主目录的&lt;code&gt;config.toml&lt;/code&gt;中。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;你博客根目录的&lt;code&gt;config.toml&lt;/code&gt;文件里要把&lt;code&gt;baseURL&lt;/code&gt;参数换成你的博客网站网址，如果你还没有部署到网上，可以填你的本地网址，就是那个默认端口1313的那个。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;你部署好之后，如果想要继续添加文章，首先使用&lt;code&gt;hugo&lt;/code&gt;命令重新生成&lt;code&gt;public/&lt;/code&gt;文件夹，然后在里面用git添加，提交，上传就行了。与第一次部署时的操作一样。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;### 以上差不多就是我遇到的坑。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>字符串解码</title>
      <link>https://ripple-zjw.github.io/2019/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</link>
      <pubDate>Sat, 17 Aug 2019 18:51:43 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</guid>
      <description>

&lt;h1 id=&#34;题目-字符串解码&#34;&gt;题目：字符串解码&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个经过编码的字符串，返回它解码后的字符串。&lt;/li&gt;
&lt;li&gt;编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。&lt;/li&gt;
&lt;li&gt;你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。&lt;/li&gt;
&lt;li&gt;此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&#34;示例&#34;&gt;示例:&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;s = &amp;quot;3[a]2[bc]&amp;quot;, 返回 &amp;quot;aaabcbc&amp;quot;.
s = &amp;quot;3[a2[c]]&amp;quot;, 返回 &amp;quot;accaccacc&amp;quot;.
s = &amp;quot;2[abc]3[cd]ef&amp;quot;, 返回 &amp;quot;abcabccdcdcdef&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第394题&#34;&gt;来源：力扣（LeetCode）第394题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/decode-string&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/decode-string&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;分析&#34;&gt;分析：&lt;/h3&gt;

&lt;p&gt;两种方法，辅助栈法和递归法，递归法相对思路清晰，比较好做。其实本质两种方法是一样的，因为函数的递归调用其实也是用栈来实现的。&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;递归法：

&lt;ul&gt;
&lt;li&gt;遍历整个字符串&lt;/li&gt;
&lt;li&gt;同时要用到stack列表，tmp列表，还有一个表示下标的变量i&lt;/li&gt;
&lt;li&gt;每次递归之后stack都是该函数的stack，与外面的stack不同&lt;/li&gt;
&lt;li&gt;每次遍历字符时，tmp都要将里面的值清空&lt;/li&gt;
&lt;li&gt;遇到字母，压入stack&lt;/li&gt;
&lt;li&gt;遇到&lt;code&gt;]&lt;/code&gt;字符,结束函数并将stack返回&lt;/li&gt;
&lt;li&gt;遇到数字首先判断该数字后是否还有数字，有的话一起加入tmp，然后递归调用函数。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;辅助栈法：

&lt;ul&gt;
&lt;li&gt;遍历整个字符串&lt;/li&gt;
&lt;li&gt;res表示当前字符串，multi表示当前数字，stack储存答案&lt;/li&gt;
&lt;li&gt;遇到字母，与res拼接起来&lt;/li&gt;
&lt;li&gt;遇到数字，放入multi，注意由于两个数字放在一起要变成两位数，以此类推，所以res 写成&lt;code&gt;res = res * 10 + 当前数字&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;遇到&lt;code&gt;[&lt;/code&gt;，将res，multi同时入栈，用一个列表或元祖，并行的，不是先后入栈。&lt;/li&gt;
&lt;li&gt;遇到右括号，栈顶元素出栈，并将栈顶元素的multi与当前字符相乘，然后再与栈顶的res相加&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;上代码&#34;&gt;上代码：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;递归法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def decodeString(self, s: str) -&amp;gt; str:
        self.i = 0
        return &#39;&#39;.join(self.recursion(s))
            
    def recursion(self, s: str) -&amp;gt; list:
        stack = []
        while self.i &amp;lt; len(s):
            tmp = []
            if s[self.i].isalpha():
                stack.append(s[self.i])
            elif s[self.i] == &#39;]&#39;:
                return stack
            elif s[self.i].isdigit():
                tmp.append(s[self.i])
                while s[self.i + 1].isdigit():
                    tmp.append(s[self.i + 1])
                    self.i += 1
                self.i += 2
                stack += (int(&#39;&#39;.join(tmp)) * self.recursion(s))
            self.i += 1
        return stack
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;辅助栈法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def decodeString(self, s: str) -&amp;gt; str:
        stack, res, multi = [], &amp;quot;&amp;quot;, 0
        for c in s:
            if c == &#39;[&#39;:
                stack.append([multi, res])
                res, multi = &amp;quot;&amp;quot;, 0
            elif c == &#39;]&#39;:
                cur_multi, last_res = stack.pop()
                res = last_res + cur_multi * res
            elif &#39;0&#39; &amp;lt;= c &amp;lt;= &#39;9&#39;:
                multi = multi * 10 + int(c)            
            else:
                res += c
        return res
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;辅助栈法不是我自己写的，可以参考LeetCode上的作者：
&amp;gt; &lt;a href=&#34;https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;递归法：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为字符串长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;辅助栈法：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为字符串长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;递归是一种不错的尝试，很多时候递归的时间耗时并不是非常高，而且解题方便。&lt;/li&gt;
&lt;li&gt;写这种题目前需要理清各种情况时的行为。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>