<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>递归 on LeaveIt</title>
    <link>https://ripple-zjw.github.io/tags/%E9%80%92%E5%BD%92/</link>
    <description>Recent content in 递归 on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 23 Aug 2019 12:57:06 +0800</lastBuildDate>
    
	<atom:link href="https://ripple-zjw.github.io/tags/%E9%80%92%E5%BD%92/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>求最大子数组</title>
      <link>https://ripple-zjw.github.io/2019/%E6%B1%82%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</link>
      <pubDate>Fri, 23 Aug 2019 12:57:06 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%B1%82%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</guid>
      <description>题目：求最大子数组  在一个数组中找到和最大的子数组。 数组中有正有负，但都是integer类型。  题目来源：算法导论第38页 4.1 最大子数组问题 分析： 根据书中的问题，采用分治思想来解题。具体可参考算法导论。
思路：  将整个数组一分为二，每次分完之后做四件事件：  查看是否是最小数组即长度是1，因为数组长度是1那么总和就是这一个数的值。 如果不是1，那就分别递归进左边的数组和右边的数组继续分，直到分到1再返回。 每次递归除了左边的最大子数组和右边的最大子数组外，还有交叉在中间的最大子数组。所以要把中间的最大子数组也算出来。 算出三者的各自的和将和最大的那个子数组并返回，同时返回它的两端下标。  每次递归都会返回左边，右边，中间的最大的那个子数组。 最后一次递归返回最大的子数组，答案就出来了。  代码： class FindMaxNum: def _find_crossing(self, A, low, mid, high): # 寻找穿过中间值的最大子数组 leftSum = float(&#39;-inf&#39;) ans = 0 maxLeft = mid maxRight = mid + 1 for i in range(mid, low - 1, -1): # 找到左边的最大子数组 ans += A[i] if ans &amp;gt; leftSum: leftSum = ans maxLeft = i rightSum = float(&#39;-inf&#39;) ans = 0 for j in range(mid + 1, high + 1): # 找到右边的最大子数组 ans += A[j] if ans &amp;gt; rightSum: rightSum = ans maxRight = j return maxLeft, maxRight, leftSum + rightSum # 返回最大的子数组以及它的两端下标 def find_max_num(self, A, low, high): if low == high: # 如果分到了1，那么就返回 return low, high, A[low] else: mid = (low + high) // 2 # 将数组一分为二 left_low, left_high, left_sum = self.</description>
    </item>
    
    <item>
      <title>字符串解码</title>
      <link>https://ripple-zjw.github.io/2019/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</link>
      <pubDate>Sat, 17 Aug 2019 18:51:43 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</guid>
      <description>题目：字符串解码  给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。  示例: s = &amp;quot;3[a]2[bc]&amp;quot;, 返回 &amp;quot;aaabcbc&amp;quot;. s = &amp;quot;3[a2[c]]&amp;quot;, 返回 &amp;quot;accaccacc&amp;quot;. s = &amp;quot;2[abc]3[cd]ef&amp;quot;, 返回 &amp;quot;abcabccdcdcdef&amp;quot;.  来源：力扣（LeetCode）第394题  链接：https://leetcode-cn.com/problems/decode-string
 分析： 两种方法，辅助栈法和递归法，递归法相对思路清晰，比较好做。其实本质两种方法是一样的，因为函数的递归调用其实也是用栈来实现的。
思路：  递归法：  遍历整个字符串 同时要用到stack列表，tmp列表，还有一个表示下标的变量i 每次递归之后stack都是该函数的stack，与外面的stack不同 每次遍历字符时，tmp都要将里面的值清空 遇到字母，压入stack 遇到]字符,结束函数并将stack返回 遇到数字首先判断该数字后是否还有数字，有的话一起加入tmp，然后递归调用函数。  辅助栈法：  遍历整个字符串 res表示当前字符串，multi表示当前数字，stack储存答案 遇到字母，与res拼接起来 遇到数字，放入multi，注意由于两个数字放在一起要变成两位数，以此类推，所以res 写成res = res * 10 + 当前数字 遇到[，将res，multi同时入栈，用一个列表或元祖，并行的，不是先后入栈。 遇到右括号，栈顶元素出栈，并将栈顶元素的multi与当前字符相乘，然后再与栈顶的res相加   上代码：  递归法：</description>
    </item>
    
    <item>
      <title>扁平化嵌套列表迭代器</title>
      <link>https://ripple-zjw.github.io/2019/%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Sat, 17 Aug 2019 18:50:30 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>题目:扁平化嵌套列表迭代器  给定一个嵌套的整型列表。设计一个迭代器，使其能够遍历这个整型列表中的所有整数。 列表中的项或者为一个整数，或者是另一个列表。  示例 1: 输入: [[1,1],2,[1,1]] 输出: [1,1,2,1,1] 解释: 通过重复调用 next 直到 hasNext 返回false，next 返回的元素的顺序应该是: [1,1,2,1,1]。  示例 2: 输入: [1,[4,[6]]] 输出: [1,4,6] 解释: 通过重复调用 next 直到 hasNext 返回false，next 返回的元素的顺序应该是: [1,4,6]。  来源：力扣（LeetCode）第341题  链接：https://leetcode-cn.com/problems/flatten-nested-list-iterator
 分析： 递归调用，不是很难。唯一要注意的是要看清题目，list里面是NestedIterator，需要使用他给你的方法调用才能得到integer或者list。
思路：  从后往前遍历 判断是否是integer，是 入栈 不是 递归进去 返回栈，结束。  代码： # &amp;quot;&amp;quot;&amp;quot; # This is the interface that allows for creating nested lists. # You should not implement it, or speculate about its implementation # &amp;quot;&amp;quot;&amp;quot; #class NestedInteger(object): # def isInteger(self): # &amp;quot;&amp;quot;&amp;quot; # @return True if this NestedInteger holds a single integer, rather than a nested list.</description>
    </item>
    
  </channel>
</rss>