<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>树 on LeaveIt</title>
    <link>https://ripple-zjw.github.io/tags/%E6%A0%91/</link>
    <description>Recent content in 树 on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 23 Aug 2019 12:49:52 +0800</lastBuildDate>
    
	<atom:link href="https://ripple-zjw.github.io/tags/%E6%A0%91/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>二叉树的后序遍历</title>
      <link>https://ripple-zjw.github.io/2019/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Fri, 23 Aug 2019 12:49:52 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>题目：二叉树的后序遍历  给定一个二叉树，返回它的 后序 遍历。  示例: 输入: [1,null,2,3] 1 \ 2 / 3 输出: [3,2,1]  进阶:递归算法很简单，你可以通过迭代算法完成吗？
来源：力扣（LeetCode）第145题  链接：https://leetcode-cn.com/problems/binary-tree-postorder-traversal
 分析： 方法有很多，递归法最简单，迭代法使用栈辅助完成，还有莫里斯遍历。本文讲解官方写的题解迭代法。虽然我也写出了迭代法，但是官方的解法既简单又高效，非常厉害。使用了迭代法+逆向工作法。
思路：  后序遍历是左，右，中。可是中在最后，如果正常解后序遍历的话有的复杂。 如果我们用中，右，左这样来遍历的话岂不是将后序遍历变成了前序遍历的翻版类型。 这样的话答案只是与我们要求的答案相反，翻转一下列表就可以了。 所以解法就是一个反向的先序遍历方法。  代码：  官方的迭代法+逆向工作法
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def postorderTraversal(self, root: TreeNode) -&amp;gt; List[int]: if root is None: return [] stack = [root] res = [] while stack: root = stack.</description>
    </item>
    
    <item>
      <title>验证二叉树的前序序列化</title>
      <link>https://ripple-zjw.github.io/2019/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96/</link>
      <pubDate>Mon, 19 Aug 2019 22:51:58 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
      <description>题目：验证二叉树的前序序列化 序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。
 _9_ / \ 3 2 / \ / \ 4 1 # 6 / \ / \ / \ # # # # # #   例如，上面的二叉树可以被序列化为字符串 &amp;quot;9,3,4,#,#,1,#,#,2,#,6,#,#&amp;quot;，其中 #代表一个空节点。 给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。 每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 &#39;#&#39; 。 你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如&amp;quot;1,,3&amp;quot;。  示例 1: 输入: &amp;quot;9,3,4,#,#,1,#,#,2,#,6,#,#&amp;quot; 输出: true  示例 2: 输入: &amp;quot;1,#&amp;quot; 输出: false  示例 3: 输入: &amp;quot;9,#,#,1&amp;quot; 输出: false  来源：力扣（LeetCode）第331题  链接：https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree
 分析：  就是每个爸爸都要找到两个儿子。(两个儿子可以是数字也可以是#) #爸爸什么都没有，比较惨。 上面两条任意一条不对都不合法。  思路:  前序遍历严格遵守中，左，右的顺序。 所以第一个为根节点，到第一个#为止，前面这些数字都是根节点的最左边的左子节点 维护一个栈stack，栈中存的是未确认它是否有两个子节点的节点，就是说如果该节点找到了他的两个子节点，就出栈(#也算它的子节点)。 凡是找到数字，全都入栈，因为一开始找到数字，你只能确认它的左子节点是下一个值(数字或#)，无法知道它的右子节点。 当找到第一个#时，开始遍历右子节点。因为没有左子节点了，遍历最近的节点的右子节点，也就是栈顶元素！！！ 一旦遍历了右子节点，那么该节点的左右子节点都找到了，出栈。 接下来继续重复之前的规律，如果字符串合法，那么stack中的元素都被弹出去了，如果栈中还有元素，那么就说明有的元素找不到它的两个儿子。 大概是这么个思路，不过还有些细节要处理。  看我写的代码： class Solution: def isValidSerialization(self, preorder: str) -&amp;gt; bool: if preorder == &#39;&#39;: return False if preorder == &#39;#&#39;: return True pol = preorder.</description>
    </item>
    
    <item>
      <title>二叉树的锯齿形层次遍历</title>
      <link>https://ripple-zjw.github.io/2019/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sat, 17 Aug 2019 18:48:01 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</guid>
      <description>题目: 二叉树的锯齿形层次遍历 给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
例如： 给定二叉树 [3,9,20,null,null,15,7],
 3 / \ 9 20 / \ 15 7  返回锯齿形层次遍历如下：
[ [3], [20,9], [15,7] ]  来源：力扣（LeetCode）第103题  链接：https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal
 分析: 层次遍历比较简单，主要是锯齿形，就是单数层从左到右，双数层从右到左。网上有很多题解，看了他们的之后觉得没有自己的好，他们基本都是使用了反转列表的操作，理论上会很耗时间。所以，我讲的是自己写的思路。
思路:  运用双栈法，分别储存单数层和双数层两种情况。 ans为返回的总列表，res为每一层的答案，stack和helper是两个栈，方法和之前的前、中序遍历差不多。 写一个主循环while，再写两个循环放在主循环中，一个遍历单数层，一个遍历双数层。 两个循环里把双栈中的节点拿出来，同时也把节点的两个子节点(stack或者helper)以及他们的值(res)也存起来。 最后将res的值加到ans中。主循环结束，ans值也都进去了。  代码: # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def zigzagLevelOrder(self, root: TreeNode) -&amp;gt; List[List[int]]: if root is None: return [] stack = [] helper = [root] res = [] ans = [[root.</description>
    </item>
    
    <item>
      <title>二叉搜索树迭代器</title>
      <link>https://ripple-zjw.github.io/2019/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Thu, 15 Aug 2019 16:42:03 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>题目：二叉搜索树迭代器  实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。 调用 next() 将返回二叉搜索树中的下一个最小的数。  示例： BSTIterator iterator = new BSTIterator(root); iterator.next(); // 返回 3 iterator.next(); // 返回 7 iterator.hasNext(); // 返回 true iterator.next(); // 返回 9 iterator.hasNext(); // 返回 true iterator.next(); // 返回 15 iterator.hasNext(); // 返回 true iterator.next(); // 返回 20 iterator.hasNext(); // 返回 false  提示：  next() 和 hasNext() 操作的时间复杂度是 O(1)，并使用O(h)内存，其中 h 是树的高度。 你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 中至少存在一个下一个最小的数。  来源：力扣（LeetCode）第173题  链接：https://leetcode-cn.com/problems/binary-search-tree-iterator</description>
    </item>
    
    <item>
      <title>中序遍历二叉树</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Wed, 14 Aug 2019 13:22:20 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目：二叉树的中序遍历 给定一个二叉树，返回它的中序遍历。
示例: 输入: [1,null,2,3] 1 \ 2 / 3 输出: [1,3,2]   进阶: 递归算法很简单，你可以通过迭代算法完成吗？  来源：力扣（LeetCode）第94题  链接：https://leetcode-cn.com/problems/binary-tree-inorder-traversal
 分析: 两种方法，一种是最常用的递归遍历，非常简单。第二种是迭代遍历，需要用到栈。本文章分析第二种算法。
思路: 维护一个栈，每次经过一个节点，就入栈，当节点的左节点没有值时出栈，并继续从出栈的那个节点找它的右节点。
 维护一个栈stack和要储存答案的列表ans 写一个循环，不停地将左节点一层一层的入栈 当左节点为None时，不要入栈，并且将栈顶节点弹出 拿到栈顶节点的value，并且进入该节点的右节点（因为中序遍历是左，中，右） 继续拿这个节点的左节点，重复2-4步 当节点值为None 或者 stack为空时结束循环  代码： # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def inorderTraversal(self, root: TreeNode) -&amp;gt; List[int]: stack = [] ans = [] tail = root while tail is not None or stack: while tail is not None: stack.</description>
    </item>
    
  </channel>
</rss>