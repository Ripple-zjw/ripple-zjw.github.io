<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeaveIt on LeaveIt</title>
    <link>https://ripple-zjw.github.io/</link>
    <description>Recent content in LeaveIt on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 23 Aug 2019 13:01:17 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>有序数组的平方</title>
      <link>https://ripple-zjw.github.io/2019/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</link>
      <pubDate>Fri, 23 Aug 2019 13:01:17 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</guid>
      <description>

&lt;h1 id=&#34;题目-有序数组的平方&#34;&gt;题目：有序数组的平方&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：[-4,-1,0,3,10]
输出：[0,1,9,16,100]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：[-7,-3,2,3,11]
输出：[4,9,9,49,121]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;提示&#34;&gt;提示：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= &lt;code&gt;A.length&lt;/code&gt; &amp;lt;= 10000&lt;/li&gt;
&lt;li&gt;10000 &amp;lt;= &lt;code&gt;A[i]&lt;/code&gt; &amp;lt;= 10000&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A&lt;/code&gt;已按非递减顺序排序。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第977题&#34;&gt;来源：力扣（LeetCode）第977题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/squares-of-a-sorted-array&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/squares-of-a-sorted-array&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;这道题的方法有两种，一种最简单，先计算，再排序。第二种用双指针做到一遍遍历解答。&lt;/p&gt;

&lt;h2 id=&#34;思路&#34;&gt;思路：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;由于数组是按照递增的顺序增长的，因此所有的正数都是递增的，所有的负数加上绝对值都是递减的。&lt;/li&gt;
&lt;li&gt;我们用两个指针&lt;code&gt;i&lt;/code&gt;和&lt;code&gt;j&lt;/code&gt;，&lt;code&gt;i&lt;/code&gt;从前往后遍历，&lt;code&gt;j&lt;/code&gt;从后往前遍历。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt;遇到正数就停下来，&lt;code&gt;j&lt;/code&gt;遇到负数就停下来，然后比较他们两谁小，小的那个放到ans答案中。&lt;/li&gt;
&lt;li&gt;然后就把放入答案中的那个指针往后前移。&lt;/li&gt;
&lt;li&gt;最后退出循环，但是可能有一个指针并没有移到终点，因此要在循环结束后去判断两个指针的情况，把指针后面的值都加到ans中去。&lt;/li&gt;
&lt;li&gt;最后得到答案。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def sortedSquares(self, A: List[int]) -&amp;gt; List[int]:
        i = 0
        j = len(A) - 1
        ans = []
        while i &amp;lt; len(A) and j &amp;gt;= 0:  # 主循环
            while i &amp;lt; len(A) and A[i] &amp;lt; 0:  # 遍历到第一个正数
                i += 1
            while j &amp;gt;= 0 and A[j] &amp;gt;= 0:  # 遍历到第一个负数
                j -= 1
            if i &amp;lt; len(A) and j &amp;gt;= 0:  # 谁小就把谁加进来
                if A[i] ** 2 &amp;gt; A[j] ** 2:
                    ans.append(A[j] ** 2)
                    j -= 1
                else:
                    ans.append(A[i] ** 2)
                    i += 1
        while i &amp;lt; len(A):  # 如果i没有到遍历完吧i加进去
            ans.append(A[i] ** 2)
            i += 1
        while j &amp;gt;=0:  # j没有到头把j加进去
            ans.append(A[j] ** 2)
            j -= 1
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;简单暴力法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def sortedSquares(self, A: List[int]) -&amp;gt; List[int]:
    return sorted(x * x for x in A)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;双指针法：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n 为数组长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;暴力法：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(nlogn) n为数组长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;双指针法在解数组这一块的问题时是一个不错的方法。&lt;/li&gt;
&lt;li&gt;一段递增的数，如果有负数那么负数的绝对值是递减的。反向遍历就能使其递增。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>高度检查器</title>
      <link>https://ripple-zjw.github.io/2019/%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/</link>
      <pubDate>Fri, 23 Aug 2019 12:59:06 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/</guid>
      <description>

&lt;h1 id=&#34;题目-高度检查器&#34;&gt;题目：高度检查器&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。&lt;/li&gt;
&lt;li&gt;请你返回至少有多少个学生没有站在正确位置数量。该人数指的是：能让所有学生以 非递减 高度排列的必要移动人数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：[1,1,4,2,1,3]
输出：3
解释：
高度为 4、3 和最后一个 1 的学生，没有站在正确的位置。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;提示&#34;&gt;提示：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= heights.length &amp;lt;= 100&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= heights[i] &amp;lt;= 100&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第1051题&#34;&gt;来源：力扣（LeetCode）第1051题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/height-checker&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/height-checker&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;有两种方法。都是先排序，然后比较两者之间的差异。不同处，第一种是比较排序，第二种是计数排序。计数排序的时间复杂度相对较低，本文讲解计数排序。&lt;/p&gt;

&lt;h2 id=&#34;思路&#34;&gt;思路：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;因为&lt;code&gt;heights[i]&lt;/code&gt;不会超过100，所以采用hash的思想，将所给数组每个值出现的次数作为值，将所给数组的值作为下标，这样相同值出现的次数就会被归在一起，而且值小的元素会在前面，因为下标就是值。&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;1&lt;/code&gt;出现了3次，那么这3次一定是在最前面的，所以我们顺序遍历原数组，如果前3次不是1，就说明这个数要移动，以此类推。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def heightChecker(self, heights: List[int]) -&amp;gt; int:
        ans = 0
        arr = [0] * 101  # heights[i]最多不超过100个
        for height in heights:  # 将heights散列到arr中
            arr[height] += 1
        j = 0
        for i in range(1, len(arr)):  # 根据arr中的计数排序比较原数组
            while arr[i] &amp;gt; 0:
                if heights[j] != i:  # 如果值不同，那么ans就+1
                    ans += 1
                j += 1
                arr[i] -= 1  # 比较完一次计数就-1，减到0说明这个数没有了。
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;然后再放上比较排序的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
def heightChecker(self, heights: List[int]) -&amp;gt; int:
    sorted_list = sorted(heights)
    ans = 0
    for i in range(len(heights)):
        if heights[i] != sorted_list[i]:
            ans += 1
    return ans
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;计数排序：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) &lt;code&gt;n = n + n&lt;/code&gt; n为数组&lt;code&gt;heights&lt;/code&gt;的长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1) 1 为arr的长度101&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;比较排序：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(nlogn) n 为&lt;code&gt;heights&lt;/code&gt;的长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;计数排序的效率比快速排序还要快，但是只适用于特殊场景。&lt;/li&gt;
&lt;li&gt;例如在该题中，如果&lt;code&gt;heights[i]&lt;/code&gt;的大小非常大，那么需要的内存空间会非常多。如果大小不确定，那么就无法知道该声明多长的数组，一旦内存溢出，程序就崩溃了。又比如次数非常少，基本没有重复的数，那么排序的时间也不会快到哪里去。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>求最大子数组</title>
      <link>https://ripple-zjw.github.io/2019/%E6%B1%82%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</link>
      <pubDate>Fri, 23 Aug 2019 12:57:06 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%B1%82%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</guid>
      <description>

&lt;h1 id=&#34;题目-求最大子数组&#34;&gt;题目：求最大子数组&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;在一个数组中找到和最大的子数组。&lt;/li&gt;
&lt;li&gt;数组中有正有负，但都是&lt;code&gt;integer&lt;/code&gt;类型。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;题目来源-算法导论第38页-4-1-最大子数组问题&#34;&gt;题目来源：算法导论第38页 4.1 最大子数组问题&lt;/h4&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;根据书中的问题，采用分治思想来解题。具体可参考算法导论。&lt;/p&gt;

&lt;h2 id=&#34;思路&#34;&gt;思路：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;将整个数组一分为二，每次分完之后做四件事件：

&lt;ul&gt;
&lt;li&gt;查看是否是最小数组即长度是1，因为数组长度是1那么总和就是这一个数的值。&lt;/li&gt;
&lt;li&gt;如果不是1，那就分别递归进左边的数组和右边的数组继续分，直到分到1再返回。&lt;/li&gt;
&lt;li&gt;每次递归除了左边的最大子数组和右边的最大子数组外，还有交叉在中间的最大子数组。所以要把中间的最大子数组也算出来。&lt;/li&gt;
&lt;li&gt;算出三者的各自的和将和最大的那个子数组并返回，同时返回它的两端下标。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;每次递归都会返回左边，右边，中间的最大的那个子数组。&lt;/li&gt;
&lt;li&gt;最后一次递归返回最大的子数组，答案就出来了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class FindMaxNum:
	def _find_crossing(self, A, low, mid, high):  # 寻找穿过中间值的最大子数组
		leftSum = float(&#39;-inf&#39;)
		ans = 0
		maxLeft = mid
		maxRight = mid + 1
		for i in range(mid, low - 1, -1):  # 找到左边的最大子数组
			ans += A[i]
			if ans &amp;gt; leftSum:
				leftSum = ans
				maxLeft = i
		rightSum = float(&#39;-inf&#39;)
		ans = 0
		for j in range(mid + 1, high + 1):  # 找到右边的最大子数组
			ans += A[j]
			if ans &amp;gt; rightSum:
				rightSum = ans
				maxRight = j
		return maxLeft, maxRight, leftSum + rightSum  # 返回最大的子数组以及它的两端下标


	def find_max_num(self, A, low, high):
		if low == high:  # 如果分到了1，那么就返回
			return low, high, A[low]
		else:
			mid = (low + high) // 2  # 将数组一分为二
			left_low, left_high, left_sum = self.find_max_num(A, low, mid)  # 递归进左子数组
			right_low, right_high, right_sum = self.find_max_num(A, mid + 1, high)  # 递归进右子数组
			cro_low, cro_high, cro_sum = self._find_crossing(A, low, mid, high)  # 寻找中间子数组
			if left_sum &amp;gt;= right_sum and left_sum &amp;gt;= cro_sum:  # 左边最大返回左边
				return left_low, left_high, left_sum
			elif right_sum &amp;gt;= left_sum and right_sum &amp;gt;= cro_sum:  # 右边最大返回右边
				return right_low, right_high, right_sum
			else:  # 否则中间最大返回中间
				return cro_low, cro_high, cro_sum

if __name__ == &#39;__main__&#39;:  # 测试通过
	test = [13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7]
	fn = FindMaxNum()
	i, j, res = fn.find_max_num(test, 0, len(test) - 1)
	print(test[i:j+1])
	print(i,j)
	print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(nlogn) n 为数组的长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1) 完全没有开辟新的数组空间，仅仅是在原数组上分治。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;分治算法可以大幅度提高运行效率，相比于暴力法，速度提升很多。&lt;/li&gt;
&lt;li&gt;算法导论上的这个分治法应该是我看到的最好的分治法了，很多地方的算法解这道题时总是会开辟新的数组，这就导致了内存空间的浪费，如果数据量多的话，很容易空间不够。&lt;/li&gt;
&lt;li&gt;分治的主要思想就是找到递归条件和线性条件。然后用分而治之的方法从线性条件不停地向前合并，最终找到答案。主要的原理和递归很像。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>接雨水</title>
      <link>https://ripple-zjw.github.io/2019/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</link>
      <pubDate>Fri, 23 Aug 2019 12:55:03 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</guid>
      <description>

&lt;h1 id=&#34;题目-接雨水&#34;&gt;题目：接雨水&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定&lt;code&gt;n&lt;/code&gt;个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;images/接雨水/rainwatertrap.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;上面是由数组 &lt;code&gt;[0,1,0,2,1,0,1,3,2,1,2,1]&lt;/code&gt; 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。感谢 &lt;code&gt;Marcos&lt;/code&gt; 贡献此图。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第42题&#34;&gt;来源：力扣（LeetCode）第42题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/trapping-rain-water&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/trapping-rain-water&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;方法太多了，一道极难题，从暴力法，到动态规划，再到单调栈，再到双指针。方法非常多，也很难理解，暴力法最好理解，dp和双指针稍难，我这里讲单调栈的方法。&lt;/p&gt;

&lt;h2 id=&#34;思路&#34;&gt;思路：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;维护一个单调递减栈。&lt;/li&gt;
&lt;li&gt;当有值比栈顶元素大的时候做这么几件事情：

&lt;ul&gt;
&lt;li&gt;先出栈一个元素并保存到top中。&lt;/li&gt;
&lt;li&gt;然后判断stack是否是空，如果是空的话，说明出栈的左边没有东西，所以无法装雨水。(一定要两边都要有东西并且两边的墙比出栈的墙要长，这样才能装雨水)&lt;/li&gt;
&lt;li&gt;算出当前元素与栈顶元素中间的距离&lt;code&gt;dis&lt;/code&gt;(注意现在是出栈之后的栈顶元素)&lt;/li&gt;
&lt;li&gt;算出当前元素与栈顶元素中哪个值最小，并将小的那个值与出栈的那个元素相减，得到&lt;code&gt;floor_cnt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;为什么要叫&lt;code&gt;floor_cnt&lt;/code&gt;呢，因为将&lt;code&gt;floor_cnt&lt;/code&gt;与&lt;code&gt;dis&lt;/code&gt;(也就是两栋大墙之间的距离)相乘，你就能得到在这两栋墙之间一层的雨水数量。&lt;/li&gt;
&lt;li&gt;将它们加到ans答案中。例如：如果两栋墙最小的那栋是&lt;code&gt;3&lt;/code&gt;，那么就会有3层，每一层的雨水数量可能是不一样的，所以要算3遍。&lt;/li&gt;
&lt;li&gt;最后返回ans得到答案。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果值比栈顶元素小的话就入栈就行了，这样就能维护单调递减栈。(注意栈中存的是数组下标，为了算起来方便。)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;talk-is-cheap-show-me-the-code&#34;&gt;Talk is cheap,show me the code.&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution(object):
    def trap(self, height):
        stack = []
        ans = 0
        cur = 0
        while cur &amp;lt; len(height):
            while stack and height[stack[-1]] &amp;lt; height[cur]:
                top = stack.pop()
                if not stack:
                    break
                dis = cur - stack[-1] - 1
                floor_cnt = min(height[stack[-1]], height[cur]) - height[top]
                ans += dis * floor_cnt
            stack.append(cur)
            cur += 1
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;顺便写上双指针法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def trap(self, height: List[int]) -&amp;gt; int:
        lMax = 0
        rMax = 0
        res = 0
        i = 0
        j = len(height) - 1
        while i &amp;lt; j:
            if height[i] &amp;lt; height[j]:
                if height[i] &amp;gt;= lMax:
                    lMax = height[i]
                else:
                    res += (lMax - height[i])
                i += 1
            else:
                if height[j] &amp;gt;= rMax:
                    rMax = height[j]
                else:
                    res += (rMax - height[j])
                j -= 1
        return res
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n 为height长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n) n为stack长度。最坏情况下完全是单调递减栈，n变为height的长度。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;这是一道hard题。难度挺大的，其实我自己第一次想的时侯方法已经很接近了，但就是那个突破口没有想到，导致做不出来。&lt;/li&gt;
&lt;li&gt;如果我能想到一层一层算的话这道题就能解决了。&lt;/li&gt;
&lt;li&gt;而且这道题非常经典，有非常多的解法，建议大家收藏。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>任务调度器</title>
      <link>https://ripple-zjw.github.io/2019/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/</link>
      <pubDate>Fri, 23 Aug 2019 12:52:54 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/</guid>
      <description>

&lt;h1 id=&#34;题目-任务调度器&#34;&gt;题目：任务调度器&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。&lt;/li&gt;
&lt;li&gt;任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。&lt;/li&gt;
&lt;li&gt;CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。&lt;/li&gt;
&lt;li&gt;然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。&lt;/li&gt;
&lt;li&gt;你需要计算完成所有任务所需要的最短时间。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: tasks = [&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;,&amp;quot;B&amp;quot;,&amp;quot;B&amp;quot;,&amp;quot;B&amp;quot;], n = 2
输出: 8
执行顺序: A -&amp;gt; B -&amp;gt; (待命) -&amp;gt; A -&amp;gt; B -&amp;gt; (待命) -&amp;gt; A -&amp;gt; B.
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;注&#34;&gt;注：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;任务的总个数为 [1, 10000]。&lt;/li&gt;
&lt;li&gt;n 的取值范围为 [0, 100]。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第621题&#34;&gt;来源：力扣（LeetCode）第621题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/task-scheduler&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/task-scheduler&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;写在队列的标签里，本质上用的却是贪心算法，不知道为什么，同时还用到了一点hashmap的知识。&lt;/p&gt;

&lt;h2 id=&#34;思路&#34;&gt;思路：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;要知道最短时间首先要找到出现次数最多的那个值，如果出现次数一样多，选哪个都无所谓。&lt;/li&gt;
&lt;li&gt;然后看&lt;code&gt;A-Z&lt;/code&gt;中总共有几个数字出现了，假设最多次数的值是&lt;code&gt;A&lt;/code&gt;，那么第一个&lt;code&gt;A&lt;/code&gt;到第二个&lt;code&gt;A&lt;/code&gt;之间总共还能再放&lt;code&gt;n&lt;/code&gt;个不一样的值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A -&amp;gt; (单位时间) -&amp;gt; (单位时间) -&amp;gt; A -&amp;gt; (单位时间) -&amp;gt; (单位时间) -&amp;gt; A&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果填不满那就为&lt;code&gt;等待时间&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果填满了，那就说明不需要&lt;code&gt;等待时间&lt;/code&gt;就能得到最短时间，所以最短时间就是数组的长度。&lt;/li&gt;
&lt;li&gt;如果没填满，那么我们可以计算&lt;code&gt;(出现的次数最多的元素 - 1) * (n + 1) + 出现次数一样多的元素的个数&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;我们依靠出现的次数最多的元素&lt;code&gt;A&lt;/code&gt;把整个答案划分为a份(a为&lt;code&gt;A&lt;/code&gt;的次数)，每一份就是&lt;code&gt;n+1&lt;/code&gt;，由于最后一份不一定是&lt;code&gt;n+1&lt;/code&gt;，所以是&lt;code&gt;(a-1)*(n+1)&lt;/code&gt;，最后在把不相等的最后一份加进去就得到了答案。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def leastInterval(self, tasks: List[str], n: int) -&amp;gt; int:
        count = [0] * 26
        for task in tasks:
            count[ord(task) - 65] += 1  # 这里是我自己写的简单hash函数，也可以用字典，我这里觉得简单就没用字典。
        maxNum = max(count)
        maxCount = 0
        for c in count:
            if c == maxNum:
                maxCount += 1
        return max((maxNum - 1) * (n + 1) + maxCount, len(tasks))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为tasks的长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;第一次写贪心算法题，标签写错了，本来有想到贪心算法的，可是标签是队列我就一直在想队列，想了半天没有思路。&lt;/li&gt;
&lt;li&gt;贪心算法得到的有可能是近似解，在使用贪心算法时要想清楚特殊的情况。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>二叉树的后序遍历</title>
      <link>https://ripple-zjw.github.io/2019/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Fri, 23 Aug 2019 12:49:52 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>

&lt;h1 id=&#34;题目-二叉树的后序遍历&#34;&gt;题目：二叉树的后序遍历&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个二叉树，返回它的 后序 遍历。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,null,2,3]  
   1
    \
     2
    /
   3 
输出: [3,2,1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;进阶:递归算法很简单，你可以通过迭代算法完成吗？&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第145题&#34;&gt;来源：力扣（LeetCode）第145题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/binary-tree-postorder-traversal&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/binary-tree-postorder-traversal&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析：&lt;/h2&gt;

&lt;p&gt;方法有很多，递归法最简单，迭代法使用栈辅助完成，还有莫里斯遍历。本文讲解官方写的题解迭代法。虽然我也写出了迭代法，但是官方的解法既简单又高效，非常厉害。使用了迭代法+逆向工作法。&lt;/p&gt;

&lt;h2 id=&#34;思路&#34;&gt;思路：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;后序遍历是左，右，中。可是中在最后，如果正常解后序遍历的话有的复杂。&lt;/li&gt;
&lt;li&gt;如果我们用中，右，左这样来遍历的话岂不是将后序遍历变成了前序遍历的翻版类型。&lt;/li&gt;
&lt;li&gt;这样的话答案只是与我们要求的答案相反，翻转一下列表就可以了。&lt;/li&gt;
&lt;li&gt;所以解法就是一个反向的先序遍历方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;官方的迭代法+逆向工作法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
def postorderTraversal(self, root: TreeNode) -&amp;gt; List[int]:
    if root is None:
        return []
    stack = [root]
    res = []
    while stack:
        root = stack.pop()
        res.append(root.val)
        if root.left is not None:  # 先加左再加右，出栈的时候就是先加右，再加左。
            stack.append(root.left)
        if root.right is not None:
            stack.append(root.right)
    return res[::-1]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我自己写的迭代法，内容有点复杂，不是很好理解。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
def postorderTraversal(self, root):
    stack = []
    helper = []
    res = []
    while stack or root:
        while root:
            stack.append(root)
            root = root.left
        helper.append(stack[-1])
        root = stack.pop().right
        if root is None:
            res.append(helper.pop().val)
            while stack and stack[-1].left in helper and helper:
                res.append(helper.pop().val)
            while not stack and helper:
                res.append(helper.pop().val)
    return res
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;虽然我的方法写的多了一点，但是速度和官方的一样，甚至有时比官方解法快。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;两种方法相同，都是迭代法：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为树的所有节点。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;再一次遇到逆向工作法，事实证明如果你遇到问题解不开来反向解一下，思路清晰，易于求解。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>132模式</title>
      <link>https://ripple-zjw.github.io/2019/132%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 19 Aug 2019 22:52:15 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/132%E6%A8%A1%E5%BC%8F/</guid>
      <description>

&lt;h1 id=&#34;题目-132模式&#34;&gt;题目：132模式&lt;/h1&gt;

&lt;p&gt;给定一个整数序列：&lt;code&gt;a1, a2, ..., an&lt;/code&gt;，一个132模式的子序列&lt;code&gt;ai, aj, ak&lt;/code&gt;被定义为：当 &lt;code&gt;i &amp;lt; j &amp;lt; k&lt;/code&gt;时，&lt;code&gt;ai &amp;lt; ak &amp;lt; aj&lt;/code&gt;。设计一个算法，当给定有 n 个数字的序列时，验证这个序列中是否含有132模式的子序列。
- 注意：n 的值小于15000。&lt;/p&gt;

&lt;h5 id=&#34;示例1&#34;&gt;示例1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1, 2, 3, 4]
输出: False
解释: 序列中不存在132模式的子序列。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [3, 1, 4, 2]
输出: True
解释: 序列中有 1 个132模式的子序列： [1, 4, 2].
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-3&#34;&gt;示例 3:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [-1, 3, 2, 0]
输出: True
解释: 序列中有 3 个132模式的的子序列: [-1, 3, 2], [-1, 3, 0] 和 [-1, 2, 0].
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第456题&#34;&gt;来源：力扣（LeetCode）第456题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/132-pattern&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/132-pattern&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;分析&#34;&gt;分析：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;还是单调栈，不过还需要用到另一个方法，逆向工作法。反向遍历列表就会发现不一样的做法。&lt;/li&gt;
&lt;li&gt;根据题意&lt;code&gt;1&lt;/code&gt;代表最小元素，&lt;code&gt;3&lt;/code&gt;代表最大元素，&lt;code&gt;2&lt;/code&gt;代表次大元素&lt;/li&gt;
&lt;li&gt;通过单调递减栈找到最大元素的最大次大元素，然后再确定最小元素要比最大次大元素小。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;反向遍历列表。&lt;/li&gt;
&lt;li&gt;严格维护一个单调递减栈。&lt;/li&gt;
&lt;li&gt;一旦遇到一个大的元素，将栈内元素出栈，维护单调递减。入栈后，将自己作为题目中的最大元素，即中间的元素。&lt;/li&gt;
&lt;li&gt;将最后一个出栈的元素作为次大元素，即右边的元素。&lt;/li&gt;
&lt;li&gt;这样的好处是我找到的次大元素一定是与当前最大元素的值最近的，而且还在最大元素的后面。&lt;/li&gt;
&lt;li&gt;这样我只要在前面找到一个比次大元素小的值，也就是最小值，那么就是True。&lt;/li&gt;
&lt;li&gt;如果找不到，那么可能有两种情况。

&lt;ul&gt;
&lt;li&gt;第一种在最大元素和次大元素之间，最小值比最大的次大元素还要大，不符合题意。但是要维护单调递减栈，所以入栈。&lt;/li&gt;
&lt;li&gt;第二种在最大元素之上，那么用刚才的方法重新确定最大元素和次大元素。由于它在最大元素之上，当它为最大元素时它能包括之前的最大元素在内，重新确定的次大元素一定会比之前的次大元素大。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果遍历完为止都没有返回True，那么返回False。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;上代码&#34;&gt;上代码：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def find132pattern(self, nums: List[int]) -&amp;gt; bool:
        stack = []
        _min = float(&#39;-inf&#39;)
        for i in range(len(nums) - 1, -1, -1):
            if nums[i] &amp;lt; _min:
                return True
            while stack and stack[-1] &amp;lt; nums[i]:
                _min = stack.pop()
            stack.append(nums[i])
        return False
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为列表的长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;逆向工作法，如果你想不出来细节时可以考虑使用。&lt;/li&gt;
&lt;li&gt;我一开始的思路是正向遍历，维护一个单调递减栈。&lt;/li&gt;
&lt;li&gt;然后确定一个最小值，但是次大元素在右边，所以单调栈内无法找到次大元素。如果次大元素在左边的话，就可以直接正向单调递减了。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>验证二叉树的前序序列化</title>
      <link>https://ripple-zjw.github.io/2019/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96/</link>
      <pubDate>Mon, 19 Aug 2019 22:51:58 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
      <description>

&lt;h1 id=&#34;题目-验证二叉树的前序序列化&#34;&gt;题目：验证二叉树的前序序列化&lt;/h1&gt;

&lt;p&gt;序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     _9_
    /   \
   3     2
  / \   / \
 4   1  #  6
/ \ / \   / \
# # # #   # #
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;例如，上面的二叉树可以被序列化为字符串 &lt;code&gt;&amp;quot;9,3,4,#,#,1,#,#,2,#,6,#,#&amp;quot;&lt;/code&gt;，其中 &lt;code&gt;#&lt;/code&gt;代表一个空节点。&lt;/li&gt;
&lt;li&gt;给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。&lt;/li&gt;
&lt;li&gt;每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 &lt;code&gt;&#39;#&#39;&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如&lt;code&gt;&amp;quot;1,,3&amp;quot;&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;9,3,4,#,#,1,#,#,2,#,6,#,#&amp;quot;
输出: true
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;1,#&amp;quot;
输出: false
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-3&#34;&gt;示例 3:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;9,#,#,1&amp;quot;
输出: false
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第331题&#34;&gt;来源：力扣（LeetCode）第331题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;分析&#34;&gt;分析：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;就是每个爸爸都要找到两个儿子。(两个儿子可以是数字也可以是&lt;code&gt;#&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#&lt;/code&gt;爸爸什么都没有，比较惨。&lt;/li&gt;
&lt;li&gt;上面两条任意一条不对都不合法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;前序遍历严格遵守中，左，右的顺序。&lt;/li&gt;
&lt;li&gt;所以第一个为根节点，到第一个&lt;code&gt;#&lt;/code&gt;为止，前面这些数字都是根节点的最左边的左子节点&lt;/li&gt;
&lt;li&gt;维护一个栈&lt;code&gt;stack&lt;/code&gt;，栈中存的是未确认它是否有两个子节点的节点，就是说如果该节点找到了他的两个子节点，就出栈(&lt;code&gt;#&lt;/code&gt;也算它的子节点)。&lt;/li&gt;
&lt;li&gt;凡是找到数字，全都入栈，因为一开始找到数字，你只能确认它的左子节点是下一个值(数字或&lt;code&gt;#&lt;/code&gt;)，无法知道它的右子节点。&lt;/li&gt;
&lt;li&gt;当找到第一个&lt;code&gt;#&lt;/code&gt;时，开始遍历右子节点。因为没有左子节点了，遍历最近的节点的右子节点，也就是栈顶元素！！！&lt;/li&gt;
&lt;li&gt;一旦遍历了右子节点，那么该节点的左右子节点都找到了，出栈。&lt;/li&gt;
&lt;li&gt;接下来继续重复之前的规律，如果字符串合法，那么stack中的元素都被弹出去了，如果栈中还有元素，那么就说明有的元素找不到它的两个儿子。&lt;/li&gt;
&lt;li&gt;大概是这么个思路，不过还有些细节要处理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;看我写的代码&#34;&gt;看我写的代码：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def isValidSerialization(self, preorder: str) -&amp;gt; bool:
        if preorder == &#39;&#39;:
            return False
        if preorder == &#39;#&#39;:
            return True
        pol = preorder.split(&#39;,&#39;)  # PreOrderList
        stack = []  # 只有数字入栈，当确认了该数字的两个子节点后出栈
        n = len(pol)
        isLeftTree = True  # 如果现在遍历的是左子树的话，不用出栈，如果为右子树的话无论是什么都要出栈
        for i in range(n):
            if pol[i].isdigit():
                if not isLeftTree:
                    if not stack:  # 如果栈是空的还要弹元素的话说明这字符串不合法。
                        return False
                    stack.pop()
                stack.append(pol[i])  # 无论是左子树还是右子树，遇到数字都要入栈
                isLeftTree = True  # 如果遍历到的是数字的话，那么又开始遍历左子树了。
            else:
                isLeftTree = False  # 当左子树遍历到#号时那么左子树完了，开始遍历右子树。
                if pol[i - 1] == &#39;#&#39;:
                    if not stack:
                        return False
                    stack.pop()
        return len(stack) == 0  # 栈为空就说明合法，每一个节点都找到了它的两个子节点了。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为pol列表长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;p&gt;写的不是最优，总的来说就是将数据分为遍历左子树和右子树两种情况。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>移掉K位数字</title>
      <link>https://ripple-zjw.github.io/2019/%E7%A7%BB%E6%8E%89k%E4%BD%8D%E6%95%B0%E5%AD%97/</link>
      <pubDate>Mon, 19 Aug 2019 22:51:46 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E7%A7%BB%E6%8E%89k%E4%BD%8D%E6%95%B0%E5%AD%97/</guid>
      <description>

&lt;h1 id=&#34;题目-移掉k位数字&#34;&gt;题目：移掉K位数字&lt;/h1&gt;

&lt;p&gt;给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。&lt;/p&gt;

&lt;h5 id=&#34;注意&#34;&gt;注意:&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;num 的长度小于 10002 且 ≥ k。&lt;/li&gt;
&lt;li&gt;num 不会包含任何前导零。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例 1 :&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: num = &amp;quot;1432219&amp;quot;, k = 3
输出: &amp;quot;1219&amp;quot;
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-2&#34;&gt;示例 2 :&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: num = &amp;quot;10200&amp;quot;, k = 1
输出: &amp;quot;200&amp;quot;
解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-3&#34;&gt;示例 3 :&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: num = &amp;quot;10&amp;quot;, k = 2
输出: &amp;quot;0&amp;quot;
解释: 从原数字移除所有的数字，剩余为空就是0。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第402题&#34;&gt;来源：力扣（LeetCode）第402题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/remove-k-digits&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/remove-k-digits&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;分析&#34;&gt;分析：&lt;/h3&gt;

&lt;p&gt;维护一个单调递增栈，主要的方法很容易想到，但是在处理细节上我还是费了的时间，其实不难处理但是我想的有点复杂了。&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;维护一个单调递增栈。&lt;/li&gt;
&lt;li&gt;依次遍历整个字符串，将元素放入栈，同时使单调栈严格单调递增。&lt;/li&gt;
&lt;li&gt;如果已经弹出去k个元素了，那么剩下的值直接放入栈中即可，不用再删了。&lt;/li&gt;
&lt;li&gt;如果还没到k个元素字符串就遍历完了，那么根据剩下还要加的元素数量，从栈顶依次出栈。&lt;/li&gt;
&lt;li&gt;栈有可能是空，根据示例3，栈为空答案时&lt;code&gt;&amp;quot;0&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果栈有值，那么将栈合并为字符串，得出答案。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;激动人心的代码环节&#34;&gt;激动人心的代码环节：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def removeKdigits(self, num: str, k: int) -&amp;gt; str:
        stack = []
        cnt = 0
        n = len(num)
        for i in range(n):
            while cnt &amp;lt; k and stack and stack[-1] &amp;gt; num[i]:
                tmp = stack.pop()
                cnt += 1
            if stack or num[i] != &#39;0&#39;:
                stack.append(num[i])
        while stack and cnt &amp;lt; k:
            stack.pop()
            cnt += 1
        ans = &#39;&#39;.join(stack)
        return ans if ans != &#39;&#39; else &#39;0&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为字符串的长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n) n为k的长度&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;单调栈的思想越来越熟了，但是在处理细节上还是不够熟练。&lt;/li&gt;
&lt;li&gt;虽然自己第一遍做出来了，但是并没有想到最优算法，写的稍微有的啰嗦了。&lt;/li&gt;
&lt;li&gt;我觉得一开始没处理好是因为我忽略了k这个值，于是关于k的细节没有想得很全面，导致最后自己测试时总是会发现一些小错误，浪费时间。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>搭建Hugo时需要注意的坑</title>
      <link>https://ripple-zjw.github.io/2019/%E6%90%AD%E5%BB%BAhugo%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9D%91/</link>
      <pubDate>Sat, 17 Aug 2019 18:58:39 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%90%AD%E5%BB%BAhugo%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9D%91/</guid>
      <description>

&lt;h1 id=&#34;搭建hugo时需要注意的坑&#34;&gt;搭建Hugo时需要注意的坑&lt;/h1&gt;

&lt;p&gt;Hugo是一种博客框架，可以说是非常优秀的博客框架。基于go语言，网页生成的速度非常的快，而且下载简单，在GitHub上就能下载，还有官方的中文文档，操作也是很简单。但是对于刚开始搭建博客的小白，还是会遇到各种各样的问题，在这里我把我遇到的坑分享给各位读者。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;从GitHub上把Hugo下载下来会慢，当然也有人网速没问题。这个问题可以找网上的一些方法，比如改hosts文件。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可能有人和我一样下载完解压后在终端输入&lt;code&gt;hugo xxx&lt;/code&gt;的命令无效，那是因为系统找不到你要输的是什么东西，有两种解决方法。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一种是每次输入命令都带上你&lt;code&gt;hugo.exe&lt;/code&gt;文件的绝对路径，但是这样太麻烦了。&lt;/li&gt;
&lt;li&gt;第二种是将&lt;code&gt;hugo.exe&lt;/code&gt;添加到你系统的环境变量中，这样直接输入hugo就能启动命令了。&lt;/li&gt;
&lt;li&gt;设置方法为：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;控制面板 &amp;gt; 系统和安全 &amp;gt; 系统 &amp;gt; 高级系统设置 &amp;gt; 高级 &amp;gt; 环境变量&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;上下两个一个是用户变量，一个是系统变量，建议两个都设置。&lt;/li&gt;
&lt;li&gt;点击&lt;code&gt;Path&lt;/code&gt;变量，然后点击&lt;code&gt;新建&lt;/code&gt;，将你&lt;code&gt;hugo.exe&lt;/code&gt;的绝对路径目录添加进去，注意是目录。不要把&lt;code&gt;hugo.exe&lt;/code&gt;带进去。例如：你的目录为&lt;code&gt;c:/xxx/xxx/hugo.exe&lt;/code&gt;，你只要添加&lt;code&gt;c:/xxx/xxx&lt;/code&gt;就行了。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;主题是下载到&lt;code&gt;themes\&lt;/code&gt;文件夹中的，用git clone。如果不会使用git，请参考我关于git的文章&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下载完之后，里面基本都会有一个&lt;code&gt;exampleSite\&lt;/code&gt;文件夹，里面放的是一个样式，你可以直接把里面的&lt;code&gt;config.toml&lt;/code&gt;中的内容复制到你的博客主目录的&lt;code&gt;config.toml&lt;/code&gt;中。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;你博客根目录的&lt;code&gt;config.toml&lt;/code&gt;文件里要把&lt;code&gt;baseURL&lt;/code&gt;参数换成你的博客网站网址，如果你还没有部署到网上，可以填你的本地网址，就是那个默认端口1313的那个。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;你部署好之后，如果想要继续添加文章，首先使用&lt;code&gt;hugo&lt;/code&gt;命令重新生成&lt;code&gt;public/&lt;/code&gt;文件夹，然后在里面用git添加，提交，上传就行了。与第一次部署时的操作一样。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;### 以上差不多就是我遇到的坑。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>字符串解码</title>
      <link>https://ripple-zjw.github.io/2019/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</link>
      <pubDate>Sat, 17 Aug 2019 18:51:43 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</guid>
      <description>

&lt;h1 id=&#34;题目-字符串解码&#34;&gt;题目：字符串解码&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个经过编码的字符串，返回它解码后的字符串。&lt;/li&gt;
&lt;li&gt;编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。&lt;/li&gt;
&lt;li&gt;你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。&lt;/li&gt;
&lt;li&gt;此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&#34;示例&#34;&gt;示例:&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;s = &amp;quot;3[a]2[bc]&amp;quot;, 返回 &amp;quot;aaabcbc&amp;quot;.
s = &amp;quot;3[a2[c]]&amp;quot;, 返回 &amp;quot;accaccacc&amp;quot;.
s = &amp;quot;2[abc]3[cd]ef&amp;quot;, 返回 &amp;quot;abcabccdcdcdef&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第394题&#34;&gt;来源：力扣（LeetCode）第394题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/decode-string&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/decode-string&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;分析&#34;&gt;分析：&lt;/h3&gt;

&lt;p&gt;两种方法，辅助栈法和递归法，递归法相对思路清晰，比较好做。其实本质两种方法是一样的，因为函数的递归调用其实也是用栈来实现的。&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;递归法：

&lt;ul&gt;
&lt;li&gt;遍历整个字符串&lt;/li&gt;
&lt;li&gt;同时要用到stack列表，tmp列表，还有一个表示下标的变量i&lt;/li&gt;
&lt;li&gt;每次递归之后stack都是该函数的stack，与外面的stack不同&lt;/li&gt;
&lt;li&gt;每次遍历字符时，tmp都要将里面的值清空&lt;/li&gt;
&lt;li&gt;遇到字母，压入stack&lt;/li&gt;
&lt;li&gt;遇到&lt;code&gt;]&lt;/code&gt;字符,结束函数并将stack返回&lt;/li&gt;
&lt;li&gt;遇到数字首先判断该数字后是否还有数字，有的话一起加入tmp，然后递归调用函数。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;辅助栈法：

&lt;ul&gt;
&lt;li&gt;遍历整个字符串&lt;/li&gt;
&lt;li&gt;res表示当前字符串，multi表示当前数字，stack储存答案&lt;/li&gt;
&lt;li&gt;遇到字母，与res拼接起来&lt;/li&gt;
&lt;li&gt;遇到数字，放入multi，注意由于两个数字放在一起要变成两位数，以此类推，所以res 写成&lt;code&gt;res = res * 10 + 当前数字&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;遇到&lt;code&gt;[&lt;/code&gt;，将res，multi同时入栈，用一个列表或元祖，并行的，不是先后入栈。&lt;/li&gt;
&lt;li&gt;遇到右括号，栈顶元素出栈，并将栈顶元素的multi与当前字符相乘，然后再与栈顶的res相加&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;上代码&#34;&gt;上代码：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;递归法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def decodeString(self, s: str) -&amp;gt; str:
        self.i = 0
        return &#39;&#39;.join(self.recursion(s))
            
    def recursion(self, s: str) -&amp;gt; list:
        stack = []
        while self.i &amp;lt; len(s):
            tmp = []
            if s[self.i].isalpha():
                stack.append(s[self.i])
            elif s[self.i] == &#39;]&#39;:
                return stack
            elif s[self.i].isdigit():
                tmp.append(s[self.i])
                while s[self.i + 1].isdigit():
                    tmp.append(s[self.i + 1])
                    self.i += 1
                self.i += 2
                stack += (int(&#39;&#39;.join(tmp)) * self.recursion(s))
            self.i += 1
        return stack
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;辅助栈法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def decodeString(self, s: str) -&amp;gt; str:
        stack, res, multi = [], &amp;quot;&amp;quot;, 0
        for c in s:
            if c == &#39;[&#39;:
                stack.append([multi, res])
                res, multi = &amp;quot;&amp;quot;, 0
            elif c == &#39;]&#39;:
                cur_multi, last_res = stack.pop()
                res = last_res + cur_multi * res
            elif &#39;0&#39; &amp;lt;= c &amp;lt;= &#39;9&#39;:
                multi = multi * 10 + int(c)            
            else:
                res += c
        return res
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;辅助栈法不是我自己写的，可以参考LeetCode上的作者：
&amp;gt; &lt;a href=&#34;https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;递归法：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为字符串长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;辅助栈法：

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为字符串长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;递归是一种不错的尝试，很多时候递归的时间耗时并不是非常高，而且解题方便。&lt;/li&gt;
&lt;li&gt;写这种题目前需要理清各种情况时的行为。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>下一个更大元素</title>
      <link>https://ripple-zjw.github.io/2019/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0ii/</link>
      <pubDate>Sat, 17 Aug 2019 18:50:56 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0ii/</guid>
      <description>

&lt;h1 id=&#34;题目-下一个更大元素-ii&#34;&gt;题目：下一个更大元素 II&lt;/h1&gt;

&lt;p&gt;给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。&lt;/p&gt;

&lt;h6 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第503题&#34;&gt;来源：力扣（LeetCode）第503题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/next-greater-element-ii&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/next-greater-element-ii&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;分析&#34;&gt;分析：&lt;/h3&gt;

&lt;p&gt;循环数组和循环队列的样子差不多，这道题主要是单调栈，同样涉及两种解法，暴力法和单调栈法。这题的难点不在于单调栈，而是循环数组什么时候停下来。&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;由于是循环数组，如果只遍历一遍无法完全找到答案，所以我们遍历两边数组，使得数组较后的元素能与前面的元素比对。&lt;/li&gt;
&lt;li&gt;当下表(i)比数组的最后一个下表大时，i % len(数组)&lt;/li&gt;
&lt;li&gt;初始化所有答案均为-1(如果找不到最大的是-1，所以先全部等于-1)&lt;/li&gt;
&lt;li&gt;维护一个单调递减栈，入栈元素将比它小的栈内元素全部出栈，出栈元素的答案就是入栈元素。&lt;/li&gt;
&lt;li&gt;如此循环两次，如果栈内元素在两次循环之后均未能出栈(找到比它大的元素),那么它们就是数组中最大的元素，又由于我们初始化答案全部为-1，所以不用改变它们。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;上代码&#34;&gt;上代码:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution(object):
    def nextGreaterElements(self, nums):
        &amp;quot;&amp;quot;&amp;quot;
        :type nums: List[int]
        :rtype: List[int]
        &amp;quot;&amp;quot;&amp;quot;
        stack = []
        n = len(nums)
        res = [-1 for _ in nums]
        for i in range(2 * n):
            while stack and nums[i % n] &amp;gt; nums[stack[-1]]:
                res[stack.pop()] = nums[i % n]
            stack.append(i % n)
        return res
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一并给出暴力法(时间太长，会超时)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def nextGreaterElements(self, nums: List[int]) -&amp;gt; List[int]:
        n = len(nums)
        ans = []
        for i in range(n):
            j = i
            while True:
                j = (j + 1) % n
                if nums[j] &amp;gt; nums[i]:
                    ans.append(nums[j])
                    break
                if j + 1 == i:
                    ans.append(-1)
                    break
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;复杂地分析&#34;&gt;复杂地分析:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;暴力法:&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂地：O(n^2^)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;单调栈法:

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n为数组长度

&lt;ul&gt;
&lt;li&gt;最好情况 n = 3n&lt;/li&gt;
&lt;li&gt;最差情况 n = 4n&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n) n为数组长度 n = 2n(最差)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;使用单调栈解这类题目非常合适。&lt;/li&gt;
&lt;li&gt;如果实在无法找到结束循环点，不妨全部再遍历一遍数组。&lt;/li&gt;
&lt;li&gt;单调栈不一定要全部将栈中的元素都拿出来，如果有元素没有合适的答案，留在栈中也是可以的。&lt;/li&gt;
&lt;li&gt;初始化答案数组是一个不错方法，保证数组内的元素在找不到合适的答案时也能满足题目要求。(比如这道题说如果没有比它大的元素，那么它的答案为-1，所以我们就全部初始化为-1)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>扁平化嵌套列表迭代器</title>
      <link>https://ripple-zjw.github.io/2019/%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Sat, 17 Aug 2019 18:50:30 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>

&lt;h1 id=&#34;题目-扁平化嵌套列表迭代器&#34;&gt;题目:扁平化嵌套列表迭代器&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;给定一个嵌套的整型列表。设计一个迭代器，使其能够遍历这个整型列表中的所有整数。&lt;/li&gt;
&lt;li&gt;列表中的项或者为一个整数，或者是另一个列表。&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;输入: [[1,1],2,[1,1]]
输出: [1,1,2,1,1]
解释: 通过重复调用 next 直到 hasNext 返回false，next 返回的元素的顺序应该是: [1,1,2,1,1]。
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,[4,[6]]]
输出: [1,4,6]
解释: 通过重复调用 next 直到 hasNext 返回false，next 返回的元素的顺序应该是: [1,4,6]。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第341题&#34;&gt;来源：力扣（LeetCode）第341题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/flatten-nested-list-iterator&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/flatten-nested-list-iterator&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;分析&#34;&gt;分析：&lt;/h3&gt;

&lt;p&gt;递归调用，不是很难。唯一要注意的是要看清题目，list里面是NestedIterator，需要使用他给你的方法调用才能得到integer或者list。&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;从后往前遍历&lt;/li&gt;
&lt;li&gt;判断是否是integer，是  入栈  不是  递归进去&lt;/li&gt;
&lt;li&gt;返回栈，结束。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# &amp;quot;&amp;quot;&amp;quot;
# This is the interface that allows for creating nested lists.
# You should not implement it, or speculate about its implementation
# &amp;quot;&amp;quot;&amp;quot;
#class NestedInteger(object):
#    def isInteger(self):
#        &amp;quot;&amp;quot;&amp;quot;
#        @return True if this NestedInteger holds a single integer, rather than a nested list.
#        :rtype bool
#        &amp;quot;&amp;quot;&amp;quot;
#
#    def getInteger(self):
#        &amp;quot;&amp;quot;&amp;quot;
#        @return the single integer that this NestedInteger holds, if it holds a single integer
#        Return None if this NestedInteger holds a nested list
#        :rtype int
#        &amp;quot;&amp;quot;&amp;quot;
#
#    def getList(self):
#        &amp;quot;&amp;quot;&amp;quot;
#        @return the nested list that this NestedInteger holds, if it holds a nested list
#        Return None if this NestedInteger holds a single integer
#        :rtype List[NestedInteger]
#        &amp;quot;&amp;quot;&amp;quot;

class NestedIterator(object):  # 注意看清上面的方法都是干什么的，虽然是英文但是也比较容易看懂。
    def __init__(self, nestedList):
        &amp;quot;&amp;quot;&amp;quot;
        Initialize your data structure here.
        :type nestedList: List[NestedInteger]
        &amp;quot;&amp;quot;&amp;quot;
        self.stack = []
        self.recursion(nestedList)


    def recursion(self, nestedList):
        for i in range(len(nestedList) - 1, -1, -1):
            if nestedList[i].isInteger():
                self.stack.append(nestedList[i].getInteger())
            else:
                self.recursion(nestedList[i].getList())


    def next(self):
        &amp;quot;&amp;quot;&amp;quot;
        :rtype: int
        &amp;quot;&amp;quot;&amp;quot;
        return self.stack.pop()
        

    def hasNext(self):
        &amp;quot;&amp;quot;&amp;quot;
        :rtype: bool
        &amp;quot;&amp;quot;&amp;quot;
        return len(self.stack) &amp;gt; 0

# Your NestedIterator object will be instantiated and called as such:
# i, v = NestedIterator(nestedList), []
# while i.hasNext(): v.append(i.next())
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n) n 为整个列表的元素，也就是最后stack里的元素。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;p&gt;还是很简单的，只要递归写的稍微熟练一点都能写的出来。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>二叉树的锯齿形层次遍历</title>
      <link>https://ripple-zjw.github.io/2019/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sat, 17 Aug 2019 18:48:01 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</guid>
      <description>

&lt;h1 id=&#34;题目-二叉树的锯齿形层次遍历&#34;&gt;题目: 二叉树的锯齿形层次遍历&lt;/h1&gt;

&lt;p&gt;给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。&lt;/p&gt;

&lt;h6 id=&#34;例如&#34;&gt;例如：&lt;/h6&gt;

&lt;p&gt;给定二叉树 [3,9,20,null,null,15,7],&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    3
   / \
  9  20
    /  \
   15   7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回锯齿形层次遍历如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  [3],
  [20,9],
  [15,7]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第103题&#34;&gt;来源：力扣（LeetCode）第103题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;分析&#34;&gt;分析:&lt;/h3&gt;

&lt;p&gt;层次遍历比较简单，主要是锯齿形，就是单数层从左到右，双数层从右到左。网上有很多题解，看了他们的之后觉得没有自己的好，他们基本都是使用了反转列表的操作，理论上会很耗时间。所以，我讲的是自己写的思路。&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;运用双栈法，分别储存单数层和双数层两种情况。&lt;/li&gt;
&lt;li&gt;ans为返回的总列表，res为每一层的答案，stack和helper是两个栈，方法和之前的前、中序遍历差不多。&lt;/li&gt;
&lt;li&gt;写一个主循环while，再写两个循环放在主循环中，一个遍历单数层，一个遍历双数层。&lt;/li&gt;
&lt;li&gt;两个循环里把双栈中的节点拿出来，同时也把节点的两个子节点(stack或者helper)以及他们的值(res)也存起来。&lt;/li&gt;
&lt;li&gt;最后将res的值加到ans中。主循环结束，ans值也都进去了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -&amp;gt; List[List[int]]:
        if root is None:
            return []
        stack = []
        helper = [root]
        res = []
        ans = [[root.val]]
        cnt = 1
        while stack or helper:
            for i in range(cnt):
                tail = helper.pop()
                if tail.right is not None:
                    stack.append(tail.right)
                    res.append(tail.right.val)
                if tail.left is not None:
                    stack.append(tail.left)
                    res.append(tail.left.val)
            if res:
                ans.append(res)
                res = []
                cnt = len(stack)
            else:
                break
            for i in range(cnt):
                tail = stack.pop()
                if tail.left is not None:
                    helper.append(tail.left)
                    res.append(tail.left.val)
                if tail.right is not None:
                    helper.append(tail.right)
                    res.append(tail.right.val)
            if res:
                ans.append(res)
                res = []
                cnt = len(helper)
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;虽然有一个while，两个for，但是其实只遍历了一遍节点，而且没有额外的其他耗时操作，也没有递归&lt;/li&gt;
&lt;li&gt;所以时间复杂度为O(n) n为树的总节点&lt;/li&gt;
&lt;li&gt;空间复杂度为O(n)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结:&lt;/h1&gt;

&lt;p&gt;双栈法的另一个用处，当遇到在一个循环里但是其中两次循环的条件不一眼时，可以写两个循环分别运算，再用一个主循环让两个循环不会结束。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>二叉搜索树迭代器</title>
      <link>https://ripple-zjw.github.io/2019/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Thu, 15 Aug 2019 16:42:03 +0800</pubDate>
      
      <guid>https://ripple-zjw.github.io/2019/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>

&lt;h2 id=&#34;题目-二叉搜索树迭代器&#34;&gt;题目：二叉搜索树迭代器&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。&lt;/li&gt;
&lt;li&gt;调用 next() 将返回二叉搜索树中的下一个最小的数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&#34;示例&#34;&gt;示例：&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;BSTIterator iterator = new BSTIterator(root);
iterator.next();    // 返回 3
iterator.next();    // 返回 7
iterator.hasNext(); // 返回 true
iterator.next();    // 返回 9
iterator.hasNext(); // 返回 true
iterator.next();    // 返回 15
iterator.hasNext(); // 返回 true
iterator.next();    // 返回 20
iterator.hasNext(); // 返回 false
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;提示&#34;&gt;提示：&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;next() 和 hasNext() 操作的时间复杂度是 O(1)，并使用O(h)内存，其中 h 是树的高度。&lt;/li&gt;
&lt;li&gt;你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 中至少存在一个下一个最小的数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;来源-力扣-leetcode-第173题&#34;&gt;来源：力扣（LeetCode）第173题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&#34;https://leetcode-cn.com/problems/binary-search-tree-iterator&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/binary-search-tree-iterator&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;二叉搜索树的性质，任何一个节点的左子树都比自己小，任何一个节点的右子树都比自己大。&lt;/li&gt;
&lt;li&gt;然后它还有一个性质，我在哪个地方看到的有点不记得了。就是将二叉搜索树中序遍历之后得到的值是从小到大排列的有序列表。&lt;/li&gt;
&lt;li&gt;所以将二叉搜索树中序遍历就能拿到它的最小值到最大值&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;看代码吧&#34;&gt;看代码吧:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;class BSTIterator:
    def __init__(self, root: TreeNode):
        stack = []
        self.ans = []  # 储存答案
        tail = root
        while stack or tail is not None:  # 中序遍历
            if tail:
                stack.append(tail)
                tail = tail.right  # 注意和中序遍历稍有不同，因为我是用出栈的方式拿到最小值的，判断也是ans是否为空。所以我是反向的中序遍历，即中序遍历是左，中，右。而我是右，中，左。这样栈顶元素就是最小的值。
            else:
                tail = stack.pop()
                self.ans.append(tail.val)
                tail = tail.left  # 本质还是中序遍历，不用反向的应该也能做出来

    def next(self) -&amp;gt; int:
        return self.ans.pop()  # 最小值出栈，绝对的O(1)
        
    def hasNext(self) -&amp;gt; bool:
        return len(self.ans) != 0  # 这就更不用说了
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;整个程序只有中序遍历耗点时，其它两个操作根本不耗时。&lt;/li&gt;
&lt;li&gt;while 循环遍历整个树，&lt;/li&gt;
&lt;li&gt;时间复杂度应该是 O(n) n为树的节点总和&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;

&lt;p&gt;二叉搜索树的中序遍历就是将二叉搜索树从小到大排列。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>